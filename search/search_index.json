{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"C++17 - Iterating Problems","text":"<p>Subtitle: The C++ Book Only The Author Will Read Author: Daniel Rodriguez Revision Date: June 2025 Version: 1.3.19</p> <p>Use the navigation menu on the left-hand side panel to access the different sections.</p> <p>Have fun.</p>"},{"location":"0007-preface/","title":"Introduction","text":"<p>In our modern times and with the advent of Artificial Intelligence, there are many prophets that have loudly announced the end of programmers as a species. And they are probably right. The exact moment in time still remains a mystery.</p> <p>Until then, a hobby programmer, like your humble author, can still decide to tackle some programming challenges using C++. This is something I have done in the past to keep myself updated with the incredible changes that have introduced into the language since the C++11 standard was brought to life.</p> <p>Considering that the last serious period of time was back in 2016, it was already time to bring myself up to date. My first intention was to use CodeEval, the platform I used in the past, but the platform is gone for good. The second obvious choice was HackerRank, simply because I tested it a couple of times and my account was still there.</p> <p>Seeing C++20 as one of the choices, skipping the C++17 wave seemed like a good choice. Unfortunately, the C++20 selection was simply a label from a <code>clang</code> compiler version with a couple of features from the end of 2017, and for sure not the next best standard sanctioned in 2020.</p> <p>On the bright side, HackerRank does not lock the editor for this C++20 label. It does in some, not all, instances of problems for previous versions. This is something I could use to my advantage to provide complete solutions, rather than solving the problem by filling out just one method.</p> <p>This gave me an idea, that later led to this book/blog/static site, call-it-x if you wish. I could rethink the problems and address them as something much bigger, forcing myself along the way to work with as many features of C++17 as possible. And as it usually happens in life, one idea led to the next: solve the challenges using iterators as much as possible.</p> <p>The STL (Standard Template Library) was already a thing when I had my first contact with C++, even if C++98 was yet to be conceived. Back then, I hit a wall when I first tried to love iterators, until one day something made \u201cclick\u201d and the idea seemed simple but incredibly brilliant. Hence the thought of solving everything now with iterators, even a simple \u201cHello, World!\u201d challenge.</p>"},{"location":"0007-preface/#the-chapters-and-their-content","title":"The Chapters and Their Content","text":"<p>Each chapter presents several solutions to a given challenge. Even more, a challenge can be revisited in a second chapter to go above and beyond. Usually, the simplistic, obvious and boring solution is presented first as the starting point. After that, several solutions are presented, showing different approaches and/or the evolution to a generic iterator based solution.</p> <p>Not all the solutions are meant to succeed in solving the problem. Some of them are meant to show where a human being, the author, fails at quickly identifying what one must do.</p> <p>If a solution introduces new concepts, be it from C++17 or previous standards, it is specifically mentioned. That is the whole point of the exercise, apply a variety of techniques and the tools of the C++ arsenal, embedding that knowledge deep in one's brain.</p> <p>I have obviously read blogs and quickly scanned books and seen C++ online reference guides over the years. And I have used the reference guides during the writing of this text, if I doubted how to correctly use something, looking also for alternatives and to explore member functions of containers, for example.</p> <p>But I want to say something: if I have not understood a concept or technique, I have not used it. Copying code is something even AI can do, but that would not bring me personally any further. It is not about solving the problem with someone else's code and ideas, it is about doing it myself, because I understand how to do those things.</p> <p>Savvy C++ programmers will obviously identify several areas of improvement, obvious errors and even things that work due to sheer luck. They should not hesitate to provide feedback on the repository as that will bring me one step closer to better understand and use C++. As a hobby programmer of course, but a programmer nonetheless.</p> <p>Note</p> <p>In other cases I simply left things a bit untidy, because my other life (the real one) has a higher priority and an incredible gravitational pull. Please, be lenient with this humble coder.</p> <p>Let me finish by saying that writing this in the form of a book has really helped me. Telling a story and wanting to improve the solutions to be generic and iterator based, has improved my focus and made me a better C++ hobby programmer++. Or so do I believe, because as a kid I thought I was so good I could play professional soccer and that never ever crystallized.</p>"},{"location":"0007-preface/#navigating-the-code","title":"Navigating The Code","text":"<p>The code for the chapters follows the chapter numbering and has this form: <code>xy-descriptive-text</code>, where <code>xy</code> is a series of two digits that matches the chapter in which the solutions in that folder are developed and shown.</p> <p>Going inside the folder each solution has also this form: <code>descriptive-text-ab.cpp</code>. Once again the <code>ab</code> placeholder stands for two digits, following the order in which the solutions are presented in the chapter.</p> <p>One can test each solution inside the folder with: <code>make ab</code>. This will compile <code>descriptive-text-ab.cpp</code> and execute the binary <code>descriptive-text-ab</code> (with the extension <code>.exe</code> under Windows), feeding it a test case and evaluating the output against the well-known result.</p> <p>Beware: the <code>Makefile</code> uses GNU Make extensions, to look for files, parse names, generate the targets, build the solutions, test them and present the results.</p> <p>A failed test case will show the expected output, the actual output and the difference of the two. This can be forced for positive test cases with <code>make show ab</code>. If in doubt, just run <code>make</code> or <code>make help</code> to see the available options (like an obvious <code>make all</code> to compile and test all solutions)</p> <p>That was it for each individual challenge. Executing <code>make xy</code> from the top code directory, will enter the <code>xy-descriptive-text</code> directory and compile and test all solutions with <code>make all</code>. At this root level a <code>make all</code> is also possible to compile and test all the solutions for all the challenges.</p> <p>If you add a new solution following the aforementioned conventions, the <code>Makefile</code> will automatically be able to compile and test it. That is: <code>make ij</code> will work, where <code>ij</code> are the digits you will have assigned to your solution with this convention: <code>xy-descriptive-test/descriptive-test-ij.cpp</code>.</p>"},{"location":"0007-preface/#final-words","title":"Final Words","text":"<p>Hopefully someone finds something interesting here and not only the author enjoys the content and the process of having crafted it.</p>"},{"location":"0010-hello-world/","title":"Hello World","text":"<p>Title: Hello, World! Link: https://www.hackerrank.com/challenges/cpp-hello-world </p> <p>Getting started with any programming language always implies a \u201cHello World\u201d example and HackerRank also has this challenge to get problem solvers started with C++. Solving the problem is obvious, but the goal was not to make obvious things. Rethinking the problem to make something useful out of it is the real challenge. Let us see how to rework this into something interesting.</p> <p>We first draft the obvious solution, considering that the expected output is: \u201cHello, World!\u201d.</p> <pre><code>#include &lt;iostream&gt; // std::cout\n\nint\nmain(int, char *[]) {\n    std::cout &lt;&lt; \"Hello, World!\";\n    return 0;\n}\n</code></pre> <p>GitHub: 01-hello-world/hello-world-01.cpp </p> <p>There it is. The solution does not even require a <code>\\n</code> (or <code>std::endl</code>) after printing the message. But notice that a comma, followed by a space, is used as a delimiter unlike in many other cases. That will be our first challenge.</p>"},{"location":"0010-hello-world/#using-an-output-iterator","title":"Using an Output Iterator","text":"<p>Because the goal is to solve the problems, where possible, with a Standard Library approach, the solution above is not really satisfying. Let us therefore introduce a classic from the STL: iterators. We will be adding an output iterator to the mix, in this case: <code>std::ostream_iterator</code>, that will take over the functionality of <code>std::cout</code>.</p> <pre><code>#include &lt;iostream&gt; // std::cout\n#include &lt;iterator&gt; // std::ostream_iterator\n\nint\nmain(int, char *[]) {\n    auto out = std::ostream_iterator&lt;std::string&gt;{std::cout};\n    *out++ = \"Hello, World!\";\n    return 0;\n}\n</code></pre> <p>GitHub: 01-hello-world/hello-world-02.cpp </p> <p>We have added our output iterator, initially managing it manually with the <code>*</code> (dereference) and <code>++</code> (postfix increment) operators to output our string for us. This still bears no resemblance to an STL solution. Luckily, our <code>std::ostream_iterator</code> can take a second parameter during construction, which is the delimiter to be used after each output operation. We can use it to get closer to the final goal.</p> <p>Notice that we have used <code>std::string</code> with <code>std::ostream_iterator</code>. We could have used a good old <code>const char *</code> but our focus is the Standard Library.</p>"},{"location":"0010-hello-world/#adding-input-iterators","title":"Adding Input Iterators","text":"<p>Let us now simulate that there is also input, by managing \u201cHello\u201d and \u201cWorld!\u201d as separate tokens and making the \u201c, \u201d delimiter a part of the output operation and not part of the content itself.</p> <pre><code>#include &lt;array&gt; // std::array\n#include &lt;iostream&gt; // std::cout\n#include &lt;iterator&gt; // std::ostream_iterator\n\nint\nmain(int, char *[]) {\n    auto hello_world = std::array{\"Hello\", \"World!\"}; // input range\n    auto out = std::ostream_iterator&lt;std::string&gt;{std::cout, \", \"}; // with delim\n    for(auto in = hello_world.begin(), last = hello_world.end(); in != last;)\n        *out++ = *in++; // input to output, move both to next position\n    return 0;\n}\n</code></pre> <p>GitHub: 01-hello-world/hello-world-03.cpp </p> <p>This is much better. By using an <code>std::array</code> to hold the two words in our message, we can use the <code>begin</code> and <code>end</code> methods to iterate over the input range and then output each element with our iterator. Even for this simple case, we obviously avoid checking against <code>end()</code> each and every time. Imagine if we did that for an array of millions of elements, instead of storing the <code>last</code> iterator in a variable.</p> <p>We are using the C++17 <code>std::array</code> facilities, with which it is possible to forego the template syntax, avoiding the need to specify the type of the array elements and the array size. The compiler will do it for us. And this is yet another reason <code>std::string</code> was a good choice as the type for <code>std::ostream_iterator</code>. We could quickly find out if the compiler is choosing <code>const char *</code>, however by choosing <code>std::string</code> there is no need to worry, because it will be converted to a <code>std::string</code> when moving it to the output.</p> <p>In any case this solution fails to pass the test because the output has a trailing comma.</p> <pre><code>Hello, World!,\n</code></pre> <p>An improvement is still possible, by using a range based <code>for</code> loop, instead of manually controlling the iteration.</p> <pre><code>#include &lt;array&gt; // std::array\n#include &lt;iostream&gt; // std::cout\n#include &lt;iterator&gt; // std::ostream_iterator\n\nint\nmain(int, char *[]) {\n    auto hello_world = std::array{\"Hello\", \"World!\"}; // input range\n    auto out = std::ostream_iterator&lt;std::string&gt;{std::cout, \", \"}; // with delim\n    for(const auto &amp;hw: hello_world) // range based for loop\n        *out++ = hw; // val to output and move output\n    return 0;\n}\n</code></pre> <p>GitHub: 01-hello-world/hello-world-04.cpp </p> <p>Some syntactic sugar that simplifies the look of our <code>for</code> loop and removes the direct use of the input iterators from the equation. The change implies no change for the result: still a failure due to the aforementioned trailing comma.</p>"},{"location":"0010-hello-world/#adding-an-stl-algorithm","title":"Adding an STL Algorithm","text":"<p>One of the goals was to use the STL as much as possible. And there is an ideal target for us: <code>std::copy</code>, which takes an input range and copies each element to a destination range, by taking an iterator that points to the first element of the output range. This destination iterator has to be at least an output iterator. We already have those elements at hand: an input range and an output iterator.</p> <pre><code>#include &lt;algorithm&gt; // std::copy\n#include &lt;array&gt; // std::array\n#include &lt;iostream&gt; // std::cout\n#include &lt;iterator&gt; // std::ostream_iterator\n\nint\nmain(int, char *[]) {\n    auto hello_world = std::array{\"Hello\", \"World!\"}; // input range\n    auto out = std::ostream_iterator&lt;std::string&gt;{std::cout, \", \"}; // with delim\n    std::copy(hello_world.begin(), hello_world.end(), out); // copy range =&gt; out\n    return 0;\n}\n</code></pre> <p>GitHub: 01-hello-world/hello-world-05.cpp </p> <p>Using <code>std::copy</code> has allowed us to simplify the solution. We no longer need to hold the result of <code>end()</code> in a variable and there is no need to manually operate on the iterators. The algorithm does all the <code>*</code> and <code>++</code> heavy lifting for us. This may seem like an overkill for this case, but the goal is to make use of the existing facilities. Reinventing the wheel can be a viable solution if an extreme optimization is needed. In any case, the people writing the algorithms for the STL, including several specializations, can write much better code than we do.</p> <p>Unfortunately, the trailing comma is still there.</p> <pre><code>Hello, World!,\n</code></pre> <p>Expecting anything else would have been naive because <code>std::copy</code> is using our instance of <code>std::ostream_iterator</code>, as we did before.</p>"},{"location":"0010-hello-world/#a-custom-output-iterator","title":"A Custom Output Iterator","text":"<p>This is where extra thinking and development are needed to square the circle: a custom output iterator! Although one has to be humble and admit it will only be a wrapper around the <code>std::ostream_iterator</code> functionality. But what a mighty wrapper because it will take over the management of the delimiter.</p> <pre><code>template &lt;typename T&gt;\nclass os_iterator {\n    std::ostream_iterator&lt;T&gt; m_iter; // wrapped iterator\n    T m_delim; // delimiter between elements\n    bool m_dodelim = false; // when to start separating\n\npublic:\n    // needed for an iterator\n    using iterator_category = std::output_iterator_tag;\n\n    // constructor replicating the wrapped iterator's constructor\n    os_iterator(std::ostream &amp;os, const T &amp;delim) : m_iter{os}, m_delim{delim} {}\n\n    // no-ops because only the assignment (= operator does something)\n    auto operator -&gt;() { return this; }\n    auto &amp;operator *() { return *this; }\n    auto &amp;operator ++() { return *this; } // ++prefix\n    auto &amp;operator ++(int) { return *this; } // postfix++\n\n    // Operation with the wrapped iterator, choosing when to output the sep\n    auto &amp;operator =(const T &amp;outval) {\n        if (m_dodelim) // output delimiter before the second/later elements\n            *m_iter++ = m_delim;\n        else\n            m_dodelim = true;\n\n        *m_iter++ = outval;\n        return *this;\n    }\n};\n</code></pre> <p>GitHub: 01-hello-world/hello-world-06.cpp:6:35 </p> <p>In order to be useful, the wrapper has to be template based to mimic the original. It can then provide the operations that one will manually use, as we saw with <code>*out++ = val;</code>, and account for the possibility of other operations being used by the algorithm inside the STL operation. That is why both <code>++</code> increment operators, prefix, and postfix, are available. Those and the <code>*</code> dereference operator are simple NOP commands.</p> <p>The real work is done with the <code>=</code> assignment operator, when the iterator is given the value that has to be output. That is where the decision to output the delimiter is done. And it is done just before outputting the value, for all assignments except for the first, which is controlled with a boolean, <code>m_dodelim</code>. The STL outputs the delimiter after the fact, we do it before, changing the logic.</p> <p>Anyone who also knows Python will notice that we are replicating the <code>'delimiter'.join(iterable of str)</code> functionality, that creates a string by joining the iterable with the delimiter in between elements, except after the last element. Even better, we do not need our range to be made out of strings, because of the generic functionality templates offer us. Granted, in Python the iterable of strings can be quickly achieved with <code>(str(x) for x in iterable)</code>.</p> <p>Defining the <code>iterator_category</code> in our custom iterator is compulsory and the alias we set it to, is the obvious choice: <code>std::output_iterator_tag</code>, because that is what our custom iterator and the wrapped one are doing: output.</p> <p>One final note about this custom iterator. The usual implementation of the <code>++</code> postfix operator looks like this.</p> <pre><code>    auto operator ++(int) { auto tmp = *this; ++(*this); return tmp; }\n</code></pre> <p>But because our <code>operator *()</code> and <code>operator ++()</code> are NOP implementations returning a reference to itself, creating a <code>tmp</code> copy is not needed and we can implement <code>++(int)</code> also as an NOP.</p> <p>The new main function that goes with it looks like this.</p> <pre><code>int\nmain(int, char *[]) {\n    auto hello = std::array{\"Hello\", \"World!\"};\n    auto out = os_iterator&lt;std::string&gt;{std::cout, \", \"};\n    std::copy(hello.begin(), hello.end(), out);\n    return 0;\n}\n</code></pre> <p>GitHub: 01-hello-world/hello-world-06.cpp:37 </p> <p>This delivers the expected solution output, with no trailing \u201c, \u201d delimiter at the end.</p> <pre><code>Hello, World!\n</code></pre> <p>But more importantly, our solution is just one step away from one of the declared goals: be STL-like. The general form we will be looking for is the one taking an input range and accepting also the beginning of a destination (or output) range.</p>"},{"location":"0010-hello-world/#an-stl-like-solution","title":"An STL-like Solution","text":"<p>It may seem like something redundant to go any for it, because <code>std::copy</code> is already part of the STL, but let us go for our own STL-like solution.</p> <pre><code>template &lt;typename I, typename O&gt;\nauto\nhello_world(I first, I last, O out) {\n    return std::copy(first, last, out);\n}\n\nint\nmain(int, char *[]) {\n    auto hello = std::array{\"Hello\", \"World!\"};\n    auto out = os_iterator&lt;std::string&gt;{std::cout, \", \"};\n    hello_world(hello.begin(), hello.end(), out);\n    return 0;\n}\n</code></pre> <p>GitHub: 01-hello-world/hello-world-07.cpp:37 </p> <p>Our newly defined <code>hello_world</code> has the final form we will be trying to use for each and every solution. We have obviously used <code>I</code> for \u201cInput\u201d and <code>O</code> for \u201cOutput\u201d to make things as clear as possible.</p>"},{"location":"0010-hello-world/#summary","title":"Summary","text":"<p>A simple 1-statement solution has been turned into a basic model for future solutions. By converting the non-input (constant value) into an iterable input range, wrapping the output iterator into our own custom iterator, we are able to control the presentation and model the final solution function after the STL algorithms.</p> <p>Mission accomplished! Well, one of many missions to come.</p>"},{"location":"0020-input-and-output/","title":"Input and Output","text":"<p>Title: Input and Output Link: https://www.hackerrank.com/challenges/cpp-input-and-output </p> <p>After the classic, output-only \u201cHello, World!\u201d, we are confronted with first accepting input, performing then a simple manipulation of the data and sending finally the result to standard output. I.e.: read three integers from standard input, add them up and output the result.</p> <p>The straightforward simplistic solution.</p> <pre><code>#include &lt;iostream&gt; // std:cin/cout\n\nint\nmain(int, char *[]) {\n    int i1, i2, i3;\n    std::cin &gt;&gt; i1 &gt;&gt; i2 &gt;&gt; i3;\n    std::cout &lt;&lt; (i1 + i2 + i3);\n    return 0;\n}\n</code></pre> <p>GitHub: 02-input-and-output/input-and-output-01.cpp </p> <p>Not really the challenge we were looking for. Let us immediately go for a first iterator based version, using also <code>auto</code>.</p> <pre><code>#include &lt;iostream&gt; // std:cin/cout\n#include &lt;iterator&gt; // std::istream_iterator/ostream_iterator\n\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin};\n    auto out = std::ostream_iterator&lt;int&gt;{std::cout};\n    *out++ = *in++ + *in++ + *in++;\n    return 0;\n}\n</code></pre> <p>GitHub: 02-input-and-output/input-and-output-02.cpp </p> <p>Unlike in the \u201cHello, World!\u201d case, we have real input and that is why we introduce an iterator to gather the input: <code>std::istream_iterator</code>. Just like its counterpart the <code>std::ostream_iterator</code>, it takes a stream (an input one, obviously) and reads characters that will be converted to the type used in the template. Whitespace, including newlines, and End-of-file are used as the separators to discriminate the input values.</p> <p>The solution is not really satisfying, even if we can use iterators and apply <code>auto</code> to all variable declarations. It is still hardcoded to take three <code>int</code> values. Notice that we do not need to even store the values, thanks to the use of the input iterator.</p> <p>Moving forward is straightforward: if there is an input iterator, there must, for sure, be a counterpart marking the end of the stream. Recall that our input range in the previous solution had <code>begin</code>/<code>end</code> member functions precisely for that. Using here an end-of-stream iterator we could read integers until the input is exhausted, making the solution dynamic.</p> <p>Such end-of-stream input iterator is instantiated by not passing a stream to the constructor, i.e.: <code>std::istream_iterator&lt;int&gt;();</code>.</p> <p>At the same time, we can use the proper algorithm from the STL to add up all integers: <code>std::accumulate</code>. To spare us some boredom and as we did with the \u201cHello, World!\u201d problem, we will move the core of our solution, even if only a wrapper, directly to a generic function.</p> <pre><code>#include &lt;iostream&gt; // std:cin/cout\n#include &lt;iterator&gt; // std::istream_iterator/ostream_iterator\n#include &lt;numeric&gt; // std::accumulate\n\ntemplate&lt;typename I, typename O&gt;\nauto\ninput_and_output(I first, I last, O out, int init = 0) {\n    *out++ = std::accumulate(first, last, init);\n}\n\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin};\n    auto in_last = std::istream_iterator&lt;int&gt;{};\n    auto out = std::ostream_iterator&lt;int&gt;{std::cout};\n    input_and_output(in, in_last, out);\n    return 0;\n}\n</code></pre> <p>GitHub: 02-input-and-output/input-and-output-03.cpp </p> <p>For the sake of it, we may even go for a single statement solution inside of <code>main</code>.</p> <pre><code>#include &lt;iostream&gt; // std:cin/cout\n#include &lt;iterator&gt; // std::istream_iterator/ostream_iterator\n#include &lt;numeric&gt; // std::accumulate\n\ntemplate&lt;typename I, typename O&gt;\nauto\ninput_and_output(I first, I last, O out, int init = 0) {\n    *out++ = std::accumulate(first, last, init);\n}\n\nint\nmain(int, char *[]) {\n    input_and_output(\n        std::istream_iterator&lt;int&gt;{std::cin},\n        std::istream_iterator&lt;int&gt;{},\n        std::ostream_iterator&lt;int&gt;{std::cout}\n    );\n    return 0;\n}\n</code></pre> <p>GitHub: 02-input-and-output/input-and-output-04.cpp </p> <p>This is a lot more like it. If you look at how this is usually solved, the problem solver will first copy the input, to an <code>std::vector</code>, which will then be used as the input range for <code>std::accumulate</code>. I.e.: an input range is used to create another input range, that is then used for the solution. It really seems we are better off by directly using the available input range.</p>"},{"location":"0020-input-and-output/#checking-the-nature-of-the-iterators","title":"Checking the Nature of the Iterators","text":"<p>Stopping here would go against the goal of our quest, i.e.: learning, learning more, learning even more, be better and write better code. Let us therefore carry on by adding some checking for our template parameters with SFINAE.</p> <p>When I first heard about SFINAE I had to make sure I was getting it right: \u201cSubstitution Failure Is Not An Error\u201d. Because once I managed to wrap my head around it, I thought that SFIAFWAD would have been a better acronym: \u201cSubstitution Failure Is A Feature Working As Designed\u201d. No matter in which industry you have worked, it is quite often that an error is deemed to be a feature and tagged with the label, \u201cit works as designed\u201d. It is anyhow highly unlikely that my proposal would have probably made the cut for the naming.</p> <p>Let us see why we would have to use SFINAE. In our two solutions, we have modeled our functions in this manner.</p> Typical Solution Model<pre><code>template&lt;typename I, template typename O&gt;\nauto\nsolution_function(I first, I last, O out) {\n    std::do_something(first, last, out);\n    // or *out++ = std::do_something(first, last);\n}\n</code></pre> <p>Our STL-like <code>solution_function</code> accepts the (until compilation) unknown types <code>I</code> and <code>O</code> and pass them completely unchecked to <code>std::do_something</code>, or feeds the result of the latter to the output iterator.</p> <p>Inside the function, it is assumed that <code>I</code> is an input iterator and <code>O</code> is an output iterator, but we have no certainty if those assumptions are actually true. Compilation will most probably fail at some point if they are not, but it may also go through causing a spectacular runtime.</p> <p>We could do the following and our on-the-fly checking IDE will not complain: <code>solution_function(5, 6, out);</code>. Those two integers are, obviously, no iterators and it would be nice to catch the error as soon as possible, ideally whilst typing.</p> <p>Here is where SFINAE comes to the rescue. By imposing some restrictions and having the parameters checked during compilation or by our IDE, the iterators will be checked to see if they are really what they claim to be. SFINAE works by removing potential template candidates. There will be no match for our call if the arguments do no fit our restrictions.</p> <p>Yes, C++20 introduces <code>concepts</code> but we are still using C++17, so we have to settle for SFINAE, the next best thing after sliced bread. Our template-based <code>solution_function</code> will be enabled if some conditions are met. To implement that enabling (or disabling) we will be using <code>std::enable_if</code> as the basis. This utility function will fail if the boolean conditions passed to it are not met. But if the conditions are met, we will be able to use the type passed to it as the result. The general form is: <code>std::enable_if&lt;condition, enabler&gt;</code>, where in this case the enabler will be used as the return type of our <code>solution_function</code> algorithm.</p> <p>To use the <code>enabler</code> as a type, we have two options:</p> <ul> <li> <p><code>std::enable_if&lt;condition, enabler&gt;::type</code> (C++11)</p> </li> <li> <p><code>std::enable_if_t&lt;condition, enabler&gt;</code> (C++14)</p> </li> </ul> <p>We will go for the latter because it seems cleaner, <code>_t</code> for <code>::type</code>, and because C++17 introduced more of these helpers as we will see below, i.e.: others did also see the benefit in using the <code>_x</code> suffix as opposed to <code>::whatever_we_want</code>.</p> <p>The most obvious idea is checking if the parameters bear the proper iterator tags for their intended functionality. Let us add some vertical spacing here or the sake of clarity. We are going directly for the helper with <code>_v</code> for <code>::value</code> when using <code>std::is_same</code>.</p> SFINAE - Checking if something *is exactly* something<pre><code>template &lt;typename I, typename O&gt;\nstd::enable_if_t&lt;\n    // enable if condition\n    std::is_same_v&lt;\n        std::input_iterator_tag,\n        typename I::iterator_category&gt;\n    &amp;&amp;\n    std::is_same_v&lt;\n        std::output_iterator_tag,\n        typename O::iterator_category&gt;\n    ,\n    void\n    &gt; // get the type of the enable_if result\nsolution_function(I first, I last, O out) {\n    std::do_something(first, last, out);\n}\n</code></pre> <p><code>std::is_same_v</code>, a C++17 present, will be substituted with <code>true</code> or <code>false</code> during compilation. If the logical <code>and</code> test, of those conditions, has a single <code>false</code>, <code>std::enable_if_t</code> will fail and the candidate will be removed from the set of possible matches for an invocation of <code>solution_function</code>.</p> <p>This unfortunately has some problems.</p> <ul> <li> <p>We are checking with <code>std::is_same_v&lt;T&gt;</code> (aka <code>std::is_same&lt;T&gt;::value</code>) and our iterator could be not only an input iterator, but actually a lot more. A RandomAccessIterator is also an InputIterator that can do a lot more things.</p> </li> <li> <p>We check directly <code>I::iterator_category</code> and <code>I</code> (or <code>O</code>) could be a simple type like a <code>const char **</code>, that the STL can manage as an iterator. Compilation failure knocking on the door in 3, 2, 1.</p> </li> </ul> <p>Luckily for us, both issues have a solution.</p> <ul> <li> <p>Run the check with <code>std::is_base_of</code>. The function will check inside <code>std::input_iterator_tag</code> to see if it is the base class of whatever tag the iterator has declared in its implementation. This will then be a positive check not only for an InputIterator but for others too, such as the aforementioned RandomAccessIterator.</p> </li> <li> <p>Use <code>std::iterator_traits&lt;T&gt;</code> to look for the tag. This STL functionality understands what is and what can be an iterator and offers a unified interface to retrieve the actual declared <code>iterator_category</code> tag or the implied one in case of thingies such as <code>const char **</code>.</p> </li> </ul> <p>Let us apply all this to our <code>input_and_output</code> challenge. Using the <code>_v</code> variant of <code>std::is_base_of</code>, of course.</p> <pre><code>#include &lt;iostream&gt; // std:cin/cout\n#include &lt;iterator&gt; // std::istream_iterator/ostream_iterator\n#include &lt;numeric&gt; // std::accumulate\n#include &lt;type_traits&gt; // std::iterator_traits/enable_if/is_base_of\n\ntemplate &lt;typename I, typename O&gt;\nstd::enable_if_t&lt;\n    // enable if condition\n    std::is_base_of_v&lt;std::input_iterator_tag,\n        typename std::iterator_traits&lt;I&gt;::iterator_category&gt; &amp;&amp;\n    std::is_base_of_v&lt;std::output_iterator_tag,\n        typename std::iterator_traits&lt;O&gt;::iterator_category&gt;\n    ,\n    void&gt; // get the type of the enable_if result\ninput_and_output(I first, I last, O out, int init = 0) {\n    *out++ = std::accumulate(first, last, init);\n}\n\nint\nmain(int, char *[]) {\n    input_and_output(\n        std::istream_iterator&lt;int&gt;{std::cin},\n        std::istream_iterator&lt;int&gt;{},\n        std::ostream_iterator&lt;int&gt;{std::cout}\n    );\n    return 0;\n}\n</code></pre> <p>GitHub: 02-input-and-output/input-and-output-05.cpp </p> <p>There are two small improvements that still can make the cut.</p> <p>Let us first have a look at how <code>std::enable_if</code> is defined.</p> <pre><code>template&lt; bool B, class T = void &gt;\nstruct enable_if;\n</code></pre> <p>Great for us. We could skip the second template parameter because it is already <code>void</code>, exactly our return type. Improvement number one is already there.</p> <p>The second change deals with how we have defined the extra parameter <code>init</code> for our <code>input_and_output</code> solution.</p> <pre><code>input_and_output(I first, I last, O out, int init = 0) {\n</code></pre> <p>This could break if we were using a different type for the input and output, like a custom class that had no conversion to/from <code>int</code>. Let us use the template facilities just a bit more. The final code is here.</p> <pre><code>#include &lt;iostream&gt; // std:cin/cout\n#include &lt;iterator&gt; // std::istream_iterator/ostream_iterator\n#include &lt;numeric&gt; // std::accumulate\n#include &lt;type_traits&gt; // std::iterator_traits/enable_if/is_base_of\n\ntemplate &lt;typename I, typename O, typename T&gt;\nstd::enable_if_t&lt;\n    // enable if condition\n    std::is_base_of_v&lt;std::input_iterator_tag,\n        typename std::iterator_traits&lt;I&gt;::iterator_category&gt; &amp;&amp;\n    std::is_base_of_v&lt;std::output_iterator_tag,\n        typename std::iterator_traits&lt;O&gt;::iterator_category&gt;\n    &gt;\ninput_and_output(I first, I last, O out, T init = T{}) {\n    *out++ = std::accumulate(first, last, init);\n}\n\nint\nmain(int, char *[]) {\n    using prob_type = int;\n    input_and_output&lt;\n        std::istream_iterator&lt;prob_type&gt;,\n        std::ostream_iterator&lt;prob_type&gt;,\n        prob_type&gt;(\n            std::istream_iterator&lt;prob_type&gt;{std::cin},\n            std::istream_iterator&lt;prob_type&gt;{},\n            std::ostream_iterator&lt;prob_type&gt;{std::cout}\n        );\n    return 0;\n}\n</code></pre> <p>GitHub: 02-input-and-output/input-and-output-06.cpp </p> <p>For the sake of a more general approach we even added an alias for <code>int</code>, the type used in our solution. All template instantiations use now <code>prob_type</code> and with a single change to <code>using prob_type = int;</code>, we would change the type everywhere.</p> <p>But this feels so unnatural. Right before this last piece of code we were free to call <code>input_output</code> without any template parameters, because the instantiation was straightforward. We now need to specify the three of them. Unless we always specify a value for <code>init</code>, to let the template facilities deduct the type, as it happens in the following code.</p> <pre><code>    input_and_output(\n        std::istream_iterator&lt;prob_type&gt;{std::cin},\n        std::istream_iterator&lt;prob_type&gt;{},\n        std::ostream_iterator&lt;prob_type&gt;{std::cout},\n        0\n    );\n    return 0;\n}\n</code></pre> <p>GitHub: 02-input-and-output/input-and-output-07.cpp:21 </p> <p>The problems should be obvious even for the untrained eye (i.e.: the author's)</p> <ul> <li> <p>First, we are forced now to always provide an argument that we have conceived as having a default value.</p> </li> <li> <p>Second, we could pass something else instead of <code>0</code> with an incompatible type. So much for our idea to make <code>init</code> as generic and default as possible. Or maybe not.</p> </li> </ul>"},{"location":"0020-input-and-output/#summary","title":"Summary","text":"<p>Let us cut our losses short, because we have achieved a lot. Having real input in the hand, we have removed the fixed constraints of the challenge and can read any number of values, not just three. Moreover, our STL-like solution has gained type checking for the parameter templates.</p> <p>But, but, but ... \u201cHouston, we have a problem\u201d, because our extra parameter is causing problems and the reader has for sure noticed that we have lost our <code>auto</code>-magic return type in the solution. The type is now manually determined, when we use <code>std::enable_if</code>. Luckily, nothing lasts forever as we will see.</p>"},{"location":"0030-input-and-output-reloaded/","title":"Input And Output - Reloaded","text":"<p>Title: Input and Output Link: https://www.hackerrank.com/challenges/cpp-input-and-output </p> <p>If the Matrix franchise could reload itself, so can we, improving what we have so far done.</p>"},{"location":"0030-input-and-output-reloaded/#a-better-input-and-output","title":"A Better Input And Output","text":"<p>We ended this challenge with two small problems: the <code>auto</code>-return type and the extra <code>init</code> parameter that we wanted to be generic, yet compatible with the types the iterators manage.</p>"},{"location":"0030-input-and-output-reloaded/#deducting-types","title":"Deducting Types","text":"<p>Let us first address the second one. Recall that <code>std::iterator_traits&lt;T&gt;</code> is the generic interface giving us access to the definitions iterators have to carry. And amongst those definitions we have <code>value_type</code>, i.e.: a type. It is the perfect mix: iterators and an API to fetch the type inside the iterator. <code>init</code> can now be a lot more generic.</p> <pre><code>#include &lt;iostream&gt; // std:cin/cout\n#include &lt;iterator&gt; // std::istream_iterator/ostream_iterator\n#include &lt;numeric&gt; // std::accumulate\n#include &lt;type_traits&gt; // std::iterator_traits/enable_if/is_base_of\n\ntemplate &lt;typename I, typename O&gt;\nstd::enable_if_t&lt;\n    std::is_base_of_v&lt;std::input_iterator_tag,\n        typename std::iterator_traits&lt;I&gt;::iterator_category&gt; &amp;&amp;\n    std::is_base_of_v&lt;std::output_iterator_tag,\n        typename std::iterator_traits&lt;O&gt;::iterator_category&gt;\n    &gt;\ninput_and_output(I first, I last, O out,\n    typename std::iterator_traits&lt;I&gt;::value_type init = {})\n{\n    *out++ = std::accumulate(first, last, init);\n}\n\nint\nmain(int, char *[]) {\n    using prob_type = int;\n    input_and_output(\n        std::istream_iterator&lt;prob_type&gt;{std::cin},\n        std::istream_iterator&lt;prob_type&gt;{},\n        std::ostream_iterator&lt;prob_type&gt;{std::cout}\n    );\n    return 0;\n}\n</code></pre> <p>GitHub: 03-input-and-output-reloaded/input-and-output-reloaded-01.cpp </p> <p>This is exactly one of those moments when Italians scream: \u201cMamma Mia!\u201d. That is really verbose but it works. If we pass something that is not directly convertible to <code>int</code>, in our example, there will already be complains in the IDE and compilation will of course fail.</p> <p>But there is a better way by using a couple made for each other: <code>decltype</code> and <code>std::declval&lt;T&gt;</code>. Although they belong to different generations, C++11 / C++14, they are both jewels. The former lets you deduct the type of the expression passed to it, so one can dynamically calculate, for example a return type or a parameter type. The latter can take an unknown (unevaluated) type <code>T</code> to use member functions of it during compilation: i.e.: not going through constructors.</p> <p>We know that iterators have a <code>*</code> operator to retrieve the current value. We can therefore use <code>std::declval&lt;T&gt;</code> to access that value by pseudo-constructing <code>T</code> and applying the operator.</p> <pre><code>    *std::declval&lt;I&gt;() // Pseudo-constructed T, use the* operator to get a value\n</code></pre> <p>Once we have a value <code>decltype</code> can give us the declared type, hence the name.</p> <pre><code>    decltype(*std::declval&lt;I&gt;()) // Get declared type of the \"value\"\n</code></pre> <p>It the right moment to apply this to the code in the challenge.</p> <pre><code>#include &lt;iostream&gt; // std:cin/cout\n#include &lt;iterator&gt; // std::istream_iterator/ostream_iterator\n#include &lt;numeric&gt; // std::accumulate\n#include &lt;type_traits&gt; // std::iterator_traits/enable_if/is_base_of\n\ntemplate &lt;typename I, typename O&gt;\nstd::enable_if_t&lt;\n    std::is_base_of_v&lt;std::input_iterator_tag,\n        typename std::iterator_traits&lt;I&gt;::iterator_category&gt; &amp;&amp;\n    std::is_base_of_v&lt;std::output_iterator_tag,\n        typename std::iterator_traits&lt;O&gt;::iterator_category&gt;\n    &gt;\ninput_and_output(I first, I last, O out, decltype(*std::declval&lt;I&gt;()) init = {}) {\n    *out++ = std::accumulate(first, last, init);\n}\n\nint\nmain(int, char *[]) {\n    using prob_type = int;\n    input_and_output(\n        std::istream_iterator&lt;prob_type&gt;{std::cin},\n        std::istream_iterator&lt;prob_type&gt;{},\n        std::ostream_iterator&lt;prob_type&gt;{std::cout}\n    );\n    return 0;\n}\n</code></pre> <p>GitHub: 03-input-and-output-reloaded/input-and-output-reloaded-02.cpp </p> <p>And things look a lot friendlier for the casual code reader and reviewer. Not only that, the errors reported by the IDE and the compilation process are shorter and more amicable. And although both solutions work, we will stick, wherever and whenever possible, with the <code>declxxx</code> dynamic duo, because it offers a general interface for deducting types, whereas <code>std::iterator_traits&lt;T&gt;</code> is limited to iterators.</p>"},{"location":"0030-input-and-output-reloaded/#regaining-the-auto-return-type","title":"Regaining The \u201cauto\u201d Return Type","text":"<p>By using SFINAE with <code>std::enable_if_t</code> and an enabler, i.e.: return type from it, we lost the <code>auto</code> facility we were applying to our solution functions. We are forced to manually specify the right type in <code>std::enable_if_t</code>.</p> <p>But see, there is a trick because <code>std::enable_if_t</code> returns a type and that means we could put that in the template declaration, where types are allowed. If it fails, the template will not be part of the candidate set. If it succeeds, the template will be a possible match for the template instantiation we look for. Here is how it looks (no changes to <code>main</code>)</p> <pre><code>#include &lt;iostream&gt; // std:cin/cout\n#include &lt;iterator&gt; // std::istream_iterator/ostream_iterator\n#include &lt;numeric&gt; // std::accumulate\n#include &lt;type_traits&gt; // std::iterator_traits/enable_if/is_base_of\n\ntemplate &lt;typename I, typename O,\n    std::enable_if_t&lt;\n        std::is_base_of_v&lt;std::input_iterator_tag,\n            typename std::iterator_traits&lt;I&gt;::iterator_category&gt; &amp;&amp;\n        std::is_base_of_v&lt;std::output_iterator_tag,\n            typename std::iterator_traits&lt;O&gt;::iterator_category&gt;\n        &gt;* = nullptr\n    &gt;\nauto\ninput_and_output(I first, I last, O out, decltype(*std::declval&lt;I&gt;()) init = {}) {\n    *out++ = std::accumulate(first, last, init);\n}\n\nint\nmain(int, char *[]) {\n    using prob_type = int;\n    input_and_output(\n        std::istream_iterator&lt;prob_type&gt;{std::cin},\n        std::istream_iterator&lt;prob_type&gt;{},\n        std::ostream_iterator&lt;prob_type&gt;{std::cout}\n    );\n    return 0;\n}\n</code></pre> <p>GitHub: 03-input-and-output-reloaded/input-and-output-reloaded-03.cpp </p> <p>Recall that the default enabler type for <code>std::enable_if_t</code> is <code>void</code>. And that is what we therefore effectively are left with in the code if the checks are all <code>true</code>, is this:</p> <pre><code>template &lt;typename I, typename O, void* = nullptr&gt;\nauto\ninput_and_output(I first, I last, O out, decltype(*std::declval&lt;I&gt;()) init = {})\n</code></pre> <p>Our third template parameter is valid, of type <code>void *</code> and has a default value of <code>nullptr</code>. We do not really care about this third parameter because its only purpose is to succeed in being there or fail, in order to remove itself from the candidate set.</p> <p>Notice that we are back in business because <code>auto</code> is back in business itself, as the return type. This saves us from the burdensome work of having to specify the right type there or as the second parameter to <code>std::enable_if_t&lt;bool, typename = void&gt;</code>.</p> <p>The match candidate will finally look a bit more awkward once the types are in place. Similar to the code below, where we can easily recognize what goes where, how <code>int</code> was deduced for <code>init</code> and how our <code>nullptr</code> enabler is ignored.</p> <pre><code>template&lt;&gt;\nvoid\ninput_and_output&lt;\n    std::istream_iterator&lt;int, ...&gt;, // I\n    std::ostream_iterator&lt;int, ...&gt;, // O\n    nullptr&gt; // std::enable_if result\n(\n    std::istream_iterator&lt;int, ...&gt; first,\n    std::istream_iterator&lt;int, ...&gt; last,\n    std::ostream_iterator&lt;int, ...&gt; out,\n    const int &amp;init\n)\n</code></pre> <p>Both small problems are now solved.</p>"},{"location":"0030-input-and-output-reloaded/#sfinae-on-steroids","title":"SFINAE On Steroids","text":"<p>Steroids is probably an exaggeration. Let us simply say that we can improve the look of the SFINAE checks and make things generic for its reusability later somewhere else.</p> <p>We are indeed checking the nature of our iterators, but whether anyone is willing to type all that every time and actually read it later to understand what is going on, it is another story. Let us then present <code>std::void_t&lt;class ...&gt;</code> a C++17 metafunction looking forward to helping us. It transforms valid types passed as templates arguments into <code>void</code>. If something is not valid, <code>std::void_t</code> will not transform it and this will be the key to remove that candidate.</p> <p>To profit from <code>std::void_t</code> we will use the following technique:</p> <ul> <li> <p>Use a <code>struct</code> that can resolve to <code>true</code> if <code>std::void_t</code> succeeds in converting all types to <code>void</code></p> </li> <li> <p>Have the same <code>struct</code> as a fallback, with default template parameters, that will resolve to <code>false</code>. This will be a match if the checks above failed.</p> </li> </ul> <p>To have something that resolves to <code>true</code> and <code>false</code>, we may use <code>std::true_type</code> and <code>std::false_type</code>, the perfect Yin and Yang for the work. Both are specializations of <code>template&lt;class T, T v&gt; struct integral_constant</code>, where <code>T = bool</code> and each specialization receives the <code>v = true</code> and <code>v = false</code> values respectively.</p> <p>For the sake of an example, let us imagine that we want to check if something is simply an iterator with <code>std::iterator_traits</code>, disregarding if it is an input, output, forward, or any other type of iterator. Using all the ingredients gathered above, this is how we would do it.</p> <pre><code>template &lt;typename, typename = void&gt;\nstruct is_it : std::false_type {};\n\ntemplate &lt;typename T&gt;\nstruct is_it&lt;T, std::void_t&lt;typename std::iterator_traits&lt;T&gt;::iterator_category&gt;&gt;\n    : std::true_type {};\n</code></pre> <p>GitHub: 03-input-and-output-reloaded/input-and-output-reloaded-04.cpp:6:11 </p> <p>This is probably easy to understand: the first template candidate is a subclass of <code>std::false_type</code> (its value will be <code>false</code> when instantiated), whereas the second, a subclass of <code>std::true_type</code> that will be <code>true</code> when instantiated. The second will be a valid candidate if the template parameter <code>T</code> has the iterator trait <code>iterator_category.</code> In that case <code>std::void_t</code> will convert that to <code>void</code>. If not it will fail and our <code>std::false_type</code> derived struct will be the matching candidate.</p> <p>We could now apply this together with <code>std::enable_if</code></p> <pre><code>template &lt;typename, typename = void&gt;\nstruct is_it : std::false_type {};\n\ntemplate &lt;typename T&gt;\nstruct is_it&lt;T, std::void_t&lt;typename std::iterator_traits&lt;T&gt;::iterator_category&gt;&gt;\n    : std::true_type {};\n\ntemplate &lt;typename I, typename O,\n    std::enable_if_t&lt;is_it&lt;I&gt;{} &amp;&amp; is_it&lt;O&gt;{}&gt;* = nullptr&gt;\nauto\ninput_and_output(I first, I last, O out, decltype(*std::declval&lt;I&gt;()) init = {}) {\n    *out++ = std::accumulate(first, last, init);\n}\n</code></pre> <p>GitHub: 03-input-and-output-reloaded/input-and-output-reloaded-04.cpp:6:18 </p> <p>It seems like if we have gone from 100 to 0 in microseconds, removing most of the bloat. Notice that we use <code>{}</code> to instantiate <code>is_it&lt;T&gt;</code> and get the corresponding <code>true</code> or <code>false</code> value for the logical condition. This is equivalent to having used the <code>is_xxx_v</code> form above, a shorthand for <code>is_xxx::value</code>. Our <code>is_it</code> checker has actually a <code>::value</code> (declared as <code>constexpr static</code>), because it is a subclass of either <code>std::false_type</code> or <code>std::true_type</code>.</p> <p>We can do even better and check multiple parameters in one go by using another C++17 pearl, <code>std::conjunction&lt;class ...&gt;</code>. This one takes many types and performs a logical <code>and</code> test, returning the value in, you guessed, <code>::value</code>. As our types all have a boolean <code>::value</code>, the can be used for the logical conjunction.</p> <pre><code>template &lt;typename ...T&gt;\nusing are_it = std::conjunction&lt;is_it&lt;T&gt;...&gt;;\n</code></pre> <p>GitHub: 03-input-and-output-reloaded/input-and-output-reloaded-05.cpp:13:14 </p> <p>And this leads to an improvement/simplification of the previous code.</p> <p>Our code can be further simplified.</p> <pre><code>template &lt;typename I, typename O, std::enable_if_t&lt;are_it&lt;I, O&gt;{}&gt;* = nullptr&gt;\nauto\ninput_and_output(I first, I last, O out, decltype(*std::declval&lt;I&gt;()) init = {}) {\n    *out++ = std::accumulate(first, last, init);\n}\n</code></pre> <p>GitHub: 03-input-and-output-reloaded/input-and-output-reloaded-05.cpp:16:20 </p> <p>The goal, of course, is to check specifically if the iterators are subclasses of InputIterator and OutputIterator. Let us formulate these traits with <code>std::void_t</code> and then pack everything with <code>using</code> to make things even cleaner.</p> <p>First the check for an InputIterator.</p> <pre><code>template &lt;typename, typename = void&gt;\nstruct is_input : std::false_type {};\n\ntemplate &lt;typename I&gt;\nstruct is_input&lt;I, std::void_t&lt;std::is_base_of&lt;\n        std::input_iterator_tag,\n        typename std::iterator_traits&lt;I&gt;::iterator_category&gt;&gt;&gt;\n    : std::true_type {};\n</code></pre> <p>GitHub: 03-input-and-output-reloaded/input-and-output-reloaded-06.cpp:16:23 </p> <p>Notice that we have used <code>std::is_base_of</code> and not the <code>_v</code> helper to get the value. <code>std::void_t</code> is expecting types and not boolean values.</p> <p>We can do the same for the output.</p> <pre><code>template &lt;typename, typename = void&gt;\nstruct is_output : std::false_type {};\n\ntemplate &lt;typename O&gt;\nstruct is_output&lt;O, std::void_t&lt;std::is_base_of&lt;\n        std::output_iterator_tag,\n        typename std::iterator_traits&lt;O&gt;::iterator_category&gt;&gt;&gt;\n    : std::true_type {};\n</code></pre> <p>GitHub: 03-input-and-output-reloaded/input-and-output-reloaded-06.cpp:25:32 </p> <p>And then check both as shown above with <code>std::conjunction</code>.</p> <pre><code>template&lt;typename I, typename O&gt;\nusing io_iterators = std::conjunction&lt;is_input&lt;I&gt;, is_output&lt;O&gt;&gt;;\n</code></pre> <p>GitHub: 03-input-and-output-reloaded/input-and-output-reloaded-06.cpp:34:35 </p> <p>For bonus points and in order to get the gold medal for packaging and reusability, we can even alias the usage of <code>std::enable_if_t</code>.</p> <pre><code>template&lt;typename I, typename O&gt;\nusing enable_if_io = std::enable_if_t&lt;io_iterators&lt;I, O&gt;{}&gt;*;\n</code></pre> <p>GitHub: 03-input-and-output-reloaded/input-and-output-reloaded-06.cpp:37:38 </p> <p>This means that our definition of <code>input_output</code> looks like this now.</p> <pre><code>template &lt;typename I, typename O, enable_if_io&lt;I, O&gt; = nullptr&gt;\nauto\ninput_and_output(I first, I last, O out, decltype(*std::declval&lt;I&gt;()) init = {}) {\n    *out++ = std::accumulate(first, last, init);\n}\n</code></pre> <p>GitHub: 03-input-and-output-reloaded/input-and-output-reloaded-06.cpp:40:44 </p> <p>Although this looks really nice, we can still make it nicer. Using <code>decltype(*std::declval&lt;I&gt;())</code> is for sure a niece piece of work but we could rethink how we use <code>std::enable_if_t</code> (or the alias we have created) as a template parameter.</p> <p>For starters we could alias it, as we have done with the other checks above.</p> <pre><code>template &lt;typename T&gt;\nusing it_type = decltype(*std::declval&lt;T&gt;());\n\ntemplate &lt;typename I, typename O, enable_if_io&lt;I, O&gt; = nullptr&gt;\nauto\ninput_and_output(I first, I last, O out, it_type&lt;I&gt; init = {}) {\n    *out++ = std::accumulate(first, last, init);\n}\n</code></pre> <p>GitHub: 03-input-and-output-reloaded/input-and-output-reloaded-07.cpp:40:47 </p> <p>Even nicer. But we have not reworked <code>std::enable_if_t</code>. And something nicer would still check the traits but making something useful out of the third template parameter. Now that we can so nicely deduce the type inside iterator with <code>decltype</code> / <code>std::declval</code> the spark is there. Let us use that type as the return type in <code>std::enable_if_t</code> and then use that as a useful third template parameter instead of having just a dummy <code>nullptr</code> placeholder.</p> <pre><code>template&lt;typename I, typename O&gt;\nconstexpr bool io_iterators_v = io_iterators&lt;I, O&gt;::value;\n\ntemplate &lt;typename T&gt;\nusing it_type = decltype(*std::declval&lt;T&gt;());\n\ntemplate&lt;typename I, typename O&gt;\nusing enable_if_io = std::enable_if_t&lt;io_iterators_v&lt;I, O&gt;, it_type&lt;I&gt;&gt;;\n\ntemplate &lt;typename I, typename O, typename I_Type = enable_if_io&lt;I, O&gt;&gt;\nauto\ninput_and_output(I first, I last, O out, I_Type init = {}) {\n    *out++ = std::accumulate(first, last, init);\n}\n</code></pre> <p>GitHub: 03-input-and-output-reloaded/input-and-output-reloaded-08.cpp:37:50 </p> <p>We even added a bonus to replicate what we see in the standard our own <code>_v</code> helper with <code>io_iterators_v</code>. Instead of being a <code>struct</code> or a <code>using</code> alias, this one is a <code>constexpr bool</code>, i.e.: a bool calculated during compile time. That means that we do not have to initialize <code>io_iterators</code> or access the <code>static constexpr value</code> in it with <code>::value</code>, because our helper is doing it for us.</p>"},{"location":"0030-input-and-output-reloaded/#leaner-and-meaner","title":"Leaner and Meaner","text":"<p>Everything works, but not really fully. The typename <code>I_Type</code> has a default value in the template declaration but we are not specifying the template parameters: the compiler is doing that for us. That means that the real type passed as <code>I_Type</code> for the <code>init</code> parameter can be something else.</p> <p>This will be caught by the compiler if the type is not convertible to the type inside the InputIterator, but the goal was to invalidate the candidate if the type is wrong.</p> <p>We can additionally remove some of the bloat we have generated by using <code>constexpr bool</code> as we are wrapping <code>_v</code> values in <code>structs</code> that are subclasses of <code>std::true_type</code> plus a fallback subclass of <code>std::false_type</code>. If the standard <code>_v</code> helpers already give us <code>true</code> and <code>false</code>, let us then use them directly.</p> <pre><code>#include &lt;iostream&gt; // std:cin/cout\n#include &lt;iterator&gt; // std::istream_iterator/ostream_iterator\n#include &lt;numeric&gt; // std::accumulate\n#include &lt;type_traits&gt; // std::iterator_traits/enable_if/is_base_of\n\ntemplate &lt;typename T, typename Tag&gt;\nconstexpr bool is_it_tag_v = std::is_base_of_v&lt;\n    Tag, typename std::iterator_traits&lt;T&gt;::iterator_category&gt;;\n\ntemplate &lt;typename I&gt;\nconstexpr bool is_input_v = is_it_tag_v&lt;I, std::input_iterator_tag&gt;;\n\ntemplate &lt;typename O&gt;\nconstexpr bool is_output_v = is_it_tag_v&lt;O, std::output_iterator_tag&gt;;\n\ntemplate&lt;typename I, typename O&gt;\nconstexpr bool io_iterators_v = is_input_v&lt;I&gt; &amp;&amp; is_output_v&lt;O&gt;;\n\ntemplate &lt;typename T&gt;\nusing it_type = decltype(*std::declval&lt;T&gt;());\n\ntemplate&lt;typename I, typename O&gt;\nusing I_Type = std::enable_if_t&lt;io_iterators_v&lt;I, O&gt;, it_type&lt;I&gt;&gt;;\n</code></pre> <p>GitHub: 03-input-and-output-reloaded/input-and-output-reloaded-09.cpp:1:23 </p> <p>There it is. Although <code>std::void_t</code>, <code>std::conjunction</code> and using the duo <code>std::false_type</code> / <code>std::true_type</code> looked good and it actually worked, we now need a lot less and remember the famous axiom: \u201cless is more\u201d.</p> <p>Good old <code>bool</code> values that are calculated during compilation, hence <code>constexpr</code>, is everything we need. Notice that the type deduction for <code>init</code> with <code>it_type</code> remains unchanged and we have changed the name of <code>enable_if_io</code> to the typename we gave, and will still give, to the parameter <code>init</code>, i.e.: we have named the enabler as <code>I_Type</code>. See how this is applied in our new definition of <code>input_and_output</code>.</p> <pre><code>template &lt;typename I, typename O&gt;\nauto\ninput_and_output(I first, I last, O out, I_Type&lt;I, O&gt; init = {}) {\n    *out++ = std::accumulate(first, last, init);\n}\n\nint\nmain(int, char *[]) {\n    using prob_type = int;\n    input_and_output(\n        std::istream_iterator&lt;prob_type&gt;{std::cin},\n        std::istream_iterator&lt;prob_type&gt;{},\n        std::ostream_iterator&lt;prob_type&gt;{std::cout}\n    );\n    return 0;\n}\n</code></pre> <p>GitHub: 03-input-and-output-reloaded/input-and-output-reloaded-09.cpp:25 </p> <p>It would seem as if we were playing a game of \u201cWhere is the ball?\u201d. We first had our enabler <code>std::enable_if_t</code> in between the template declaration and the function definition. Later we moved it to be the default value of a template parameter (wrapping it in our own <code>enable_if_io</code>) And with the name <code>I_type</code> it is now the type for the <code>init</code> parameter in the function definition.</p> <p>The <code>std::enable_if_t</code> check behind the curtains remains the same and the candidate will be eliminated from the set if either <code>I</code> and/or <code>O</code> fail the check to see the nature as an InputIterator and an OutputIterator respectively. What we are doing here is taking advantage of the fact that <code>std::enable_if_t</code> returns a type and that type is the one we want to have for <code>init</code>.</p> <p>Recall that type was a hindrance at the beginning, because it would prevent us from using <code>auto</code> as the return type. It is now the perfect enforcer for the parameter type. Any wrong type passed to <code>init</code> will be caught early, in the definition of our function. In the previous version, any wrong parameter was flagged later, at the <code>std::accumulate</code> level.</p>"},{"location":"0030-input-and-output-reloaded/#summary","title":"Summary","text":"<p>We started with our first ugly and bloated version of SFINAE and although we used nice constructs and incredible facilities from the language and the library, this only led to replacing bloat with bloat. We then progressed to make a leaner and meaner version that shall serve us as a model for the future.</p>"},{"location":"0040-hello-world-revolution/","title":"Hello World - Revolutions","text":"<p>Title: Hello, World! Link: https://www.hackerrank.com/challenges/cpp-hello-world </p> <p>After the Matrix was reloaded a revolution followed. Let us try to revolutionize the \u201cHello, World!\u201d challenge.</p>"},{"location":"0040-hello-world-revolution/#sfinae-for-the-custom-iterator","title":"SFINAE for the custom iterator","text":"<p>When we modeled our \u201cHello, World!\u201d solution with iterators, including a custom output iterator, we had not yet introduced SFINAE. Let us see if our custom iterator can pass the test using the tools we have developed, recovering the <code>enable_if_io</code> naming, as we are not using the helper for a type declaration.</p> <pre><code>template &lt;typename T, typename Tag&gt;\nconstexpr bool is_it_tag_v = std::is_base_of_v&lt;\n    Tag, typename std::iterator_traits&lt;T&gt;::iterator_category&gt;;\n\ntemplate &lt;typename I&gt;\nconstexpr bool is_input_v = is_it_tag_v&lt;I, std::input_iterator_tag&gt;;\n\ntemplate &lt;typename O&gt;\nconstexpr bool is_output_v = is_it_tag_v&lt;O, std::output_iterator_tag&gt;;\n\ntemplate&lt;typename I, typename O&gt;\nconstexpr bool io_iterators_v = is_input_v&lt;I&gt; &amp;&amp; is_output_v&lt;O&gt;;\n\ntemplate&lt;typename I, typename O&gt;\nusing enable_if_io = std::enable_if_t&lt;io_iterators_v&lt;I, O&gt;&gt;*;\n</code></pre> <p>GitHub: 04-hello-world-revolution/hello-world-revolution-01.cpp:38:52 </p> <p>Using that arsenal we rework the <code>hello_world</code> definition to use <code>enable_if_io</code>.</p> <pre><code>template &lt;typename I, typename O, enable_if_io&lt;I, O&gt; = nullptr&gt;\nauto\nhello_world(I first, I last, O out) {\n    return std::copy(first, last, out);\n}\n</code></pre> <p>GitHub: 04-hello-world-revolution/hello-world-revolution-01.cpp:54:58 </p> <p>And here comes the surprise, because after crafting that nice, even if verbose, piece of code, the custom output iterator that we crafted before does not pass our own check, and we for sure used the right tag. And we are checking with <code>std::iterator_traits</code> as we did in the previous chapter to verify the tag that went into the iterator.</p> <pre><code>    using iterator_category = std::output_iterator_tag;\n</code></pre> <p>GitHub: 04-hello-world-revolution/hello-world-revolution-01.cpp:15:15 </p> <p>There will be complaints about <code>std::basic_string</code> (i.e.: <code>std::string</code>) not having an <code>iterator_category</code> defined. And that simply means that <code>std::iterator_traits</code> is trying to tell us that we were lazy.</p> <p>One has to wonder if we really implemented an output iterator. Before C++17 one could subclass from <code>std::iterator</code> and avoid being lazy, because all needed definitions had to be provided. But this was deprecated and a custom iterator needs to have some extra definitions in place to make <code>std::iterator_traits</code> happy.</p> <p>Even more. Our laziness meant we were sloppy and defined the delimiter as <code>T m_delim</code>. This does not match what an <code>std::ostream_iterator</code> does, because it takes a <code>const char *</code>. Let us therefore fix those two things in the custom iterator, presenting the changes.</p> <pre><code>template &lt;typename T&gt;\nclass os_iterator {\n    using ositer = std::ostream_iterator&lt;T&gt;;\n    using osdelim = std::ostream_iterator&lt;std::string&gt;;\n\n    ositer m_iter; // wrapped iterator\n    osdelim m_itdelim; // wrapped iterator for delimiter\n    const std::string m_delim; // separator between elements\n    bool m_dodelim = false; // when to start separating\n\npublic:\n    // needed for an iterator - copy from wrapped iterator\n    using iterator_category = typename ositer::iterator_category;\n    using value_type = typename ositer::value_type;\n    using difference_type = typename ositer::difference_type;\n    using pointer = os_iterator *;\n    using reference = os_iterator &amp;;\n</code></pre> <p>GitHub: 04-hello-world-revolution/hello-world-revolution-02.cpp:7:23 </p> <p>The delimiter type issue requires some extra machinery, with a second <code>std::ostream_iterator</code> in place. We store the delimiter as an <code>std::string</code> and even if in our challenge, the values fed into our custom iterator are also of type <code>std::string</code>, they could be anything. And getting our delimiter into that other iterator would fail spectacularly.</p> <p>To work cleanly we create an alias for each of the <code>std::ostream_iterator</code> instances we are hosting, namely: <code>ositer</code> for the main type to output and <code>osdelim</code> for the delimiter outputting the iterator.</p> <p>Notice that we copy as many of possible of the iterator definition values from the iterator we are wrapping, namely: <code>iterator_category</code>, <code>value_type</code> and <code>difference_type</code>. But for <code>pointer</code> and <code>reference</code> the actual values returned by the corresponding methods are returned, i.e.: this iterator.</p> <p>After this rework, the custom iterator passes all checks and the code compiles. Having been lazy had one advantage: now we know that the SFINAE machinery we developed previously works in all cases. We found out as soon as we applied it to the first version of the custom iterator.</p>"},{"location":"0040-hello-world-revolution/#checking-type-compatibility","title":"Checking Type Compatibility","text":"<p>In our previous case we had an <code>init</code> parameter for which we wanted to set the allowed type in its declaration as a parameter. We achieved this by returning the type gotten via <code>decltype</code> / <code>std::declval</code> with <code>std::enable_if_t</code>.</p> <p>When considering the checks for this case, testing if the types of the input iterator can be converted to something accepted by the output iterator seems the logical way to go. That would have been the major price: packing that check into the final alias.</p> <p>After all, we wrote this previously when we were solving the \u201cInput and Output\u201d challenge.</p> <pre><code>    *out++ = *in++ + *in++ + *in++;\n</code></pre> <p>It would therefore seem logical that the type of <code>I</code> is convertible to something accepted by <code>O</code>. Once again, <code>decltype</code> and <code>std::declval&lt;T&gt;</code> come to the rescue, as we can pseudo-construct objects and use their functionalities.</p> <p>Let us write a check for that.</p> <pre><code>template &lt;typename I, typename O&gt;\nusing io_type = decltype(*std::declval&lt;O&gt;() = *std::declval&lt;I&gt;());\n\ntemplate&lt;typename, typename, typename = void&gt;\nstruct io_i2o : std::false_type {};\n\ntemplate&lt;typename I, typename O&gt;\nstruct io_i2o&lt;I, O, std::void_t&lt;io_type&lt;I, O&gt;&gt;&gt;\n    : std::true_type {};\n\ntemplate&lt;typename I, typename O&gt;\nconstexpr bool io_i2o_v = io_i2o&lt;I, O&gt;::value;\n</code></pre> <p>GitHub: 04-hello-world-revolution/hello-world-revolution-03.cpp:64:75 </p> <p>We first look for the type of the output, but simulating the input to output operation. In plain English: we are taking the type after the dereferenced declared value of <code>O</code> can take the dereferenced value of <code>I</code>. Shorthand: <code>*out = *in</code> but written as <code>*std::declval&lt;O&gt;() = *std::declval&lt;I&gt;())</code> If this works, <code>decltype</code> will deliver a type.</p> <p>To process the type we recover <code>std::void_t</code>. Recall that we were previously able to work only with <code>constexpr bool</code> as we had values, but we are now deducting a type and have to resort to the <code>std::false_type</code> / <code>std::true_type</code> combo of structs we name <code>io_i2o</code>, i.e.: \u201cinput-output, input to output\u201d.</p> <p>\u201cGo with the flow\u201d, \u201cFollow the Path of Least Resistance\u201d, \u201cBe Water My Friend\u201d or any other similar saying is telling us to go with the trend. And the trend favors the use of <code>_v</code> helpers. That is why we \u201cdegrade\u201d the struct combo down to a <code>constexpr bool</code>, as we did previously to have our <code>io_i2o_v</code> helper.</p> <p>The helper is added as a check to <code>std::enable_if_t</code> as the second term of a logical and, in which first we check the input/output nature of the iterators. If we changed the input <code>std::array</code> to hold integers instead of strings, there would be no candidate matching our <code>hello_world</code> function request, because the template parameter deduction would fail. One cannot directly put <code>int</code> into a <code>std::string</code>.</p> <p>But wait: we are giving the output iterator a manipulated value and the outcome of the manipulation could be anything, even the instance of a custom class, after we have read some integers. Perfectly valid use cases that we would break by using our <code>io_i2o_v</code> as a check. The fact that we get <code>const char *</code> values as the input and output a <code>std::string</code> is just a coincidence, it is a specific trait of this problem and not a general check.</p> <p>We could therefore use it here for the sake of it, but not as a general rule, in we probably want to check if the types of the iterators match our expected definition.</p> <p>The final code in its entirety is presented now.</p> <pre><code>#include &lt;algorithm&gt; // std::copy\n#include &lt;array&gt; // std::array\n#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iterator&gt; // std::istream/ostream_iterator\n#include &lt;type_traits&gt; // std::enable_if/is_base_of\n\ntemplate &lt;typename T&gt;\nclass os_iterator {\n    using ositer = std::ostream_iterator&lt;T&gt;;\n    using osdelim = std::ostream_iterator&lt;std::string&gt;;\n\n    ositer m_iter; // wrapped iterator\n    osdelim m_itdelim; // wrapped iterator for delimiter\n    const std::string m_delim; // separator between elements\n    bool m_dodelim = false; // when to start separating\n\npublic:\n    // needed for an iterator - copy from wrapped iterator\n    using iterator_category = typename ositer::iterator_category;\n    using value_type = typename ositer::value_type;\n    using difference_type = typename ositer::difference_type;\n    using pointer = os_iterator *;\n    using reference = os_iterator &amp;;\n\n    // constructor replicating the wrapped iterator's constructor\n    os_iterator(std::ostream &amp;os, const std::string &amp;delim=\"\") :\n        m_iter{os}, m_itdelim{os}, m_delim{delim} {}\n\n    // no-ops because only the assignment (= operator does something)\n    auto *operator -&gt;() { return this; } // we wouldn't need this\n    auto &amp;operator *() { return *this; }\n    auto &amp;operator ++() { return *this; } // ++prefix\n    auto &amp;operator ++(int) { return *this; } // postfix++\n\n    // usual ++ postfix implementation, but we need no tmp\n    // because our * and ++ operators are reall no-ops\n    // auto operator ++(int) { auto tmp = *this; ++(*this); return tmp; }\n\n    // Operation with the wrapped iterator, choosing when to\n    auto &amp;operator =(const T &amp;outval) {\n        if(m_dodelim) // output separator before the second/later elements\n            *m_itdelim++ = m_delim;\n        else\n            m_dodelim = true;\n\n        *m_iter++ = outval;\n        return *this;\n    }\n};\n\ntemplate &lt;typename T, typename Tag&gt;\nconstexpr bool is_it_tag_v = std::is_base_of_v&lt;\n    Tag, typename std::iterator_traits&lt;T&gt;::iterator_category&gt;;\n\ntemplate &lt;typename I&gt;\nconstexpr bool is_input_v = is_it_tag_v&lt;I, std::input_iterator_tag&gt;;\n\ntemplate &lt;typename O&gt;\nconstexpr bool is_output_v = is_it_tag_v&lt;O, std::output_iterator_tag&gt;;\n\ntemplate&lt;typename I, typename O&gt;\nconstexpr bool io_iterators_v = is_input_v&lt;I&gt; &amp;&amp; is_output_v&lt;O&gt;;\n\ntemplate &lt;typename I, typename O&gt;\nusing io_type = decltype(*std::declval&lt;O&gt;() = *std::declval&lt;I&gt;());\n\ntemplate&lt;typename, typename, typename = void&gt;\nstruct io_i2o : std::false_type {};\n\ntemplate&lt;typename I, typename O&gt;\nstruct io_i2o&lt;I, O, std::void_t&lt;io_type&lt;I, O&gt;&gt;&gt;\n    : std::true_type {};\n\ntemplate&lt;typename I, typename O&gt;\nconstexpr bool io_i2o_v = io_i2o&lt;I, O&gt;::value;\n\ntemplate&lt;typename I, typename O&gt;\nusing enable_if_io = std::enable_if_t&lt;io_iterators_v&lt;I, O&gt; &amp;&amp; io_i2o_v&lt;I, O&gt;&gt;*;\n\ntemplate &lt;typename I, typename O, enable_if_io&lt;I, O&gt; = nullptr&gt;\nauto\nhello_world(I first, I last, O out) {\n    return std::copy(first, last, out);\n}\n\nint\nmain(int, char *[]) {\n    auto hello = std::array{\"Hello\", \"World!\"};\n    auto out = os_iterator&lt;std::string&gt;{std::cout, \", \"};\n    hello_world(hello.begin(), hello.end(), out);\n    return 0;\n}\n</code></pre> <p>GitHub: 04-hello-world-revolution/hello-world-revolution-03.cpp </p>"},{"location":"0040-hello-world-revolution/#summary","title":"Summary","text":"<p>We had a working solution, but all the work done with out SFINAE machinery has paid off, letting us improve our solution to be correct and not only a working solution. C++17 has finally a proper \u201cHello, World!\u201d salutation in place.</p>"},{"location":"0050-types-types-types/","title":"Types, Types, Types","text":"<p>Title: Basic Data Types Link: https://www.hackerrank.com/challenges/c-tutorial-basic-data-types </p> <p>This title probably sounds so bad that even Ballmer's \u201cDevelopers, Developers, Developers ...\u201d gig would have sold many more vinyl records.</p> <p>The next challenge gives us a list of basic types. We are expected to read values from the standard input and output the values back to the standard output, with some formatting in a couple of cases. Let us go for it.</p>"},{"location":"0050-types-types-types/#the-obvious-approach","title":"The Obvious Approach","text":"<pre><code>#include &lt;iomanip&gt; // std::setprecision\n#include &lt;ios&gt; // std::fixed\n#include &lt;iostream&gt; // std::cin/cout\n\nint\nmain(int, char *[]) {\n    int i;\n    long l;\n    char c;\n    float f;\n    double d;\n\n    std::cin &gt;&gt; i &gt;&gt; l &gt;&gt; c &gt;&gt; f &gt;&gt; d;\n\n    std::cout &lt;&lt; i &lt;&lt; std::endl;\n    std::cout &lt;&lt; l &lt;&lt; std::endl;\n    std::cout &lt;&lt; c &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(3) &lt;&lt; f &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(9) &lt;&lt; d &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> <p>GitHub: 05-basic-data-types/basic-data-types-01.cpp </p> <p>We simply create some variables of the following types: <code>int</code>, <code>long</code>, <code>char</code>, <code>float</code> and <code>double</code>, read from <code>std::cin</code> and output to <code>std::cout</code>. The types <code>float</code> and <code>double</code> need some manipulation to be output with a fixed number of decimals each, namely 3 and 9.</p> <p>A simple replacement of this approach with five instances of <code>std::istream_iterator&lt;T&gt;</code> and another set of five instances of <code>std::ostream_iterator&lt;type, \u201c\\n\u201d&gt;</code> is for sure not the kind of challenge we are looking for. Even if one of the goals is to use iterators here, there and everywhere. Let us therefore skip putting that in written form.</p>"},{"location":"0050-types-types-types/#the-classic-recursive-template","title":"The Classic Recursive Template","text":"<p>If this were Python, we could iterate over the type names, because those type names are also the classes that we can instantiate to obtain values. But this is not Python and we cannot iterate over the types.</p> <p>Unless we can. If we consider that one can pass an unlimited number of types to a template and we can then pass those types to another template function, it would seem as if we could iterate. Let us craft a <code>for_each</code> looping function. And let us do it in the most classic way.</p> <pre><code>template&lt;typename BasicType, typename BasicType2, typename ...BasicTypes&gt;\nauto\nfor_each(size_t fprec = 3, size_t dprec = 9) {\n    for_each&lt;BasicType&gt;(fprec, dprec);\n    for_each&lt;BasicType2, BasicTypes...&gt;(fprec, dprec);\n}\n</code></pre> <p>GitHub: 05-basic-data-types/basic-data-types-02.cpp:41:46 </p> <p>The tricks here should be easy to see, <code>for_each</code> takes any number of types by using a template parameter pack, yes, the thing with the <code>...</code>. At the same time, and to avoid ambiguity, two of the parameters are specified before the pack. We actually need two, because the pack could be empty and there would be no way to differentiate between these two cases.</p> <pre><code>// 1 template parameter ... the pack is empty\ntemplate&lt;typename BasicType, typename ...BasicTypes&gt;\n\n// 1 template parameter\ntemplate&lt;typename BasicType&gt; //\n</code></pre> <p>If the pack is empty, the compiler resolves both cases to be simply a template with one parameter and cannot decide which one will be the match. But if we have two, we are making sure that if the pack is empty, the cases are different.</p> <pre><code>// empty pack, 2 template parameters\ntemplate&lt;typename BasicType, typename BasicType2, typename ...BasicTypes&gt;\n\n// 1 template parameter\ntemplate&lt;typename BasicType&gt; //\n</code></pre> <p>That is how the two recursive calls to <code>for_each</code> can succeed. The rest will be easy, given that we only need the following.</p> <ul> <li> <p>A generic <code>for_each</code> that instantiates an <code>std::istream_iterator&lt;BasicType&gt;</code> and an <code>std::ostream_iterator&lt;BasicType, \u201c\\n\u201d&gt;</code> and copies one element from the former to the latter.</p> </li> <li> <p>Because <code>float</code> and <code>double</code> need some special handling, specializations for those types are needed.</p> </li> <li> <p>A call in <code>main</code> to start the iteration.</p> </li> </ul> <p>All those ideas expressed in code are shown here.</p> <pre><code>#include &lt;algorithm&gt; // std::copy_n\n#include &lt;iomanip&gt; // std::setprecision\n#include &lt;ios&gt; // std::fixed\n#include &lt;iostream&gt; // std::cin/cout\n#include &lt;iterator&gt; // std::ostream_iterator/istream\n\ntemplate&lt;typename BasicType&gt;\nauto\nfor_each(size_t /* fprec */ = 3, size_t /* dprec */ = 9) {\n    auto in = std::istream_iterator&lt;BasicType&gt;{std::cin};\n    auto out = std::ostream_iterator&lt;BasicType&gt;{std::cout, \"\\n\"};\n    std::copy_n(in, 1, out); // *out++ = *in;\n}\n\ntemplate&lt;&gt;\nauto\nfor_each&lt;float&gt;(size_t fprec /* = 3 */, size_t /* dprec = 9 */) {\n    const auto def_prec{std::cout.precision()}; // save current prec\n    const auto def_flags{std::cout.flags()}; // save current prec\n    using BasicType = float;\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(fprec);\n    auto in = std::istream_iterator&lt;BasicType&gt;{std::cin};\n    auto out = std::ostream_iterator&lt;BasicType&gt;{std::cout, \"\\n\"};\n    std::copy_n(in, 1, out); // *out++ = *in;\n    (std::cout &lt;&lt; std::setprecision(def_prec)).flags(def_flags); // reset\n}\n\ntemplate&lt;&gt;\nauto\nfor_each&lt;double&gt;(size_t /* fprec = 3 */, size_t dprec /* = 9 */) {\n    const auto def_prec{std::cout.precision()}; // save current prec\n    const auto def_flags{std::cout.flags()}; // save current prec\n    using BasicType = double;\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(dprec);\n    auto in = std::istream_iterator&lt;BasicType&gt;{std::cin};\n    auto out = std::ostream_iterator&lt;BasicType&gt;{std::cout, \"\\n\"};\n    std::copy_n(in, 1, out); // *out++ = *in;\n    (std::cout &lt;&lt; std::setprecision(def_prec)).flags(def_flags); // reset\n}\n\ntemplate&lt;typename BasicType, typename BasicType2, typename ...BasicTypes&gt;\nauto\nfor_each(size_t fprec = 3, size_t dprec = 9) {\n    for_each&lt;BasicType&gt;(fprec, dprec);\n    for_each&lt;BasicType2, BasicTypes...&gt;(fprec, dprec);\n}\n\nint\nmain(int, char *[]) {\n    for_each&lt;int, long, char, float, double&gt;();\n    return 0;\n}\n</code></pre> <p>GitHub: 05-basic-data-types/basic-data-types-02.cpp </p> <p>Even if it solves the problem, there are some ugly things. We need to carry around the number of decimal places, <code>3</code> and <code>9</code>, for <code>float</code> and <code>double</code>, and to avoid warnings we need to suppress the parameter name. It is not nice.</p> <pre><code>for_each(size_t /* fprec */ = 3, size_t /* dprec */ = 9) {\nfor_each&lt;float&gt;(size_t fprec /* = 3 */, size_t /* dprec = 9 */) {\nfor_each&lt;double&gt;(size_t /* fprec = 3 */, size_t dprec /* = 9 */) {\n</code></pre> <p>GitHub: 05-basic-data-types/basic-data-types-02.cpp:9:9,17:17,30:30 </p> <p>A lot of code is also repeated in the management of the precision for <code>float</code> and <code>double</code> and in the instantiation of the iterators. Let us address those shortcomings.</p>"},{"location":"0050-types-types-types/#the-classic-template-reworked","title":"The Classic Template Reworked","text":"<pre><code>#include &lt;algorithm&gt; // std::copy_n\n#include &lt;iomanip&gt; // std::setprecision\n#include &lt;ios&gt; // std::fixed\n#include &lt;iostream&gt; // std::cin/cout\n#include &lt;iterator&gt; // std::ostream_iterator/istream\n#include &lt;utility&gt; // std::make_pair\n\ntemplate &lt;typename BasicType&gt;\nauto\nin_out() {\n    auto in = std::istream_iterator&lt;BasicType&gt;{std::cin};\n    auto out = std::ostream_iterator&lt;BasicType&gt;{std::cout, \"\\n\"};\n    return std::make_pair(in, out);\n}\n\ntemplate&lt;typename BasicType&gt;\nauto\nfor_each(size_t /* fprec */ = 3, size_t /* dprec */ = 9) {\n    auto [in, out] = in_out&lt;BasicType&gt;();\n    std::copy_n(in, 1, out); // *out++ = *in;\n}\n\ntemplate&lt;typename BasicType&gt;\nauto\nfor_each_floating(size_t prec) {\n    const auto def_prec{std::cout.precision()}; // save current prec\n    const auto def_flags{std::cout.flags()}; // save current prec\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(prec);\n    auto [in, out] = in_out&lt;BasicType&gt;();\n    std::copy_n(in, 1, out); // *out++ = *in;\n    (std::cout &lt;&lt; std::setprecision(def_prec)).flags(def_flags); // reset\n}\n\ntemplate&lt;&gt;\nauto\nfor_each&lt;float&gt;(size_t fprec /* = 3 */, size_t /* dprec = 9 */) {\n    for_each_floating&lt;float&gt;(fprec);\n}\n\ntemplate&lt;&gt;\nauto\nfor_each&lt;double&gt;(size_t /* fprec = 3 */, size_t dprec /* = 9 */) {\n    for_each_floating&lt;double&gt;(dprec);\n}\n\ntemplate&lt;typename BasicType, typename BasicType2, typename ...BasicTypes&gt;\nauto\nfor_each(size_t fprec = 3, size_t dprec = 9) {\n    for_each&lt;BasicType&gt;(fprec, dprec);\n    for_each&lt;BasicType2, BasicTypes...&gt;(fprec, dprec);\n}\n\nint\nmain(int, char *[]) {\n    for_each&lt;int, long, char, float, double&gt;();\n    return 0;\n}\n</code></pre> <p>GitHub: 05-basic-data-types/basic-data-types-03.cpp </p> <p>This is our best try. A function <code>in_out</code> serves as a central factory for the <code>std::istream_iterator</code> / <code>std::ostream_iterator</code> pair we need. And the management of the <code>float</code> / <code>double</code> precision differences is also outsourced to a <code>for_each_floating</code> function.</p> <p>But that is all. The recursive template nature and the specializations are still there. There has to be something more modern than this.</p>"},{"location":"0050-types-types-types/#the-if-constexpr-express","title":"The \u201cif constexpr\u201d Express","text":"<p>C++17 introduces a real beast: <code>if constexpr</code>, i.e.: we can logically reason during compilation time. It is not that we were not already doing it. The template solutions we presented before were choosing what function to call in the background and with which types, so the logic was there.</p> <p>But not being able to implement the logic directly with <code>if ...</code> was taking the power out of our hands, and C++17 changes the landscape. Here is the solution after our new white elephant comes into the picture.</p> <pre><code>#include &lt;algorithm&gt; // std::copy_n\n#include &lt;iomanip&gt; // std::setprecision\n#include &lt;ios&gt; // std::fixed\n#include &lt;iostream&gt; // std::cin/cout\n#include &lt;iterator&gt; // std::ostream_iterator/istream\n#include &lt;type_traits&gt; // std::is_same_v\n\ntemplate&lt;typename BasicType&gt;\nauto\nfor_each(size_t fprec = 3, size_t dprec = 9) {\n    const auto def_prec{std::cout.precision()}; // save current prec\n    const auto def_flags{std::cout.flags()}; // save current prec\n\n    if constexpr (std::is_same_v&lt;float, BasicType&gt;)\n        std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(fprec);\n    else if constexpr (std::is_same_v&lt;double, BasicType&gt;)\n        std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(dprec);\n\n    auto in = std::istream_iterator&lt;BasicType&gt;{std::cin};\n    auto out = std::ostream_iterator&lt;BasicType&gt;{std::cout, \"\\n\"};\n    std::copy_n(in, 1, out); // *out++ = *in;\n    (std::cout &lt;&lt; std::setprecision(def_prec)).flags(def_flags); // reset\n}\n\ntemplate&lt;typename BasicType, typename BasicType2, typename ...BasicTypes&gt;\nauto\nfor_each(size_t fprec = 3, size_t dprec = 9) {\n    for_each&lt;BasicType&gt;(fprec, dprec);\n    for_each&lt;BasicType2, BasicTypes...&gt;(fprec, dprec);\n}\n\nint\nmain(int, char *[]) {\n    for_each&lt;int, long, char, float, double&gt;();\n    return 0;\n}\n</code></pre> <p>GitHub: 05-basic-data-types/basic-data-types-04.cpp </p> <p>It really feels like magic. Adding two lines of logic to handle <code>float</code> and <code>double</code> does remove the need for separate generic and specialized template solutions. And with it the need to duplicate code or to have additional factories and helper functions.</p> <p>Our, already old and well-known, friend <code>std::is_same_v</code> enables the <code>if constexpr</code> check. Remember that we discarded <code>std::is_same</code> for our iterator checks, because several types (subclasses) of iterators could fit the profile. In this case we want to be specific.</p> <p>The world is already a better place, but rest assured it can be evaluated from many different perspectives.</p>"},{"location":"0050-types-types-types/#the-if-constexpr-single-method-solution","title":"The \u201cif constexpr\u201d Single Method Solution","text":"<p>The introduction of <code>if constexpr</code> has allowed a quick removal of specializations and all the bloat (or optimizations) we added. But we still have two template functions. One is doing the work, and the other is simply managing the recursion.</p> <p>Given the powers granted to, and by, <code>if constexpr</code>, it is easy to wonder if the recursion can also be managed by this wonder of wonders. Let us answer that question by directly looking at the following code.</p> <pre><code>#include &lt;algorithm&gt; // std::copy_n\n#include &lt;iomanip&gt; // std::setprecision\n#include &lt;ios&gt; // std::fixed\n#include &lt;iostream&gt; // std::cin/cout\n#include &lt;iterator&gt; // std::ostream_iterator/istream\n#include &lt;type_traits&gt; // std::is_same_v\n\ntemplate&lt;typename BasicType, typename ...BasicTypes&gt;\nauto\nfor_each(size_t fprec = 3, size_t dprec = 9) {\n    const auto def_prec{std::cout.precision()}; // save current prec\n    const auto def_flags{std::cout.flags()}; // save current prec\n\n    if constexpr (std::is_same_v&lt;float, BasicType&gt;)\n        std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(fprec);\n    else if constexpr (std::is_same_v&lt;double, BasicType&gt;)\n        std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(dprec);\n\n    auto in = std::istream_iterator&lt;BasicType&gt;{std::cin};\n    auto out = std::ostream_iterator&lt;BasicType&gt;{std::cout, \"\\n\"};\n    std::copy_n(in, 1, out); // *out++ = *in;\n\n    (std::cout &lt;&lt; std::setprecision(def_prec)).flags(def_flags); // reset\n\n    if constexpr(sizeof...(BasicTypes))\n        for_each&lt;BasicTypes...&gt;(fprec, dprec);\n}\n\nint\nmain(int, char *[]) {\n    for_each&lt;int, long, char, float, double&gt;();\n    return 0;\n}\n</code></pre> <p>GitHub: 05-basic-data-types/basic-data-types-05.cpp </p> <p>Yes and no (a classic German \u201cJein\u201d, i.e.: \u201cJa\u201d + \u201cNein\u201d). <code>if constexpr</code> alone cannot enter godmode. It needs to work in tandem with a pre-existing member of the C++ family: <code>sizeof...(pack)</code>. As the name implies, it allows us to know the number of elements in the pack. Now, we may even perform a logical <code>if</code> check on it to know if recursion is needed.</p> <p>That is the key to remove the trick of having the \u201c2 parameters + 1 pack\u201d trick we analyzed before. <code>for_each</code> now features a standard \u201c1 parameter + 1 pack\u201d. And before recursing, it is checked if the pack has any remaining types. This is really clean, because the \u201c1 parameter\u201d has a clear name, <code>BasicType</code>, for its usage in the function and <code>...BasicTypes</code> contains the remaining types, if any, that would still need to be processed.</p>"},{"location":"0050-types-types-types/#the-fold-expression-miracle","title":"The Fold Expression Miracle","text":"<p>Good things come in pairs, and C++17 did not simply bring <code>if constexpr</code>, it also brought Fold Expressions to the table. A miracle that needs some consideration before one can really understand its depth.</p> <p>Reading about it and looking at many examples and ideas about how Fold Expression work, one of the approaches seemed like magical. Actually, more magical than the others. It was the application of Fold Expressions with the comma operator. In a regular case, the <code>,</code> operator works by executing the statements that are separated by the comma and returns the value of the last one. Like in this <code>while</code> situation.</p> <pre><code>    int a = 0, b = 100;\n    while(a++, a &lt; b)\n        do_something();\n</code></pre> <p>After increasing <code>a</code> with <code>a++</code>, the boolean value of the comparison <code>a &lt; b</code> is what will determine if the <code>while</code> loop continues or not. But with Fold Expressions, this is different:</p> <pre><code>template&lt;typename ...ParameterPack&gt;\nauto\nmy_function() {\n  (do_something&lt;ParameterPack&gt;(), ...);\n}\n</code></pre> <p>Our parameter pack is being folded over the <code>,</code> operator, i.e.: each of the members of the pack is being passed one by one to <code>do_something&lt;ParameterPack&gt;()</code>. We can for sure work with that. Let us see how.</p> <pre><code>#include &lt;algorithm&gt; // std::copy_n\n#include &lt;iomanip&gt; // std::setprecision\n#include &lt;ios&gt; // std::fixed\n#include &lt;iostream&gt; // std::cin/cout\n#include &lt;iterator&gt; // std::ostream_iterator/istream\n#include &lt;type_traits&gt; // std::is_same_v\n\ntemplate &lt;typename BasicType&gt;\nauto\nin_out(size_t fprec = 3, size_t dprec = 9) {\n    const auto def_prec{std::cout.precision()}; // save current prec\n    const auto def_flags{std::cout.flags()}; // save current prec\n\n    if constexpr (std::is_same_v&lt;float, BasicType&gt;)\n        std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(fprec);\n    else if constexpr (std::is_same_v&lt;double, BasicType&gt;)\n        std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(dprec);\n\n    auto in = std::istream_iterator&lt;BasicType&gt;{std::cin};\n    auto out = std::ostream_iterator&lt;BasicType&gt;{std::cout, \"\\n\"};\n    std::copy_n(in, 1, out); // *out++ = *in;\n\n    (std::cout &lt;&lt; std::setprecision(def_prec)).flags(def_flags); // reset\n};\n\ntemplate&lt;typename ...BasicTypes&gt;\nauto\nfor_each(size_t fprec = 3, size_t dprec = 9) {\n    (in_out&lt;BasicTypes&gt;(fprec, dprec), ...);\n}\n\nint\nmain(int, char *[]) {\n    for_each&lt;int, long, char, float, double&gt;();\n    return 0;\n}\n</code></pre> <p>GitHub: 05-basic-data-types/basic-data-types-06.cpp </p> <p>Recursion is managed by Fold Expressions with the <code>,</code> operator. We have seen ourselves in the need to outsource the processing of the type again to the <code>in_out</code> function. And we are in the business of less is more.</p>"},{"location":"0050-types-types-types/#the-fold-expression-single-method","title":"The Fold Expression Single Method","text":"<p>This is where another modern member of the C++ family comes to the rescue, because we can make good use of a lambda expression, i.e.: an unnamed function declared there where you need it. We can move the content of <code>in_out</code> inside our <code>for_each</code> to have it working together with the fold expression.</p> <p>But some reworking will be needed, because a lambda expression cannot use templates. OK, because we live in the future we know this is possible with C++20, but our compiler is a veteran still using C++17. Luckily, not all hope is lost, because we can invite a well-known friend to the party: <code>decltype</code>. This time it comes without the famous partner <code>std::declval&lt;T&gt;</code>, but this time extra help in deducing the type is not needed, because it is partnering with someone else: <code>auto</code>. In this case as a parameter type, for the first time ever ... in our C++ ramblings, of course.</p> <p>Because a template parameter is not possible for the lambda, we have crafted an automatic parameter.</p> <pre><code>    auto in_out = [&amp;fprec, &amp;dprec](auto x) {\n</code></pre> <p>GitHub: 05-basic-data-types/basic-data-types-07.cpp:11:11 </p> <p>The parameter will <code>auto</code>-magically adapt itself to what we pass. It is not that we have invented this, because it was invented with C++14, with the concept being named a generic lambda.</p> <p>Notice how we also have <code>fprec</code> and <code>dprec</code> in the lambda expression. They are captures, hence the lack of a default value, because it is captured from the surroundings to be used inside the lambda.</p> <p>To make our Fold Expression cooperate with the lambda, we need to make a small change. In the previous example, we were invoking <code>in_out&lt;BasicTypes&gt;()</code>, because we had a templated function. Not being able to use templated lambda expressions, the best we can do is to pass a value of the type, by instantiating the type.</p> <pre><code>    (in_out(BasicTypes{}), ...);\n</code></pre> <p>GitHub: 05-basic-data-types/basic-data-types-07.cpp:28:28 </p> <p>A value that can be later turned back, for our purposes, into a type with <code>decltype</code>.</p> <pre><code>        using BasicType = decltype(x);  // deduct type of dummy x value\n</code></pre> <p>GitHub: 05-basic-data-types/basic-data-types-07.cpp:15:15 </p> <p>And here is the complete single method approach with a Fold Expression.</p> <p>Here is the single method, thanks to the cooperation of all those heroes.</p> <pre><code>#include &lt;algorithm&gt; // std::copy_n\n#include &lt;iomanip&gt; // std::setprecision\n#include &lt;ios&gt; // std::fixed\n#include &lt;iostream&gt; // std::cin/cout\n#include &lt;iterator&gt; // std::ostream_iterator/istream\n#include &lt;type_traits&gt; // std::is_same_v\n\ntemplate&lt;typename ...BasicTypes&gt;\nauto\nfor_each(size_t fprec = 3, size_t dprec = 9) {\n    auto in_out = [&amp;fprec, &amp;dprec](auto x) {\n        const auto def_prec{std::cout.precision()}; // save current prec\n        const auto def_flags{std::cout.flags()}; // save current flags\n\n        using BasicType = decltype(x);  // deduct type of dummy x value\n        if constexpr (std::is_same_v&lt;float, BasicType&gt;)\n            std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(fprec);\n        else if constexpr (std::is_same_v&lt;double, BasicType&gt;)\n            std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(dprec);\n\n        auto in = std::istream_iterator&lt;BasicType&gt;{std::cin};\n        auto out = std::ostream_iterator&lt;BasicType&gt;{std::cout, \"\\n\"};\n        std::copy_n(in, 1, out); // *out++ = *in;\n\n        (std::cout &lt;&lt; std::setprecision(def_prec)).flags(def_flags); // reset\n    };\n\n    (in_out(BasicTypes{}), ...);\n}\n\nint\nmain(int, char *[]) {\n    for_each&lt;int, long, char, float, double&gt;();\n    return 0;\n}\n</code></pre> <p>GitHub: 05-basic-data-types/basic-data-types-07.cpp </p> <p>There is something worth mentioning before we carry on. Because the Fold Expression is managing the iteration of the parameter pack, this parameter pack is the only parameter to the template. No tricks with a first parameter or even two parameters to differentiate the candidates to be matched. A real improvement.</p> <pre><code>template&lt;typename ...BasicTypes&gt;\n</code></pre> <p>GitHub: 05-basic-data-types/basic-data-types-07.cpp:8:8 </p>"},{"location":"0050-types-types-types/#the-last-crown-jewel-stdvariant","title":"The Last Crown Jewel - std::variant","text":"<p>We need nothing more until we realize we do, because C++17 just keeps on giving. It introduced a type-safe union that can hold any value. One at a time, of course. One only needs to specify the types that may be inside <code>std::variant</code> as template parameters.</p> <p>It would seem as if someone was thinking about our little problem here when they designed this functionality, because that someone also added an <code>std::variant_alternative&lt;size_t, MyVariant&gt;</code>. I.e.: we can retrieve the type specified at a given position for an <code>std::variant</code>.</p> <p>Somehow we need to pass a <code>size_t</code> to our template function and check if we have come to the last type or else recurse. The pieces of the puzzle are all there:</p> <ul> <li> <p>templates do not only take types, they also take values.</p> </li> <li> <p><code>if constexpr</code> has already helped us with the logic to control the recursion.</p> </li> </ul> <p>With all the accumulated experience from the previous attempts, we can do this in one go.</p> <pre><code>#include &lt;algorithm&gt; // std::copy_n\n#include &lt;iomanip&gt; // std::setprecision\n#include &lt;ios&gt; // std::fixed\n#include &lt;iostream&gt; // std::cin/cout\n#include &lt;iterator&gt; // std::ostream_iterator/istream\n#include &lt;type_traits&gt; // std::is_same_v\n#include &lt;variant&gt; // std::variant\n\ntemplate &lt;typename Variant, size_t i = 0&gt;\nauto\nfor_each(size_t fprec = 3, size_t dprec = 9) {\n    const auto def_prec{std::cout.precision()}; // save current prec\n    const auto def_flags{std::cout.flags()}; // save current prec\n\n    using BasicType = std::variant_alternative_t&lt;i, Variant&gt;; // get type\n\n    if constexpr (std::is_same_v&lt;float, BasicType&gt;)\n        std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(fprec);\n    else if constexpr (std::is_same_v&lt;double, BasicType&gt;)\n        std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(dprec);\n\n    auto in = std::istream_iterator&lt;BasicType&gt;{std::cin};\n    auto out = std::ostream_iterator&lt;BasicType&gt;{std::cout, \"\\n\"};\n    std::copy_n(in, 1, out); // *out++ = *in;\n\n    (std::cout &lt;&lt; std::setprecision(def_prec)).flags(def_flags); // reset\n\n    if constexpr ((i + 1) &lt; std::variant_size_v&lt;Variant&gt;)\n        for_each&lt;Variant, i + 1&gt;(fprec, dprec);\n}\n\nint\nmain(int, char *[]) {\n    using BasicTypes = std::variant&lt;int, long, char, float, double&gt;;\n    for_each&lt;BasicTypes&gt;();\n    return 0;\n}\n</code></pre> <p>GitHub: 05-basic-data-types/basic-data-types-08.cpp </p> <p>Our looping <code>for_each</code> now takes only one template parameter for the types, the <code>std::variant</code> that carries those types. It takes a second parameter <code>size_t i = 0</code>, to let us know the current type to be retrieved.</p> <pre><code>    using BasicType = std::variant_alternative_t&lt;i, Variant&gt;; // get type\n</code></pre> <p>GitHub: 05-basic-data-types/basic-data-types-08.cpp:15:15 </p> <p>And retrieved it is. That is the key to having things working. Notice how we have to use a strange notation with <code>i</code>.</p> <pre><code>    if constexpr ((i + 1) &lt; std::variant_size_v&lt;Variant&gt;)\n</code></pre> <p>GitHub: 05-basic-data-types/basic-data-types-08.cpp:28:28 </p> <p>Being <code>size_t i</code> a template parameter, it is \u201cread-only\u201d for the function and we cannot simply do <code>i++</code>, because it is not an lvalue, hence the need to use <code>i + 1</code> for the recursive call.</p>"},{"location":"0050-types-types-types/#summary","title":"Summary","text":"<p>We have not iterated over types in a Python-like style. But we did it, not only with a classic recursive template approach. We have added as much as possible from the weaponry provided by C++17 to let us have single method approaches that control the recursion internally and reduced the template parameters to manage all types with a single one.</p> <p>It is time to bury this topic, although there may be more to come.</p>"},{"location":"0060-types-resurrection/","title":"Types - Resurrected","text":"<p>Title: Basic Data Types Link: https://www.hackerrank.com/challenges/c-tutorial-basic-data-types </p>"},{"location":"0060-types-resurrection/#iterating-iterators","title":"Iterating Iterators","text":"<p>That oxymoron is simply there to remark that for the \u201cBasic Data Types\u201d challenge we actually iterated over the types and we did not see a single iterator along the way. In spite of all the wonders we applied, <code>if constexpr</code>, <code>sizeof...</code>, fold expressions, and <code>std::variant</code>, we were working in compile-time mode. There was no room for iterators.</p> <p>But there is always room for improvement, and we are going to find room for the iterators.</p>"},{"location":"0060-types-resurrection/#templated-iterators","title":"Templated Iterators","text":"<p>Obviously, if we have been working with templates to address the problem of moving around a list of types, using templated iterators seems like the way to go.</p> <p>We are going to use two new C++ elements, and as it has been the case, we are going to couple another C++17 present with a couple of C++ veterans. The modern element is <code>std::any</code>, a class capable of holding any value, that has to be retrieved with the proper type hint, using <code>std::any_cast&lt;T&gt;(any_instance)</code>. Our veteran will be <code>std::vector</code>, to store factories of iterators for different types. Those factories will be hosted by another C++11 family member veteran, namely <code>std::function</code>.</p> <p>Recall that we previously had different ways of iterating over the list of types. To build something more complex we still need a first iteration over them. We will be building upon the latest solution, using <code>std::variant</code> and looping with a <code>size_t i</code> template parameter.</p> <p>Let us see how the factories and the storage for them are modeled.</p> <pre><code>using InTypeProcs = std::vector&lt;std::function&lt;std::any(std::istream &amp;)&gt;&gt;;\n\nusing OutTypeProcs = std::vector&lt;\n    std::function&lt;void(std::ostream &amp;, const std::any &amp;, size_t, size_t)&gt;&gt;;\n</code></pre> <p>GitHub: 06-basic-data-types-resurrections/basic-data-types-resurrections-01.cpp:12:12 </p> <p>For the input, there will be a vector holding functions that return <code>std::any</code> and take an <code>std::istream &amp;</code> as the only parameter. The <code>std::vector</code> for the output will hold functions that take an <code>std::ostream &amp;</code>, the value in the form of <code>std::any</code>, and finally two <code>size_t</code> parameters. We need those two to pass the values controlling the decimal places for <code>float</code> and <code>double</code>.</p> <p>Let us see how we will use that for the input iterator, which we name <code>vistream_iterator</code> (where <code>v</code> stands for <code>variant</code>).</p> <pre><code>template &lt;typename Variant, size_t i = 0&gt;\nauto\nfor_each_in(InTypeProcs &amp;intypeprocs) {\n    auto intypeproc = [](std::istream &amp;is) {\n        using BasicType = std::variant_alternative_t&lt;i, Variant&gt;; // get type\n        auto in = std::istream_iterator&lt;BasicType&gt;{is};\n        return std::any{*in};\n    };\n    intypeprocs.push_back(intypeproc);\n\n    if constexpr ((i + 1) &lt; std::variant_size_v&lt;Variant&gt;)\n        for_each_in&lt;Variant, i + 1&gt;(intypeprocs);\n}\n\n\n    vistream_iterator(std::istream &amp;is)\n        : m_is{is}, m_end{not std::variant_size_v&lt;Variant&gt;} {\n\n        for_each_in&lt;Variant&gt;(m_intypeprocs);\n    }\n</code></pre> <p>GitHub: 06-basic-data-types-resurrections/basic-data-types-resurrections-01.cpp:14:26 </p> <p>Just as we did previously, we recurse over the types stored in the <code>std::variant</code> we receive as a template parameter. For each type a lambda is created and stored in a vector. That lambda will later take over and create an <code>std::istream_iterator</code> of the corresponding type, returning it embedded in an <code>std::any</code> instance.</p> <p>The key to using those lambda expressions is in the <code>*</code> and <code>++</code> operators.</p> <pre><code>    auto operator *() const {\n        auto intypeproc = *std::next(m_intypeprocs.begin(), m_pos);\n        return intypeproc(m_is);\n    }\n    // Prefix increment\n    auto operator ++() {\n        m_end = (++m_pos == std::variant_size_v&lt;Variant&gt;);\n        return *this;\n    }\n</code></pre> <p>GitHub: 06-basic-data-types-resurrections/basic-data-types-resurrections-01.cpp:53:61 </p> <p>When someone invokes the <code>*</code> operator, the next lambda* is retrieved. Literally, <code>std::next</code> is always called with an offset to the beginning of the container. That offset is incremented during <code>++</code> operations, checking if the end of the container has been reached.</p> <p>There is of course a corresponding recursion procedure for the output.</p> <pre><code>template &lt;typename Variant, size_t i = 0&gt;\nauto\nfor_each_out(OutTypeProcs &amp;otypeprocs) {\n    auto proc = [](std::ostream &amp;os, const std::any &amp;val,\n                   size_t fprec = 3, size_t dprec = 9) {\n\n        using BasicType = std::variant_alternative_t&lt;i, Variant&gt;; // get type\n        const auto def_prec{os.precision()}; // save current prec\n        const auto def_flags{os.flags()}; // save current prec\n        auto out = std::ostream_iterator&lt;BasicType&gt;{os};\n        if constexpr (std::is_same_v&lt;float, BasicType&gt;)\n            os &lt;&lt; std::fixed &lt;&lt; std::setprecision(fprec);\n        else if constexpr (std::is_same_v&lt;double, BasicType&gt;)\n            os &lt;&lt; std::fixed &lt;&lt; std::setprecision(dprec);\n\n        *out++ = std::any_cast&lt;const BasicType &amp;&gt;(val);\n        (os &lt;&lt; std::setprecision(def_prec)).flags(def_flags); // reset\n    };\n    otypeprocs.push_back(proc);\n\n    if constexpr ((i + 1) &lt; std::variant_size_v&lt;Variant&gt;)\n        for_each_out&lt;Variant, i + 1&gt;(otypeprocs);\n}\n</code></pre> <p>GitHub: 06-basic-data-types-resurrections/basic-data-types-resurrections-01.cpp:81:103 </p> <p>The code in the lambda does the same as we did previously. The only novelty, as is the case with the input, is the pre-creation of the lambdas that go into the <code>std::vector</code>. The <code>vostream_iterator</code> in which we have our storage, will later retrieve the corresponding lambda.</p> <pre><code>    auto &amp;operator =(const std::any &amp;val) const {\n        auto otypeproc = *std::next(m_otypeprocs.begin(), m_pos);\n        otypeproc(m_os, val, m_fprec, m_dprec);\n        m_os &lt;&lt; m_delim;\n        return *this;\n    }\n</code></pre> <p>GitHub: 06-basic-data-types-resurrections/basic-data-types-resurrections-01.cpp:142:147 </p> <p>As was the case with our previous custom output iterator the real work takes place in the <code>=</code> operator. Here also, <code>std::next</code> is used to fetch the lambda that knows what to do with the <code>std::any</code>, given also an output stream and the values for the decimal places for <code>float</code> and <code>double</code>.</p> <p>It is now possible to create an STL-like solution. Here is the code for the entire solution.</p> <pre><code>#include &lt;any&gt; // std::any\n#include &lt;algorithm&gt; // std::copy_n\n#include &lt;functional&gt; // std::function\n#include &lt;iomanip&gt; // std::setprecision\n#include &lt;ios&gt; // std::fixed\n#include &lt;iostream&gt; // std::cin/cout\n#include &lt;iterator&gt; // std::ostream_iterator/istream\n#include &lt;type_traits&gt; // std::is_same_v\n#include &lt;variant&gt; // std::variant\n#include &lt;vector&gt; // std::vector\n\nusing InTypeProcs = std::vector&lt;std::function&lt;std::any(std::istream &amp;)&gt;&gt;;\n\ntemplate &lt;typename Variant, size_t i = 0&gt;\nauto\nfor_each_in(InTypeProcs &amp;intypeprocs) {\n    auto intypeproc = [](std::istream &amp;is) {\n        using BasicType = std::variant_alternative_t&lt;i, Variant&gt;; // get type\n        auto in = std::istream_iterator&lt;BasicType&gt;{is};\n        return std::any{*in};\n    };\n    intypeprocs.push_back(intypeproc);\n\n    if constexpr ((i + 1) &lt; std::variant_size_v&lt;Variant&gt;)\n        for_each_in&lt;Variant, i + 1&gt;(intypeprocs);\n}\n\ntemplate &lt;typename Variant&gt;\nstruct vistream_iterator {\n    // Iterator tags\n    using iterator_category = std::input_iterator_tag;\n    using difference_type   = std::ptrdiff_t;\n    using value_type        = std::any;\n    using reference         = value_type &amp;;\n    using pointer           = value_type *;\n\n    InTypeProcs m_intypeprocs;\n    size_t m_pos = 0;\n\n    std::istream &amp;m_is;\n    bool m_end = false;\n\n    vistream_iterator(std::istream &amp;is)\n        : m_is{is}, m_end{not std::variant_size_v&lt;Variant&gt;} {\n\n        for_each_in&lt;Variant&gt;(m_intypeprocs);\n    }\n    // dummy m_is initialization to avoid using -fpermissive\n    vistream_iterator() : m_is{std::cin}, m_end{true} {}\n\n    auto operator -&gt;() const noexcept { return this; }\n\n    auto operator *() const {\n        auto intypeproc = *std::next(m_intypeprocs.begin(), m_pos);\n        return intypeproc(m_is);\n    }\n    // Prefix increment\n    auto operator ++() {\n        m_end = (++m_pos == std::variant_size_v&lt;Variant&gt;);\n        return *this;\n    }\n    // Postfix increment\n    auto operator ++(int) const {\n        auto tmp = *this;\n        ++(*this);\n        return tmp;\n    }\n\n    auto operator ==(const vistream_iterator&amp; other) const {\n        return m_end ? other.m_end : (other.m_end ? false : m_pos == other.m_pos);\n    };\n    auto operator !=(const vistream_iterator&amp; other) const {\n        return not (*this == other);\n    }\n};\n\n///////////////////////////////////////////////////////////////////////////\nusing OutTypeProcs = std::vector&lt;\n    std::function&lt;void(std::ostream &amp;, const std::any &amp;, size_t, size_t)&gt;&gt;;\n\ntemplate &lt;typename Variant, size_t i = 0&gt;\nauto\nfor_each_out(OutTypeProcs &amp;otypeprocs) {\n    auto proc = [](std::ostream &amp;os, const std::any &amp;val,\n                   size_t fprec = 3, size_t dprec = 9) {\n\n        using BasicType = std::variant_alternative_t&lt;i, Variant&gt;; // get type\n        const auto def_prec{os.precision()}; // save current prec\n        const auto def_flags{os.flags()}; // save current prec\n        auto out = std::ostream_iterator&lt;BasicType&gt;{os};\n        if constexpr (std::is_same_v&lt;float, BasicType&gt;)\n            os &lt;&lt; std::fixed &lt;&lt; std::setprecision(fprec);\n        else if constexpr (std::is_same_v&lt;double, BasicType&gt;)\n            os &lt;&lt; std::fixed &lt;&lt; std::setprecision(dprec);\n\n        *out++ = std::any_cast&lt;const BasicType &amp;&gt;(val);\n        (os &lt;&lt; std::setprecision(def_prec)).flags(def_flags); // reset\n    };\n    otypeprocs.push_back(proc);\n\n    if constexpr ((i + 1) &lt; std::variant_size_v&lt;Variant&gt;)\n        for_each_out&lt;Variant, i + 1&gt;(otypeprocs);\n}\n\ntemplate &lt;typename Variant&gt;\nclass vostream_iterator {\npublic:\n    // needed for an iterator\n    using iterator_category = std::output_iterator_tag;\n    using difference_type   = std::ptrdiff_t;\n    using value_type        = std::any;\n    using reference         = value_type &amp;;\n    using pointer           = value_type *;\n\nprivate:\n    OutTypeProcs m_otypeprocs;\n    size_t m_pos = 0;\n\n    std::ostream &amp;m_os;\n    std::string m_delim;\n    size_t m_fprec;\n    size_t m_dprec;\n\npublic:\n    // constructor replicating the wrapped iterator's constructor\n    vostream_iterator(std::ostream &amp;os, const std::string &amp;delim,\n        size_t fprec = 3, size_t dprec = 9)\n        : m_os{os}, m_delim(delim), m_fprec(fprec), m_dprec(dprec) {\n\n        for_each_out&lt;Variant&gt;(m_otypeprocs);\n    }\n    // no-ops because only the assignment (= operator does something)\n    auto operator -&gt;() const { return this; };\n    auto &amp;operator *() const { return *this; }\n    auto &amp;operator ++() { ++m_pos; return *this; } // ++prefix\n    auto operator ++(int) const { //postfix++\n        auto tmp = *this;\n        ++(*this);\n        return tmp;\n    }\n    // Operation with the wrapped iterator, choosing when to output the sep\n    auto &amp;operator =(const std::any &amp;val) const {\n        auto otypeproc = *std::next(m_otypeprocs.begin(), m_pos);\n        otypeproc(m_os, val, m_fprec, m_dprec);\n        m_os &lt;&lt; m_delim;\n        return *this;\n    }\n};\n\n// Solution\ntemplate&lt;typename I, typename O&gt;\nauto\nbasic_types(I first, I last, O out) {\n    return std::copy(first, last, out);\n}\n\nint\nmain(int, char *[]) {\n    using BasicTypes = std::variant&lt;int, long, char, float, double&gt;;\n    basic_types(\n        vistream_iterator&lt;BasicTypes&gt;{std::cin},\n        vistream_iterator&lt;BasicTypes&gt;{},\n        vostream_iterator&lt;BasicTypes&gt;{std::cout, \"\\n\"}\n    );\n    return 0;\n}\n</code></pre> <p>GitHub: 06-basic-data-types-resurrections/basic-data-types-resurrections-01.cpp </p>"},{"location":"0060-types-resurrection/#criticism","title":"Criticism","text":"<p>Even if we have made our code dynamic and STL-like, we have probably made things overly complex. Especially because there is an interdependency between the input and the output as they have to remain synchronized to ensure the output iterator retrieves the proper lambda to match the type stored in the <code>std::any</code> instance.</p> <p>There must be a way to remove that link between the input and output iterators.</p>"},{"location":"0060-types-resurrection/#dynamic-type-output","title":"Dynamic Type Output","text":"<p>Tackling the nature of the input iterator is not going to be easy because it has to respect the ordering of the target types. But for starters, we can do sensible things such as taking the generation of the input functions out of the constructor.</p> <p>In the case of the output iterator we can go several steps beyond also doing that. <code>std::any</code> has a very interesting member function named <code>type</code>. As the name indicates it lets us know things about the type being held because it \u201creturns the typeid of the contained value\u201d. That means we get the following done for us: <code>typeid(type_in_std::any)</code>, returning the type information in an instance of <code>std::type_info</code>.</p> <p>C++11 brought us <code>std::type_index</code>, a wrapper around the latter to make it possible to use the type information as the key in mapping containers. And that is what is going to help us with a simplification of the output iterator. We first put the output functions in an <code>std::map</code> using an <code>std::type_index</code> as the key. When the time comes to do actual output, <code>std::any</code>, via <code>type()</code>, gives us a <code>type_info</code>, that we can wrap inside an <code>std::type_index</code> to look for the proper function in the <code>std::map</code>.</p> <pre><code>using BasicTypes = std::variant&lt;int, long, char, float, double&gt;;\n\nusing InTypeProc = std::function&lt;std::any(std::istream &amp;)&gt;;\nusing InTypeProcs = std::vector&lt;InTypeProc&gt;;\n\nusing OutTypeProc = std::function&lt;void(std::ostream &amp;, const std::any &amp;)&gt;;\nusing OutTypeProcs = std::map&lt;std::type_index, OutTypeProc&gt;;\n\nstatic InTypeProcs intypeprocs; // storage for the input fetching procs\nstatic OutTypeProcs outtypeprocs;  // storage for the output procs\n\ntemplate &lt;typename Variant, size_t i = 0&gt;\nauto\nfor_each(InTypeProcs &amp;itp, OutTypeProcs &amp;otp) {\n    using BasicType = std::variant_alternative_t&lt;i, Variant&gt;; // get type\n    auto intypeproc = [](std::istream &amp;is) {\n        return std::any{*std::istream_iterator&lt;BasicType&gt;{is}};\n    };\n    itp.push_back(intypeproc);\n\n    auto outtypeproc = [](std::ostream &amp;os, const std::any &amp;a) {\n        os &lt;&lt; std::any_cast&lt;BasicType&gt;(a);\n    };\n    auto typeidx = std::type_index(typeid(BasicType));\n    otp.insert(std::make_pair(typeidx, outtypeproc));\n\n    if constexpr ((i + 1) &lt; std::variant_size_v&lt;Variant&gt;)\n        for_each&lt;Variant, i + 1&gt;(itp, otp);\n}\n</code></pre> <p>GitHub: 06-basic-data-types-resurrections/basic-data-types-resurrections-02.cpp:14:42 </p> <p>We have gone the <code>using</code> way to have a clear view of the containers holding our input/output functions, the ones working directly with <code>std::any</code>. Iterating over the types of the <code>std::variant</code> used to hold the types, both the <code>std::vector</code> and the <code>std::map</code> are generated.</p> <p>The input iterator does not change much because it still needs to know the number of types it has to fetch and it still keeps an index with <code>m_pos</code>.</p> <p>On the other hand <code>vostream_iterator</code> is no longer a template based class.</p> <pre><code>///////////////////////////////////////////////////////////////////////////\nclass vostream_iterator {\npublic:\n</code></pre> <p>GitHub: 06-basic-data-types-resurrections/basic-data-types-resurrections-02.cpp:87:89 </p> <p>That also means there is no index to track in parallel to the index of the input iterator. We can now have a generic approach to finding the right function by retrieving it from the <code>std::map</code> with the information from the <code>std::any</code> instance.</p> <pre><code>    auto &amp;operator =(const std::any &amp;a) const {\n        const auto def_prec{m_os.precision()}; // save current prec\n        const auto def_flags{m_os.flags()}; // save current flags\n\n        if (a.type() == typeid(float))\n            m_os &lt;&lt; std::fixed &lt;&lt; std::setprecision(m_fprec);\n        else if (a.type() == typeid(double))\n            m_os &lt;&lt; std::fixed &lt;&lt; std::setprecision(m_dprec);\n\n        // use structured bindings to get our out-type-proc\n        auto &amp;[_, otproc] = *outtypeprocs.find(std::type_index(a.type()));\n        otproc(m_os, a);\n\n        (m_os &lt;&lt; std::setprecision(def_prec)).flags(def_flags); // reset\n        m_os &lt;&lt; m_delim;\n        return *this;\n    }\n</code></pre> <p>GitHub: 06-basic-data-types-resurrections/basic-data-types-resurrections-02.cpp:114:130 </p> <p>For bonus points, we also use <code>typeid(type)</code> to find out if the fixed point precision has to be set for <code>float</code> and <code>double</code>. We were previously doing that directly in the output procedures with <code>if constexpr</code>, but can do it dynamically here now thanks to the <code>type()</code> member function of <code>std::any</code>.</p> <p>To make our life easier we use another of the goodies of C++17, i.e.: Structured Bindings. It feels almost like unpacking an iterable in Python.</p> <pre><code>        // use structured bindings to get our out-type-proc\n        auto &amp;[_, otproc] = *outtypeprocs.find(std::type_index(a.type()));\n        otproc(m_os, a);\n</code></pre> <p>GitHub: 06-basic-data-types-resurrections/basic-data-types-resurrections-02.cpp:123:125 </p> <p>It also feels like magic, because we can unpack the <code>std::pair</code> held by the map directly into variables, that can be declared as <code>auto</code>. Just like in Python we use <code>_</code> as a placeholder for the variable we want to ignore. This will apparently be official in C++26, when one will be able to use officially use the placeholder and do so as many times as needed.</p> <p>Let us see the complete code of this second solution.</p> <pre><code>#include &lt;any&gt; // std::any\n#include &lt;algorithm&gt; // std::copy_n\n#include &lt;functional&gt; // std::function\n#include &lt;iomanip&gt; // std::setprecision\n#include &lt;ios&gt; // std::fixed\n#include &lt;iostream&gt; // std::cin/cout\n#include &lt;iterator&gt; // std::ostream_iterator/istream\n#include &lt;map&gt; // std::map\n#include &lt;type_traits&gt; // std::is_same_v\n#include &lt;variant&gt; // std::variant\n#include &lt;vector&gt; // std::vector\n#include &lt;typeindex&gt; // std::type_index\n\nusing BasicTypes = std::variant&lt;int, long, char, float, double&gt;;\n\nusing InTypeProc = std::function&lt;std::any(std::istream &amp;)&gt;;\nusing InTypeProcs = std::vector&lt;InTypeProc&gt;;\n\nusing OutTypeProc = std::function&lt;void(std::ostream &amp;, const std::any &amp;)&gt;;\nusing OutTypeProcs = std::map&lt;std::type_index, OutTypeProc&gt;;\n\nstatic InTypeProcs intypeprocs; // storage for the input fetching procs\nstatic OutTypeProcs outtypeprocs;  // storage for the output procs\n\ntemplate &lt;typename Variant, size_t i = 0&gt;\nauto\nfor_each(InTypeProcs &amp;itp, OutTypeProcs &amp;otp) {\n    using BasicType = std::variant_alternative_t&lt;i, Variant&gt;; // get type\n    auto intypeproc = [](std::istream &amp;is) {\n        return std::any{*std::istream_iterator&lt;BasicType&gt;{is}};\n    };\n    itp.push_back(intypeproc);\n\n    auto outtypeproc = [](std::ostream &amp;os, const std::any &amp;a) {\n        os &lt;&lt; std::any_cast&lt;BasicType&gt;(a);\n    };\n    auto typeidx = std::type_index(typeid(BasicType));\n    otp.insert(std::make_pair(typeidx, outtypeproc));\n\n    if constexpr ((i + 1) &lt; std::variant_size_v&lt;Variant&gt;)\n        for_each&lt;Variant, i + 1&gt;(itp, otp);\n}\n\ntemplate &lt;typename Variant&gt;\nstruct vistream_iterator {\n    // Iterator tags\n    using iterator_category = std::input_iterator_tag;\n    using difference_type   = std::ptrdiff_t;\n    using value_type        = std::any;\n    using reference         = value_type &amp;;\n    using pointer           = value_type *;\n\n    size_t m_pos = 0;\n\n    std::istream &amp;m_is = std::cin;\n    bool m_end = true;\n\n    vistream_iterator(std::istream &amp;is) :\n        m_is{is}, m_end{not std::variant_size_v&lt;Variant&gt;} {}\n    vistream_iterator() {}\n\n    auto operator -&gt;() const noexcept { return this; }\n    auto operator *() const {\n        auto intypeproc = *std::next(intypeprocs.begin(), m_pos);\n        return intypeproc(m_is);\n    }\n    // Prefix increment\n    auto operator ++() {\n        m_end = (++m_pos == std::variant_size_v&lt;Variant&gt;);\n        return *this;\n    }\n    // Postfix increment\n    auto operator ++(int) const {\n        auto tmp = *this;\n        ++(*this);\n        return tmp;\n    }\n\n    auto operator ==(const vistream_iterator&amp; other) const {\n        return m_end ? other.m_end : (other.m_end ? false : m_pos == other.m_pos);\n    };\n    auto operator !=(const vistream_iterator&amp; other) const {\n        return not (*this == other);\n    }\n};\n\n///////////////////////////////////////////////////////////////////////////\nclass vostream_iterator {\npublic:\n    // needed for an iterator\n    using iterator_category = std::output_iterator_tag;\n    using difference_type   = std::ptrdiff_t;\n    using value_type        = std::any;\n    using reference         = value_type &amp;;\n    using pointer           = value_type *;\n\nprivate:\n    std::ostream &amp;m_os;\n    std::string m_delim;\n    size_t m_fprec;\n    size_t m_dprec;\n\npublic:\n    // constructor replicating the wrapped iterator's constructor\n    vostream_iterator(std::ostream &amp;os, const std::string &amp;delim,\n        size_t fprec = 3, size_t dprec = 9)\n        : m_os{os}, m_delim{delim}, m_fprec{fprec}, m_dprec{dprec} {}\n    // no-ops because only the assignment (= operator does something)\n    auto operator -&gt;() const { return this; };\n    auto &amp;operator *() const { return *this; }\n    auto &amp;operator ++() { return *this; } // ++prefix\n    auto operator ++(int) const { return *this; }\n\n    auto &amp;operator =(const std::any &amp;a) const {\n        const auto def_prec{m_os.precision()}; // save current prec\n        const auto def_flags{m_os.flags()}; // save current flags\n\n        if (a.type() == typeid(float))\n            m_os &lt;&lt; std::fixed &lt;&lt; std::setprecision(m_fprec);\n        else if (a.type() == typeid(double))\n            m_os &lt;&lt; std::fixed &lt;&lt; std::setprecision(m_dprec);\n\n        // use structured bindings to get our out-type-proc\n        auto &amp;[_, otproc] = *outtypeprocs.find(std::type_index(a.type()));\n        otproc(m_os, a);\n\n        (m_os &lt;&lt; std::setprecision(def_prec)).flags(def_flags); // reset\n        m_os &lt;&lt; m_delim;\n        return *this;\n    }\n};\n\n// Solution\ntemplate&lt;typename I, typename O&gt;\nauto\nbasic_types(I first, I last, O out) {\n    return std::copy(first, last, out);\n}\n\nint\nmain(int, char *[]) {\n    for_each&lt;BasicTypes&gt;(intypeprocs, outtypeprocs);\n    basic_types(\n        vistream_iterator&lt;BasicTypes&gt;{std::cin},\n        vistream_iterator&lt;BasicTypes&gt;{},\n        vostream_iterator{std::cout, \"\\n\"}\n    );\n    return 0;\n}\n</code></pre> <p>GitHub: 06-basic-data-types-resurrections/basic-data-types-resurrections-02.cpp </p>"},{"location":"0060-types-resurrection/#going-the-iterating-mile","title":"Going The Iterating Mile","text":"<p>We started this new chapter because iterating over the list of types was not the goal. That is why we now have solutions based on iterators. Unfortunately, these solutions rely on knowledge of the <code>std::variant</code> and the containers with helpers to fetch types from <code>std::cin</code> and put them to <code>std::cout</code>.</p> <p>A real success would be to remove those two dependencies and make the code even more generic. And yes, we can!</p> <p>Let us start by backpedaling a bit. We decided to go for <code>std::any</code> as the vehicle to pass instances of the types back and forth, because it can hold anything. However, that flexibility comes with a price: getting the value out of an <code>std::any</code> instance is hard, hence the need to have so many lambda expressions, why we synchronized the iterators first and had to work with <code>std::type_info</code> later.</p> <p>Let us look at three ideas to streamline our solution</p> <ol> <li> <p>Given that we are using <code>std::variant</code> to convey the types and it can also hold instances of the types, it may be a lot easier to work with it.</p> </li> <li> <p>Let our iterator, literally iterate over the container, instead of doing something with the container. I.e.: our custom iterator will work with iterators to traverse the container of lambda expressions.</p> </li> <li> <p>If getting the value out of an <code>std::variant</code>, with the right type, is easier than with <code>std::any</code>, we may remove the lambda expressions for the output and make the output iterator really generic.</p> </li> </ol> <p>The code generating the lambdas for fetching the values from <code>std::cin</code> does not change. It is still an <code>std::vector</code>, holding lambdas, but this time the return value is an <code>std::variant</code>. Let us show it.</p> <pre><code>using BasicTypes = std::variant&lt;int, long, char, float, double&gt;;\nusing InTypeProc = std::function&lt;BasicTypes(std::istream &amp;)&gt;;\nusing InTypeProcs = std::vector&lt;InTypeProc&gt;;\n\nstatic InTypeProcs intypeprocs;\n\ntemplate &lt;typename Variant, size_t i = 0&gt;\nauto\nfor_each_in(InTypeProcs &amp;itp) {\n    using BasicType = std::variant_alternative_t&lt;i, Variant&gt;; // get type\n    auto intypeproc = [](std::istream &amp;is) {\n        return Variant{*std::istream_iterator&lt;BasicType&gt;{is}};\n    };\n</code></pre> <p>GitHub: 06-basic-data-types-resurrections/basic-data-types-resurrections-03.cpp:12:24 </p> <p>No lambdas are generated for the output.</p> <p>The input iterator works with a <code>typename I</code>, that must be an iterator.</p> <pre><code>template &lt;typename I&gt;\nstruct vistream_iterator {\n    // Iterator tags\n    using iterator_category = std::input_iterator_tag;\n    using difference_type   = std::ptrdiff_t;\n    using value_type        = std::any;\n    using reference         = value_type &amp;;\n    using pointer           = value_type *;\n\n    std::istream &amp;m_is = std::cin;\n    I m_first, m_last;\n    bool m_end = true;\n\n    vistream_iterator(std::istream &amp;is, I first, I last)\n        : m_is{is}, m_first{first}, m_last{last}, m_end{first == last} {}\n    vistream_iterator(I last) : m_first{last}, m_last{last} {}\n\n    auto operator -&gt;() const noexcept { return this; }\n    auto operator *() const {\n        return (*m_first)(m_is); // fetched intypeproc delivers result\n    }\n    // Prefix increment\n    auto &amp;operator ++() {\n        m_end = ((++m_first) == m_last);\n        return *this;\n    }\n    // Postfix increment\n    auto operator ++(int) const {\n        auto tmp = *this;\n        ++(*this);\n        return tmp;\n    }\n</code></pre> <p>GitHub: 06-basic-data-types-resurrections/basic-data-types-resurrections-03.cpp:31:62 </p> <p>It is used during construction to get the beginning, with <code>first</code>, and the end, with <code>last</code>, of the range that holds procedures to fetch the types. Our input iterator no longer needs to know things about the container. Because the range is not directly controlled by our iterator, the second constructor that defines the end of iteration also needs to know where the end of the real range is. And that it is why it takes also a <code>last</code> parameter.</p> <p>Granted, with some SFINAE we could restrict and check that the iterator <code>I</code> is of type InputIterator and delivers the expected result when dereferenced.</p> <p>Things are even better for the output iterator. We had already decoupled it from the <code>std::variant</code> but it still had to rely on a set of external functions (lambdas) to output each type, as the type had to be forcefully extracted from <code>std::any</code>. With the use of <code>std::variant</code> things are a lot cleaner.</p> <pre><code>    template&lt;typename V&gt;\n    auto &amp;operator =(const V &amp;v) const {\n        const auto def_prec{m_os.precision()}; // save current prec\n        const auto def_flags{m_os.flags()}; // save current flags\n\n        // visit our variant val and get the type in auto format\n        std::visit([&amp;](auto &amp;arg) {  // arg is the value inside variant v\n            using T = std::decay_t&lt;decltype(arg)&gt;; // deduce actual type\n            // do something if float or double\n            if constexpr (std::is_same_v&lt;T, float&gt;)\n                m_os &lt;&lt; std::fixed &lt;&lt; std::setprecision(m_fprec);\n            else if constexpr (std::is_same_v&lt;T, double&gt;)\n                m_os &lt;&lt; std::fixed &lt;&lt; std::setprecision(m_dprec);\n\n            m_os &lt;&lt; arg; // m_os can already work with arg\n        }, v);\n\n        (m_os &lt;&lt; std::setprecision(def_prec)).flags(def_flags); // reset\n        m_os &lt;&lt; m_delim;\n        return *this;\n    }\n</code></pre> <p>GitHub: 06-basic-data-types-resurrections/basic-data-types-resurrections-03.cpp120 </p> <p>Everything happens inside the <code>operator =</code> method and the reason is that extracting the type from an <code>std::variant</code> is not that difficult, because we have the help of new and known friends. First</p> <ul> <li><code>std::visit</code> that will put into a function of our choosing the argument inside the <code>std::variant</code> (or a collection of those)</li> </ul> <p>If we use a generic lambda, i.e.: with an <code>auto</code> parameter, the type will be worked out for us. But we still need the type and:</p> <ul> <li> <p><code>decltype</code> comes to the rescue to get the type of <code>auto &amp;arg</code></p> </li> <li> <p>Coupled with a new friend: <code>std::decay_t</code>. This fine piece of machinery removes the reference and gives us the real type behind <code>auto &amp;arg</code></p> </li> </ul> <p>With the type in the hand, we can again resort to using our compile-time friend and wonder, <code>if constexpr</code>, to apply specific code for <code>float</code> and <code>double</code> as we did in the past.</p> <p>There is something worth mentioning, the <code>template &lt;typename V&gt;</code> technique. Because that <code>V</code> is the parameter to the method. Recall that the input methods will return an <code>std::variant</code> with the value embedded. Our <code>operator =</code> does not need to know the types in the template instantiation; this will be worked out by the compiler.</p> <p>What we could do is add a bit of SFINAE to make sure that <code>V</code> is an <code>std::variant</code>, using <code>std::enable_if_t</code> and a check for the type.</p> <p>Let us see the complete code of this final solution.</p> <pre><code>#include &lt;any&gt; // std::any\n#include &lt;algorithm&gt; // std::copy_n\n#include &lt;functional&gt; // std::function\n#include &lt;iomanip&gt; // std::setprecision\n#include &lt;ios&gt; // std::fixed\n#include &lt;iostream&gt; // std::cin/cout\n#include &lt;iterator&gt; // std::ostream_iterator/istream\n#include &lt;type_traits&gt; // std::is_same_v\n#include &lt;variant&gt; // std::variant\n#include &lt;vector&gt; // std::vector\n\nusing BasicTypes = std::variant&lt;int, long, char, float, double&gt;;\nusing InTypeProc = std::function&lt;BasicTypes(std::istream &amp;)&gt;;\nusing InTypeProcs = std::vector&lt;InTypeProc&gt;;\n\nstatic InTypeProcs intypeprocs;\n\ntemplate &lt;typename Variant, size_t i = 0&gt;\nauto\nfor_each_in(InTypeProcs &amp;itp) {\n    using BasicType = std::variant_alternative_t&lt;i, Variant&gt;; // get type\n    auto intypeproc = [](std::istream &amp;is) {\n        return Variant{*std::istream_iterator&lt;BasicType&gt;{is}};\n    };\n    itp.push_back(intypeproc);\n\n    if constexpr ((i + 1) &lt; std::variant_size_v&lt;Variant&gt;)\n        for_each_in&lt;Variant, i + 1&gt;(itp);\n}\n\ntemplate &lt;typename I&gt;\nstruct vistream_iterator {\n    // Iterator tags\n    using iterator_category = std::input_iterator_tag;\n    using difference_type   = std::ptrdiff_t;\n    using value_type        = std::any;\n    using reference         = value_type &amp;;\n    using pointer           = value_type *;\n\n    std::istream &amp;m_is = std::cin;\n    I m_first, m_last;\n    bool m_end = true;\n\n    vistream_iterator(std::istream &amp;is, I first, I last)\n        : m_is{is}, m_first{first}, m_last{last}, m_end{first == last} {}\n    vistream_iterator(I last) : m_first{last}, m_last{last} {}\n\n    auto operator -&gt;() const noexcept { return this; }\n    auto operator *() const {\n        return (*m_first)(m_is); // fetched intypeproc delivers result\n    }\n    // Prefix increment\n    auto &amp;operator ++() {\n        m_end = ((++m_first) == m_last);\n        return *this;\n    }\n    // Postfix increment\n    auto operator ++(int) const {\n        auto tmp = *this;\n        ++(*this);\n        return tmp;\n    }\n\n    auto operator ==(const vistream_iterator&amp; other) const {\n        return m_end ? other.m_end : (other.m_end ? false : m_first == other.m_first);\n    };\n    auto operator !=(const vistream_iterator&amp; other) const {\n        return not (*this == other);\n    }\n};\n\n///////////////////////////////////////////////////////////////////////////\nclass vostream_iterator {\npublic:\n    // needed for an iterator\n    using iterator_category = std::output_iterator_tag;\n    using difference_type   = std::ptrdiff_t;\n    using value_type        = std::any;\n    using reference         = value_type &amp;;\n    using pointer           = value_type *;\n\nprivate:\n    std::ostream &amp;m_os;\n    std::string m_delim;\n    size_t m_fprec;\n    size_t m_dprec;\n\npublic:\n    // constructor replicating the wrapped iterator's constructor\n    vostream_iterator(std::ostream &amp;os, const std::string &amp;delim,\n        size_t fprec = 3, size_t dprec = 9)\n        : m_os{os}, m_delim{delim}, m_fprec{fprec}, m_dprec{dprec} {}\n\n    // no-ops because only the assignment (= operator does something)\n    auto operator -&gt;() const { return this; };\n    auto &amp;operator *() const { return *this; }\n    auto &amp;operator ++() { return *this; } // ++prefix\n    auto &amp;operator ++(int) { return *this; } // postfix++\n\n    template&lt;typename V&gt;\n    auto &amp;operator =(const V &amp;v) const {\n        const auto def_prec{m_os.precision()}; // save current prec\n        const auto def_flags{m_os.flags()}; // save current flags\n\n        // visit our variant val and get the type in auto format\n        std::visit([&amp;](auto &amp;arg) {  // arg is the value inside variant v\n            using T = std::decay_t&lt;decltype(arg)&gt;; // deduce actual type\n            // do something if float or double\n            if constexpr (std::is_same_v&lt;T, float&gt;)\n                m_os &lt;&lt; std::fixed &lt;&lt; std::setprecision(m_fprec);\n            else if constexpr (std::is_same_v&lt;T, double&gt;)\n                m_os &lt;&lt; std::fixed &lt;&lt; std::setprecision(m_dprec);\n\n            m_os &lt;&lt; arg; // m_os can already work with arg\n        }, v);\n\n        (m_os &lt;&lt; std::setprecision(def_prec)).flags(def_flags); // reset\n        m_os &lt;&lt; m_delim;\n        return *this;\n    }\n};\n\n// Solution\ntemplate&lt;typename I, typename O&gt;\nauto\nbasic_types(I first, I last, O out) {\n    return std::copy(first, last, out);\n}\n\nint\nmain(int, char *[]) {\n    for_each_in&lt;BasicTypes&gt;(intypeprocs);\n    basic_types(\n        vistream_iterator{std::cin, intypeprocs.begin(), intypeprocs.end()},\n        vistream_iterator{intypeprocs.end()},\n        vostream_iterator{std::cout, \"\\n\"}\n    );\n    return 0;\n}\n</code></pre> <p>GitHub: 06-basic-data-types-resurrections/basic-data-types-resurrections-03.cpp </p> <p>Done and dust. We have really generic code for both <code>vistream_iterator</code> and <code>vostream_iterator</code>, both freed from having to have knowledge of the <code>std::variant</code>.</p>"},{"location":"0060-types-resurrection/#summary","title":"Summary","text":"<p>The goal in this chapter was to solve the conundrum of using iterators to iterate over types, rather than fully iterate over the types at compile time. And our solutions have also been subject to iteration until we reached that goal, as much as possible.</p>"},{"location":"0060-types-resurrection/#bonus-points","title":"Bonus Points","text":"<p>OK, if you have made it that far, you have seen the cliffhangers about adding SFINAE for the new things. We could not really leave the chapter without adding it.</p> <p>First, we need to check if the code generating the lambda for type conversion from an <code>std::istream</code> is really getting an <code>std::variant</code>. This is the trickiest because one cannot really check for <code>std::variant</code> because it will always be bound to a template pack.</p> <p>The trick is therefore to specialize a <code>std::false_type</code> / <code>std::true_type</code> check, where the true part is a specialization containing an <code>std::variant&lt;Args...&gt;</code>.</p> <pre><code>// SFINAE to check for a variant\ntemplate&lt;typename V&gt;\nstruct is_variant_t : std::false_type {};\n\n// Need to specialize to consider a template pack, for std::variant\ntemplate&lt;typename ...Args&gt;\nstruct is_variant_t&lt;std::variant&lt;Args...&gt;&gt; : std::true_type {};\n\ntemplate&lt;typename V&gt;\nconstexpr bool is_variant_v = is_variant_t&lt;V&gt;::value;\n\ntemplate&lt;typename V&gt;\nusing enable_if_variant = std::enable_if_t&lt;is_variant_v&lt;V&gt;&gt;*;\n\ntemplate &lt;typename Variant, size_t i = 0, enable_if_variant&lt;Variant&gt; = nullptr&gt;\nauto\nfor_each_in(InTypeProcs &amp;itp) {\n</code></pre> <p>GitHub: 06-basic-data-types-resurrections/basic-data-types-resurrections-04.cpp:18:34 </p> <p><code>vistream_iterator</code> is the next one in need of SFINAE to see if the template parameter <code>I</code> is really an InputIterator and even more: if it delivers a function returning an <code>std::variant</code> after being dereferenced and called with an <code>std::istream</code>. Because that is the expectation when <code>vistream_iterator</code> is dereferenced itself.</p> <pre><code>// SFINAE to check for I being an Input iterator and delivering a variant\ntemplate &lt;typename T, typename Tag&gt;\nconstexpr bool is_it_tag_v = std::is_base_of_v&lt;\n    Tag, typename std::iterator_traits&lt;T&gt;::iterator_category&gt;;\n\ntemplate &lt;typename I&gt;\nconstexpr bool is_input_v = is_it_tag_v&lt;I, std::input_iterator_tag&gt;;\n\ntemplate &lt;typename I&gt;\nconstexpr bool input_variant_v = is_variant_v&lt;\n    typename std::decay_t&lt;decltype(*std::declval&lt;I&gt;())&gt;::result_type&gt;;\n\ntemplate &lt;typename I&gt;\nconstexpr bool is_input_variant_v = is_input_v&lt;I&gt; &amp;&amp; input_variant_v&lt;I&gt;;\n\ntemplate&lt;typename I&gt;\nusing enable_if_input_variant = std::enable_if_t&lt;is_input_variant_v&lt;I&gt;&gt;*;\n\ntemplate &lt;typename I, enable_if_input_variant&lt;I&gt; = nullptr&gt;\nstruct vistream_iterator {\n</code></pre> <p>GitHub: 06-basic-data-types-resurrections/basic-data-types-resurrections-04.cpp:45:64 </p> <p>Recall that lately we had made a new friend, <code>std::decay_t&lt;T&gt;</code>, and it comes to the rescue again. But not alone, because it needs a push from the left, i.e.: being prefixed by <code>typename</code> to be able to finally get down to <code>::result_type</code>.</p> <p>This is because <code>::result_type</code> is a dependent name itself, only available after the previous conundrum has been solved. <code>std::function</code> stores there the return type of the stored function, and that is what we are looking for.</p> <p>After that comes our <code>template &lt;V&gt; vostream::operator =(const V &amp;v) const</code>. That <code>V</code> needs to be a variant. We therefore reuse what we already developed above and apply <code>enable_if_variant&lt;V&gt;</code>.</p> <pre><code>    template&lt;typename V, enable_if_variant&lt;V&gt; = nullptr&gt;\n    auto &amp;operator =(const V &amp;v) const {\n</code></pre> <p>GitHub: 06-basic-data-types-resurrections/basic-data-types-resurrections-04.cpp:132:133 </p> <p>For the general case, we have reapplied the rest of the standard SFINAE machinery, to check for input/output iterators that also have compatible types and was being used in the first solution.</p> <p>It is now that we have a really complete solution. Game over and here is the code.</p> <pre><code>#include &lt;any&gt; // std::any\n#include &lt;algorithm&gt; // std::copy_n\n#include &lt;functional&gt; // std::function\n#include &lt;iomanip&gt; // std::setprecision\n#include &lt;ios&gt; // std::fixed\n#include &lt;iostream&gt; // std::cin/cout\n#include &lt;iterator&gt; // std::ostream_iterator/istream\n#include &lt;type_traits&gt; // std::is_same_v\n#include &lt;variant&gt; // std::variant\n#include &lt;vector&gt; // std::vector\n\nusing BasicTypes = std::variant&lt;int, long, char, float, double&gt;;\nusing InTypeProc = std::function&lt;BasicTypes(std::istream &amp;)&gt;;\nusing InTypeProcs = std::vector&lt;InTypeProc&gt;;\n\nstatic InTypeProcs intypeprocs;\n\n// SFINAE to check for a variant\ntemplate&lt;typename V&gt;\nstruct is_variant_t : std::false_type {};\n\n// Need to specialize to consider a template pack, for std::variant\ntemplate&lt;typename ...Args&gt;\nstruct is_variant_t&lt;std::variant&lt;Args...&gt;&gt; : std::true_type {};\n\ntemplate&lt;typename V&gt;\nconstexpr bool is_variant_v = is_variant_t&lt;V&gt;::value;\n\ntemplate&lt;typename V&gt;\nusing enable_if_variant = std::enable_if_t&lt;is_variant_v&lt;V&gt;&gt;*;\n\ntemplate &lt;typename Variant, size_t i = 0, enable_if_variant&lt;Variant&gt; = nullptr&gt;\nauto\nfor_each_in(InTypeProcs &amp;itp) {\n    using BasicType = std::variant_alternative_t&lt;i, Variant&gt;; // get type\n    auto intypeproc = [](std::istream &amp;is) {\n        return Variant{*std::istream_iterator&lt;BasicType&gt;{is}};\n    };\n    itp.push_back(intypeproc);\n\n    if constexpr ((i + 1) &lt; std::variant_size_v&lt;Variant&gt;)\n        for_each_in&lt;Variant, i + 1&gt;(itp);\n}\n\n// SFINAE to check for I being an Input iterator and delivering a variant\ntemplate &lt;typename T, typename Tag&gt;\nconstexpr bool is_it_tag_v = std::is_base_of_v&lt;\n    Tag, typename std::iterator_traits&lt;T&gt;::iterator_category&gt;;\n\ntemplate &lt;typename I&gt;\nconstexpr bool is_input_v = is_it_tag_v&lt;I, std::input_iterator_tag&gt;;\n\ntemplate &lt;typename I&gt;\nconstexpr bool input_variant_v = is_variant_v&lt;\n    typename std::decay_t&lt;decltype(*std::declval&lt;I&gt;())&gt;::result_type&gt;;\n\ntemplate &lt;typename I&gt;\nconstexpr bool is_input_variant_v = is_input_v&lt;I&gt; &amp;&amp; input_variant_v&lt;I&gt;;\n\ntemplate&lt;typename I&gt;\nusing enable_if_input_variant = std::enable_if_t&lt;is_input_variant_v&lt;I&gt;&gt;*;\n\ntemplate &lt;typename I, enable_if_input_variant&lt;I&gt; = nullptr&gt;\nstruct vistream_iterator {\n    // Iterator tags\n    using iterator_category = std::input_iterator_tag;\n    using difference_type   = std::ptrdiff_t;\n    using value_type        = std::any;\n    using reference         = value_type &amp;;\n    using pointer           = value_type *;\n\n    std::istream &amp;m_is = std::cin;\n    I m_first, m_last;\n    bool m_end = true;\n\n    vistream_iterator(std::istream &amp;is, I first, I last)\n        : m_is{is}, m_first{first}, m_last{last}, m_end{first == last} {}\n    vistream_iterator(I last) : m_first{last}, m_last{last} {}\n\n    auto operator -&gt;() const noexcept { return this; }\n    auto operator *() const {\n        return (*m_first)(m_is); // fetched intypeproc delivers result\n    }\n    // Prefix increment\n    auto &amp;operator ++() {\n        m_end = ((++m_first) == m_last);\n        return *this;\n    }\n    // Postfix increment\n    auto operator ++(int) const {\n        auto tmp = *this;\n        ++(*this);\n        return tmp;\n    }\n\n    auto operator ==(const vistream_iterator&amp; o) const {\n        return m_end ? o.m_end : (o.m_end ? false : m_first == o.m_first);\n    };\n    auto operator !=(const vistream_iterator&amp; other) const {\n        return not (*this == other);\n    }\n};\n\n///////////////////////////////////////////////////////////////////////////\nclass vostream_iterator {\npublic:\n    // needed for an iterator\n    using iterator_category = std::output_iterator_tag;\n    using difference_type   = std::ptrdiff_t;\n    using value_type        = std::any;\n    using reference         = value_type &amp;;\n    using pointer           = value_type *;\n\nprivate:\n    std::ostream &amp;m_os;\n    std::string m_delim;\n    size_t m_fprec;\n    size_t m_dprec;\n\npublic:\n    // constructor replicating the wrapped iterator's constructor\n    vostream_iterator(std::ostream &amp;os, const std::string &amp;delim,\n        size_t fprec = 3, size_t dprec = 9)\n        : m_os{os}, m_delim{delim}, m_fprec{fprec}, m_dprec{dprec} {}\n\n    // no-ops because only the assignment (= operator does something)\n    auto operator -&gt;() const { return this; };\n    auto &amp;operator *() const { return *this; }\n    auto &amp;operator ++() { return *this; } // ++prefix\n    auto &amp;operator ++(int) { return *this; } // postfix++\n\n    template&lt;typename V, enable_if_variant&lt;V&gt; = nullptr&gt;\n    auto &amp;operator =(const V &amp;v) const {\n        const auto def_prec{m_os.precision()}; // save current prec\n        const auto def_flags{m_os.flags()}; // save current flags\n\n        // visit our variant val and get the type in auto format\n        std::visit([&amp;](auto &amp;arg) {  // arg is the value inside variant v\n            using T = std::decay_t&lt;decltype(arg)&gt;; // deduce actual type\n            // do something if float or double\n            if constexpr (std::is_same_v&lt;T, float&gt;)\n                m_os &lt;&lt; std::fixed &lt;&lt; std::setprecision(m_fprec);\n            else if constexpr (std::is_same_v&lt;T, double&gt;)\n                m_os &lt;&lt; std::fixed &lt;&lt; std::setprecision(m_dprec);\n\n            m_os &lt;&lt; arg; // m_os can already work with arg\n        }, v);\n\n        (m_os &lt;&lt; std::setprecision(def_prec)).flags(def_flags); // reset\n        m_os &lt;&lt; m_delim;\n        return *this;\n    }\n};\n\n// SFINAE (extra, input is taken from above) for the general solution\ntemplate &lt;typename O&gt;\nconstexpr bool is_output_v = is_it_tag_v&lt;O, std::output_iterator_tag&gt;;\n\ntemplate&lt;typename I, typename O&gt;\nconstexpr bool io_iterators_v = is_input_v&lt;I&gt; &amp;&amp; is_output_v&lt;O&gt;;\n\ntemplate &lt;typename I, typename O&gt;\nusing io_type = decltype(*std::declval&lt;O&gt;() = *std::declval&lt;I&gt;());\n\ntemplate&lt;typename, typename, typename = void&gt;\nstruct io_i2o : std::false_type {};\n\ntemplate&lt;typename I, typename O&gt;\nstruct io_i2o&lt;I, O, std::void_t&lt;io_type&lt;I, O&gt;&gt;&gt;\n    : std::true_type {};\n\ntemplate&lt;typename I, typename O&gt;\nconstexpr bool io_i2o_v = io_i2o&lt;I, O&gt;::value;\n\ntemplate&lt;typename I, typename O&gt;\nusing enable_if_io = std::enable_if_t&lt;io_iterators_v&lt;I, O&gt; &amp;&amp; io_i2o_v&lt;I, O&gt;&gt;*;\n\n// Solution\ntemplate&lt;typename I, typename O, enable_if_io&lt;I, O&gt; = nullptr&gt;\nauto\nbasic_types(I first, I last, O out) {\n    return std::copy(first, last, out);\n}\n\nint\nmain(int, char *[]) {\n    for_each_in&lt;BasicTypes&gt;(intypeprocs);\n    basic_types(\n        vistream_iterator{std::cin, intypeprocs.begin(), intypeprocs.end()},\n        vistream_iterator{intypeprocs.end()},\n        vostream_iterator{std::cout, \"\\n\"}\n    );\n    return 0;\n}\n</code></pre> <p>GitHub: 06-basic-data-types-resurrections/basic-data-types-resurrections-04.cpp </p>"},{"location":"0070-for-loop/","title":"For Loop","text":"<p>Title: For Loop Link: https://www.hackerrank.com/challenges/c-tutorial-for-loop </p> <p>Let us go for the next \u201cinconsequential\u201d challenge that we want to transform into the best next iterating challenge.</p> <p>This one is a <code>for</code> loop in between the integers <code>a</code> and <code>b</code>, where those integers are read from <code>std::cin</code>. The output yields the equivalent integer as a word for anything <code>&lt; 10</code>, or else the parity of the given integer. An obvious approach to the problem would be as follows.</p> <pre><code>#include &lt;iostream&gt; // std::cout\n\nint\nmain(int, char *[]) {\n    const char *numbers[] = { // we do not need the zero index, a &gt;= 1\n        \"even\", \"one\", \"two\", \"three\", \"four\",\n        \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"odd\"\n    };\n\n    int a, b;\n    std::cin &gt;&gt; a &gt;&gt; b;\n    for(int i = a; i &lt;= b; i++)\n        std::cout &lt;&lt; numbers[i &lt; 10 ? i : 10 * (i % 2)] &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> <p>GitHub: 07-for-loop/for-loop-01.cpp </p> <p>To be really smart, we use the left and right sides of the <code>const char *numbers</code> array to have our <code>even</code> and <code>odd</code> results all stored within a single data structure.</p>"},{"location":"0070-for-loop/#going-python","title":"Going Python","text":"<p>Using some <code>std::istream_iterator&lt;int&gt;</code> and <code>std::ostream_iterator&lt;std::string&gt;</code> is not what we are looking for. Our goal has to be an iteration that removes the <code>for</code> loop and lets us iterate from <code>a</code> to <code>b</code>, i.e.: we need something that generates all the integers.</p> <p>We obviously do not want to create an <code>std::vector</code> that holds all the integers, even if in the test case that goes with the code we have <code>8</code> and <code>11</code>. That will, for sure, not mean any kind of stress, but we could be considering millions of integers, and the question is: why should we be storing them? If we consider Python, the built-in <code>range</code> can be used. For example (simplified example):</p> <pre><code>    '\\n'.join(numbers[i if i &lt; 10 else 10 * (i % 2)] for i in range(a, b + 1))\n</code></pre> <p>Ranges in Python are half-open, hence the <code>b + 1</code>, and the integers are not generated, then stored, and finally delivered one by one. The function generates and yields an integer, delivering the next when requested. We know (living in the future) that C++20 has implemented something like this with: <code>std::views::iota(1, 10)</code>, but recall we are still on C++17.</p> <p>Let us therefore address the problem of \u201creplicating\u201d (what we need) the <code>range</code> function in C++. Because we want to pass the range to a function that transforms the integers to a string, we need a range\u2014i.e., <code>first</code> and <code>last</code> iterators\u2014that we will get from the <code>begin</code> and <code>end</code> functions. What we are basically describing is a container, and in our case we are describing a \u201cvirtual\u201d container, because we are not going to contain anything, except the description of the range: <code>start</code>, <code>stop</code>. Although we could hardcode the step-by-step increment between those limits, let us be flexible by defining also a <code>step</code>, which will default to a value of <code>1</code>.</p> <p>This is how the beginning of our container looks like.</p> <pre><code>template &lt;typename T=int&gt;\nclass Range {\n    struct StartStopStep {\n        const T start = 0;\n        const T stop = std::numeric_limits&lt;T&gt;::max();\n        const T step = 1;\n    } m_sss;\n</code></pre> <p>GitHub: 07-for-loop/for-loop-02.cpp:7:13 </p> <p>Notice how, right from the start, our container is a template defaulting to <code>int</code>. The idea is to allow using different types of integral types. To disallow using something like a <code>float</code>, we will later consider SFINAE. To make the range as unlimited as possible, the default value for the <code>stop</code> part is taken from the standard library with <code>std::numeric_limits&lt;T&gt;::max()</code>. Much better than writing fixed values.</p> <p>The constructors are the next best addition to the sauce of this container.</p> <ol> <li> <p>We have a <code>struct StartStopStep</code> defined, so let us use it as a direct input for a constructor. That would be akin to using a <code>slice</code> in Python.</p> </li> <li> <p>Given that we have already referred to Python a couple of times, nothing like defining constructors that mimic the way the built-in <code>range</code> works.</p> </li> <li> <p>Number of parameters: <code>1</code>. The value is used for <code>stop</code>. Our other parameters take default values, i.e.: <code>start = 0</code> and <code>step = 1</code>.</p> </li> <li> <p>Number of parameters: <code>2</code>. These are then, in order, <code>start</code> and <code>stop</code>, with <code>step</code> again defaulting to <code>1</code>.</p> </li> <li> <p>Number of parameters: <code>3</code>. These are then, in order, <code>start</code>, <code>stop</code>, and <code>step</code>.</p> </li> </ol> <p>Although we have three options for the constructor family taking integers, we only need to define two of them. Let us see it.</p> <pre><code>public:\n    Range(const StartStopStep&amp; sss) : m_sss{sss} {};\n    Range(const T stop) : m_sss{.stop=stop} {};\n    Range(const T start, const T stop, const T step = 1)\n        : m_sss{.start=start, .stop=stop, .step=step} {};\n</code></pre> <p>GitHub: 07-for-loop/for-loop-02.cpp:15:19 </p> <p>The last constructor covers the <code>2-parameters</code> and <code>3-parameters</code>, assigning a default value to <code>step</code>. This last constructor shows us something very interesting: a pseudo-parameter-by-name calling convention.</p> <pre><code>    Range(const T stop) : m_sss{.stop=stop} {};\n    Range(const T start, const T stop, const T step = 1)\n        : m_sss{.start=start, .stop=stop, .step=step} {};\n</code></pre> <p>GitHub: 07-for-loop/for-loop-02.cpp:17:19 </p> <p>Our internal member <code>m_sss</code>, an instance of <code>StartStopStep</code>, is being initialized by referring to the members defined in it, just by prefixing the name with a <code>.</code> (a dot). It feels almost like Python, but it is not. The magic is limited, but it is a nice example of how \u201cnamed parameters\u201d can make things very clear. Consider that Python ended up adding more types of parameters, like positional-only parameters and named-only parameters, to give users finer-grained control when calling a function.</p> <p>It is now time to see how this container defines the iterator that will go over the <code>StartStopRange</code>.</p> <pre><code>private:\n    struct Iter {\n    private:\n        StartStopStep m_sss;\n        T m_pos;\n\n    public:\n        // Iterator tags\n        using iterator_category = std::forward_iterator_tag;\n        using difference_type   = std::ptrdiff_t;\n        using value_type        = T;\n        using reference         = value_type; // usually value_type &amp;\n        using pointer           = value_type; // usually value_type *\n\n        Iter(const StartStopStep &amp;sss) : m_sss{sss}, m_pos{m_sss.start} {};\n        Iter(const T &amp;pos) : m_sss{.stop=pos}, m_pos{pos}  {}; // en-of-range\n\n        auto operator *() const { return m_pos; }\n        auto operator -&gt;() const { return m_pos; }\n        auto&amp; operator ++() { // Prefix increment - increase until stop\n            m_pos = std::min(m_pos + m_sss.step, m_sss.stop);\n            return *this;\n        }\n        // Postfix increment\n        auto operator ++(int) { Iter tmp = *this; ++(*this); return tmp; }\n\n        auto operator ==(const Iter&amp; o) const { return m_pos == o.m_pos; }\n        auto operator !=(const Iter&amp; o) const { return m_pos != o.m_pos; }\n    };\n</code></pre> <p>GitHub: 07-for-loop/for-loop-02.cpp:21:49 </p> <p>The iterator needs to know how the range is defined, and it will therefore hold a copy of it. We could have achieved the same effect by keeping a pointer to the container that instantiated the iterator. For practical purposes, it is the same. But notice that if we do not hold that pointer, the container could be deleted and the iterator can still be valid.</p> <p>Something that seems contradictory, because if there is no container after the deletion, one could ask what it is that the iterator is iterating on. In our case, the answer is easy: on the virtual range <code>StartStopStep</code>, that is not contained anywhere, but rather defined in the container. If the iterator makes a copy of the range definition, it can directly use that definition to iterate.</p> <p>The rest should be straightforward. There is an <code>m_pos</code> member that will control where the iterator is, used at the same time to directly hold the final position when instantiating the end-of-range iterator through the method <code>end</code>. The iterator will increase <code>m_pos</code>, if still possible, on each iteration, until the value defined by <code>stop</code> is reached.</p> <p>It is time to show the entire solution. But before that, let us explain the other things we did. We have also:</p> <ul> <li> <p>Gathered input with an <code>std::istream_iterator&lt;int&gt;(std::cin)</code>, creating <code>auto</code> variables for <code>a</code> and <code>b</code>.</p> </li> <li> <p>Used our container <code>Range</code> to define the iteration range <code>[a, b]</code>, which is a closed range including both <code>a</code> and <code>b</code>.</p> <p>Recall that we are emulating the Python version and our definition is half-open, <code>[a, b)</code>. Hence the need to instantiate the container with <code>range = Range(a, b + 1)</code>.</p> </li> <li> <p>Put our solution in a separate method that takes an input range with <code>first</code> and <code>last</code> iterators and a destination <code>out</code> iterator.</p> </li> <li> <p>Invoked our solution with <code>range.begin()</code> and <code>range.end()</code> and our already classic output iterator, i.e.: <code>std::ostream_iterator&lt;std::string&gt;(std::cout, \u201c\\n\u201d)</code>.</p> </li> </ul> <p>In our solution method we have done two things that differ from the previous simplistic approach. Because our objective is to reuse what people have developed over the years for the STL, we:</p> <ul> <li> <p>Changed the storage for the words to be an <code>std::array</code>. Recall that with C++17 we can abuse the compiler and avoid telling how many elements there are and what the type of the elements is.</p> </li> <li> <p>Put the logic to decide the output word in a small lambda expression.</p> </li> <li> <p>We need it to be able to use <code>std::transform(first, last, destination, unary_predicate)</code>. I.e.: our range will be iterated and each value will be passed as the single argument (\u201cunary\u201d) to our lambda/function (\u201cpredicate\u201d). The result of the evaluation will be sent to the destination.</p> </li> </ul> <p>Our case is simple and things go to the standard output, but we could be sending the result to an <code>std::vector</code> or the iterator could point to a network socket or send an HTTP request to a well-known API.</p> <p>Here is the code.</p> <pre><code>#include &lt;algorithm&gt; // std::transform\n#include &lt;array&gt; // std::array\n#include &lt;iostream&gt; // std::cin/cout\n#include &lt;iterator&gt; // std::istream/ostream_iterator\n#include &lt;limits&gt; // std::numeric_limits\n\ntemplate &lt;typename T=int&gt;\nclass Range {\n    struct StartStopStep {\n        const T start = 0;\n        const T stop = std::numeric_limits&lt;T&gt;::max();\n        const T step = 1;\n    } m_sss;\n\npublic:\n    Range(const StartStopStep&amp; sss) : m_sss{sss} {};\n    Range(const T stop) : m_sss{.stop=stop} {};\n    Range(const T start, const T stop, const T step = 1)\n        : m_sss{.start=start, .stop=stop, .step=step} {};\n\nprivate:\n    struct Iter {\n    private:\n        StartStopStep m_sss;\n        T m_pos;\n\n    public:\n        // Iterator tags\n        using iterator_category = std::forward_iterator_tag;\n        using difference_type   = std::ptrdiff_t;\n        using value_type        = T;\n        using reference         = value_type; // usually value_type &amp;\n        using pointer           = value_type; // usually value_type *\n\n        Iter(const StartStopStep &amp;sss) : m_sss{sss}, m_pos{m_sss.start} {};\n        Iter(const T &amp;pos) : m_sss{.stop=pos}, m_pos{pos}  {}; // en-of-range\n\n        auto operator *() const { return m_pos; }\n        auto operator -&gt;() const { return m_pos; }\n        auto&amp; operator ++() { // Prefix increment - increase until stop\n            m_pos = std::min(m_pos + m_sss.step, m_sss.stop);\n            return *this;\n        }\n        // Postfix increment\n        auto operator ++(int) { Iter tmp = *this; ++(*this); return tmp; }\n\n        auto operator ==(const Iter&amp; o) const { return m_pos == o.m_pos; }\n        auto operator !=(const Iter&amp; o) const { return m_pos != o.m_pos; }\n    };\n\npublic:\n    auto begin() const { return Iter{m_sss}; } // copy range, pos at start\n    auto end() const { return Iter{m_sss.stop}; } // place directly at end\n};\n\nconstexpr auto numbers = std::array{ // we do not need the zero index, a &gt;= 1\n    \"even\", // index 0\n    \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\",\n    \"odd\" // index 10\n};\n\ntemplate &lt;typename I, typename O&gt;\nauto\nnum2words(I first, I last, O out) {\n    auto n2w = [](auto i) { return numbers[i &lt; 10 ? i : 10 * (i % 2)]; };\n    std::transform(first, last, out, n2w);\n}\n\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // prepare input iterator\n    auto a = *in++, b = *in++; // gather parameters\n    auto range = Range{a, b + 1};  // our range is half-open, need extra +1\n    num2words(\n        range.begin(), range.end(),\n        std::ostream_iterator&lt;std::string&gt;{std::cout, \"\\n\"}\n    );\n\n    return 0;\n}\n</code></pre> <p>GitHub: 07-for-loop/for-loop-02.cpp </p>"},{"location":"0070-for-loop/#refining-and-sfinae","title":"Refining And SFINAE","text":"<p>Let us start with our <code>Range&lt;T = int&gt;</code>. Ideally, we would accept anything that works like an integral type. For obvious reasons, a <code>float</code> (or a <code>double</code>) may lead to failures due to the non-exact nature of floating point arithmetic. With that in mind, adding SFINAE for <code>Range&lt;T = int&gt;</code> looks like this.</p> <pre><code>template &lt;typename T&gt;\nusing enable_if_integral = std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;;\n\ntemplate &lt;typename T = int, typename = enable_if_integral&lt;T&gt;&gt;\nclass Range {\n</code></pre> <p>GitHub: 07-for-loop/for-loop-03.cpp:8:12 </p> <p>Note that we have changed how we integrate our custom <code>enable_if</code>. Instead of delivering a type that will have a default value, <code>enable_if&lt;x, y&gt; = nullptr</code>, we use the return type as the input to an anonymous template parameter, i.e.:</p> title<pre><code>template &lt;typename T = int, typename = enable_if&lt;x, y&gt;&gt;\n</code></pre> <p>Just a different way to use our SFINAE machinery.</p> <p>There is something that we have to take into account because <code>std::is_integral&lt;T&gt;</code> will recognize integral types. However, user-defined classes that work like integral types will not pass the test.</p> <p>We would need this other check.</p> <pre><code>template &lt;typename T&gt;\nusing enable_if_integral = std::enable_if_t&lt;std::numeric_limits&lt;T&gt;::is_integer&gt;;\n\ntemplate &lt;typename T = int, typename = enable_if_integral&lt;T&gt;&gt;\nclass Range {\n</code></pre> <p>With a specialization added to recognize our user-defined type. <code>std::is_integral</code> has undefined behavior if specializations are added.</p> <p>Furthermore, we also have this at the beginning of <code>Range</code>.</p> <pre><code>    struct StartStopStep {\n        const T start = 0;\n        const T stop = std::numeric_limits&lt;T&gt;::max();\n        const T step = 1;\n    } m_sss;\n</code></pre> <p>GitHub: 07-for-loop/for-loop-03.cpp:13:17 </p> <p>I.e., we source the maximum value of our integral type <code>std::numeric_limits&lt;T&gt;::max()</code> and we would need a similar construct (or a specialization) for our user-defined <code>T</code>. Too much for the scope of our work.</p> <p>With regards to the iterators, we could simply add the previous SFINAE machinery, fire and forget. However, we have something we can improve: our solution function could take iterators and a custom function to solve the problem. And that means we also have to check the signature of that function: parameters and return type. This is how we do it.</p> <pre><code>template &lt;typename T&gt;\nusing it_type = typename std::iterator_traits&lt;T&gt;::value_type;\n\ntemplate &lt;typename I, typename F&gt;\nusing i2f_type = std::invoke_result_t&lt;F, it_type&lt;I&gt;&gt;;\n\ntemplate&lt;typename, typename, typename, typename = void&gt;\nconstexpr bool i2f2o_v = false;\n\ntemplate&lt;typename I, typename O, typename F&gt;\nconstexpr bool i2f2o_v&lt;I, O, F,\n    std::void_t&lt;decltype(std::declval&lt;O&gt;() = std::declval&lt;i2f_type&lt;I, F&gt;&gt;())&gt;\n    &gt;\n    = true;\n</code></pre> <p>GitHub: 07-for-loop/for-loop-03.cpp:74:87 </p> <p>We first fetch the type of the input iterator with <code>std::iterator_traits&lt;T&gt;::value_type</code> as an alternative to our previous formulation with <code>decltype(*std::declval&lt;T&gt;())</code>. This is what goes as the parameter to the function provided for the solution.</p> <p>To get the return type we meet a new helping hand: <code>std::invoke_result&lt;F, Args ...&gt;</code>, a new entry in C++17. Given a callable <code>F</code> and a set of types that will be provided as arguments for the call, we find out the return type at compile time.</p> <p>With those two things in hand and having also an output iterator <code>O</code>, we use the <code>constexpr bool</code> templated setup to find out if the output iterator can take what the function returns after taking the type. For that we use again <code>std::void_t&lt;type, ...&gt;</code>. Recall that it will turn valid types into <code>void</code> and fail otherwise. Our type will be valid if our <code>std::declval</code> formulation inside <code>decltype</code> is valid: <code>std::declval&lt;O&gt;() = std::declval&lt;i2f_type&lt;I, F&gt;&gt;()</code>. I.e., if the <code>operator=</code> of our output iterator can take the return type of the solution function, given the proper input type.</p> <p>We put it all together with the standard checks to see if our template parameters are iterators (or at least look like them) and coupled with <code>std::enable_if</code>, we have a good barrier for wrong inputs.</p> <pre><code>template &lt;typename I, typename O, typename F&gt;\nusing enable_if_iof = std::enable_if_t&lt;io_iterators_v&lt;I, O&gt; &amp;&amp; i2f2o_v&lt;I, O, F&gt;&gt;;\n\ntemplate &lt;typename I, typename O, typename F, typename = enable_if_iof&lt;I, O, F&gt;&gt;\nauto\nnum2words(I first, I last, O out, F n2w) {\n    std::transform(first, last, out, n2w);\n}\n</code></pre> <p>GitHub: 07-for-loop/for-loop-03.cpp:89:96 </p> <p>The full code contains four alternative formulations of functions for the solutions. Only one solves the challenge but that is not the point. The point being: two of them meet the SFINAE requirements and two of them fail them (wrong number of parameters and wrong return type). Feel free to play with them. The default is the function that solves the problem.</p> <p>Feel free to compile with <code>make 03 caseX</code>, where <code>X</code> is the digit that corresponds to the expected define value in the code, but uppercased as <code>CASEX</code>.</p> <p>Here is the full code. See the definitions.</p> <pre><code>#include &lt;algorithm&gt; // std::transform\n#include &lt;array&gt; // std::array\n#include &lt;iostream&gt; // std::cin/cout\n#include &lt;iterator&gt; // std::istream/ostream_iterator\n#include &lt;limits&gt; // std::numeric_limits\n#include &lt;type_traits&gt; // std::enable_if, std::is_integral, std::void_t\n\ntemplate &lt;typename T&gt;\nusing enable_if_integral = std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;;\n\ntemplate &lt;typename T = int, typename = enable_if_integral&lt;T&gt;&gt;\nclass Range {\n    struct StartStopStep {\n        const T start = 0;\n        const T stop = std::numeric_limits&lt;T&gt;::max();\n        const T step = 1;\n    } m_sss;\n\npublic:\n    Range(const StartStopStep&amp; sss) : m_sss{sss} {};\n    Range(const T stop) : m_sss{.stop=stop} {};\n    Range(const T start, const T stop, const T step = 1)\n        : m_sss{.start=start, .stop=stop, .step=step} {};\n\nprivate:\n    struct Iter {\n    private:\n        StartStopStep m_sss;\n        T m_pos;\n\n    public:\n        // Iterator tags\n        using iterator_category = std::forward_iterator_tag;\n        using difference_type   = std::ptrdiff_t;\n        using value_type        = T;\n        using reference         = value_type; // usually value_type &amp;\n        using pointer           = value_type; // usually value_type *\n\n        Iter(const StartStopStep &amp;sss) : m_sss{sss}, m_pos{m_sss.start} {};\n        Iter(const T &amp;pos) : m_sss{.stop=pos}, m_pos{pos}  {}; // end-of-range\n\n        auto operator *() const { return m_pos; }\n        auto operator -&gt;() const { return &amp;m_pos; }\n        auto&amp; operator ++() { // Prefix increment - increase until stop\n            m_pos = std::min(m_pos + m_sss.step, m_sss.stop);\n            return *this;\n        }\n        // Postfix increment\n        auto operator ++(int) { Iter tmp = *this; ++(*this); return tmp; }\n\n        auto operator ==(const Iter&amp; o) const { return m_pos == o.m_pos; }\n        auto operator !=(const Iter&amp; o) const { return m_pos != o.m_pos; }\n    };\n\npublic:\n    auto begin() const { return Iter{m_sss}; } // copy range, pos at start\n    auto end() const { return Iter{m_sss.stop}; } // place directly at end\n};\n\n// SFINAE to check for I being an Input iterator and delivering a variant\ntemplate &lt;typename T, typename Tag&gt;\nconstexpr bool is_it_tag_v =\n    std::is_base_of_v&lt;Tag, typename std::iterator_traits&lt;T&gt;::iterator_category&gt;;\n\ntemplate &lt;typename I&gt;\nconstexpr bool is_input_v = is_it_tag_v&lt;I, std::input_iterator_tag&gt;;\n\ntemplate &lt;typename O&gt;\nconstexpr bool is_output_v = is_it_tag_v&lt;O, std::output_iterator_tag&gt;;\n\ntemplate&lt;typename I, typename O&gt;\nconstexpr bool io_iterators_v = is_input_v&lt;I&gt; &amp;&amp; is_output_v&lt;O&gt;;\n\ntemplate &lt;typename T&gt;\nusing it_type = typename std::iterator_traits&lt;T&gt;::value_type;\n\ntemplate &lt;typename I, typename F&gt;\nusing i2f_type = std::invoke_result_t&lt;F, it_type&lt;I&gt;&gt;;\n\ntemplate&lt;typename, typename, typename, typename = void&gt;\nconstexpr bool i2f2o_v = false;\n\ntemplate&lt;typename I, typename O, typename F&gt;\nconstexpr bool i2f2o_v&lt;I, O, F,\n    std::void_t&lt;decltype(std::declval&lt;O&gt;() = std::declval&lt;i2f_type&lt;I, F&gt;&gt;())&gt;\n    &gt;\n    = true;\n\ntemplate &lt;typename I, typename O, typename F&gt;\nusing enable_if_iof = std::enable_if_t&lt;io_iterators_v&lt;I, O&gt; &amp;&amp; i2f2o_v&lt;I, O, F&gt;&gt;;\n\ntemplate &lt;typename I, typename O, typename F, typename = enable_if_iof&lt;I, O, F&gt;&gt;\nauto\nnum2words(I first, I last, O out, F n2w) {\n    std::transform(first, last, out, n2w);\n}\n\n// SFINAE is over\nconstexpr auto numbers = std::array{ // we do not need the zero index, a &gt;= 1\n    \"even\", // index 0\n    \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\",\n    \"odd\" // index 10\n};\n\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // prepare input iterator\n    auto a = *in++, b = *in++; // gather parameters\n    auto range = Range{a, b + 1};  // our range is half-open, need extra +1\n\n#ifdef CASE1\n    // SFINAE =&gt; NOK - 1 parameters but returns int\n    auto n2w = [](auto i) { return i; };\n#elif defined CASE2\n    // SFINAE =&gt; OK - 1 parameter and returns string - solution FAILS\n    auto n2w = [](auto i) { return std::string{}; };\n#elif defined CASE3\n    // SFINAE =&gt; NOK - 2 parameters instead of 1\n    auto n2w = [](auto i, auto x) { return std::string{}; };\n#else // Default - The problem solution\n    // SFINAE =&gt; OK - 1 param, returns convertible to std::string\n    auto n2w = [](auto i) { return numbers[i &lt; 10 ? i : 10 * (i % 2)]; };\n#endif\n\n    num2words(\n        range.begin(), range.end(),\n        std::ostream_iterator&lt;std::string&gt;{std::cout, \"\\n\"},\n        n2w\n    );\n\n    return 0;\n}\n</code></pre> <p>GitHub: 07-for-loop/for-loop-03.cpp </p>"},{"location":"0070-for-loop/#generalizing-things","title":"Generalizing Things","text":"<p>Our trick positioning the strings \u201ceven\u201d and \u201codd\u201d at the ends of the container (a <code>std::array</code>) seems like a hack of past times. Similar to when Spectrum/C64 programmers had to optimize the usage of every byte of RAM. So much that those legendary coders even looked for existing patterns in the code that could be re-used as explosions.</p> <p>But in doing so we have made our code dependent on a maximum of <code>9</code> elements and with fixed positions. It is time for a more general approach, including extra SFINAE.</p> <p>We could use <code>std::find</code> and go over the range of the container, check if the <code>end</code> iterator has been reached and default to the \u201ceven/odd\u201d behavior. Our solution function <code>n2w</code> would have to get either the container, to instantiate the iterators, or receive the iterators, but let me say it in advance: \u201cHouston, we have a problem!\u201d. That works for an <code>std::array</code> and an <code>std::vector</code>. However, with an <code>std::map</code> the dereferencing of the iterator gives us an <code>std::pair</code> and we therefore would need different versions of the solution function <code>n2w</code>.</p> <p>The three containers that we have mentioned share a method to locate an element and it is of interest to us because it can throw an exception. This method is <code>at</code> and the idea behind our new plan should be clear: use <code>at(key)</code>. If the element is found the value behind the key will be returned. Else, an exception will be raised and we can then apply the default \u201ceven\u201d/\u201codd\u201d behavior.</p> <p>First, and to make things even more general, we define our problem type. We will see below how this helps us.</p> <pre><code>using PTYPE = int;  // problem type for several definitions\n</code></pre> <p>GitHub: 07-for-loop/for-loop-04.cpp:9:9 </p> <p>Our <code>Range</code> remains unscathed. However, when it comes to our previous full-blown SFINAE machinery, we need to check if the container that will be used has an <code>at</code> method. Let us first show how we rewrite our solution function <code>n2w</code> to be generic.</p> <pre><code>    using namespace std::string_literals;\n\n    auto n2w = [](auto i, const auto &amp;container) {\n        try {\n            return container.at(i);\n        } catch(const std::out_of_range &amp; /* e */) {\n            return (i % 2) ? \"odd\"s : \"even\"s;\n        }\n    };\n</code></pre> <p>GitHub: 07-for-loop/for-loop-04.cpp:122:130 </p> <p>In addition to the value <code>i</code> to look for, a <code>container</code> is also a parameter. And this <code>container</code> must have an <code>at</code> method, which will be checked for, i.e., our contractual warranty. This extra parameter makes <code>n2w</code> unsuited for direct usage later with <code>std::transform</code>, hence the need for adaptation and meeting a new friend: <code>std::bind</code>, with which we can fix parameters for a function call, i.e., we do currying<sup>1</sup>.</p> <p>Notice that in the case of returning parity, the strings have a suffix: the s-suffix, i.e., the <code>std::string::operator\"\"s</code> of <code>std::string</code>. We get the suffix in motion with the statement <code>using namespace std::string_literals;</code>. Our text literals end up being standard strings.</p> <p>Our solution does still take the function <code>n2w</code> and it now takes another parameter, a generic <code>container</code>.</p> <pre><code>template &lt;typename I, typename O, typename F, typename C,\n    typename = enable_if_iof&lt;I, O, F, C&gt;&gt;\nauto\nnum2words(I first, I last, O out, F n2w, const C &amp;container) {\n    auto _n2w = std::bind(n2w, std::placeholders::_1, container);\n    std::transform(first, last, out, _n2w);\n}\n</code></pre> <p>GitHub: 07-for-loop/for-loop-04.cpp:108:114 </p> <p>Using <code>std::bind</code>, we fix the parameter <code>container</code> in the second position and use <code>placeholders::_1</code> to indicate that whatever argument is passed in the first position will be put there. In our case also as the first parameter.</p> <p>After making these modifications, we need to account for <code>typename C</code>, our new template parameter, and make sure that the solution function <code>n2w</code> takes it and that it has an <code>at</code> method.</p> <pre><code>template &lt;typename I, typename F, typename C&gt;\nusing i2f_type = std::invoke_result_t&lt;F, it_type&lt;I&gt;, C&gt;;\n\ntemplate&lt;typename, typename, typename, typename, typename = void&gt;\nconstexpr bool i2f2o_v = false;\n\ntemplate&lt;typename I, typename O, typename F, typename C&gt;\nconstexpr bool i2f2o_v&lt;I, O, F, C,\n    std::void_t&lt;decltype(std::declval&lt;O&gt;() = std::declval&lt;i2f_type&lt;I, F, C&gt;&gt;())&gt;\n    &gt; = true;\n\ntemplate &lt;typename C, typename = void&gt;\nconstexpr bool has_method_at = false;\n\ntemplate &lt;typename C&gt;\nconstexpr bool has_method_at&lt;C,\n    std::void_t&lt;decltype(std::declval&lt;C&gt;().at(PTYPE{}))&gt;&gt; = true;\n\ntemplate &lt;typename I, typename O, typename F, typename C&gt;\nusing enable_if_iof = std::enable_if_t&lt;\n    io_iterators_v&lt;I, O&gt; &amp;&amp; i2f2o_v&lt;I, O, F, C&gt; &amp;&amp; has_method_at&lt;C&gt;&gt;;\n</code></pre> <p>GitHub: 07-for-loop/for-loop-04.cpp:80:100 </p> <p>It is first added to the type deduction for the callable <code>F</code> and then checked with <code>has_method_at</code>. To check for the method we use again <code>std::void_t</code> in combination with <code>decltype</code> and <code>std::declval</code>. As it can be seen, the check needs to invoke <code>at</code> and provide a proper parameter (even in an unevaluated context). It is now that <code>PTYPE</code>, our general problem type (fixed to <code>int</code>), comes in handy.</p> <p>We could have done something like this.</p> <pre><code>template &lt;typename C&gt;\nconstexpr bool has_method_at&lt;C,\n    std::void_t&lt;decltype(std::declval&lt;C&gt;().at(int{}))&gt;&gt; = true;\n</code></pre> <p>However, we would have fixed that to be <code>int</code> and <code>at</code> could be taking something else. Another option would have been the following.</p> <pre><code>template &lt;typename C&gt;\nconstexpr bool has_method_at&lt;C,\n    std::void_t&lt;decltype(\n        std::declval&lt;C&gt;().at(std::declval&lt;typename C::key_type&gt;()))&gt;&gt; = true;\n</code></pre> <p>But that would be plainly wrong because it would only work with <code>std::map</code> (or an <code>std::unordered_map</code>), where the existence of <code>key_type</code> is guaranteed. Should we choose to replace the container type <code>C</code> with an <code>std::vector</code> or an <code>std::array</code>, our check would fail.</p> <p>Adding the check for <code>at</code> to our custom version of <code>enable_if</code>, we complete the set of SFINAE tricks for the generic approach to the \u201cFor Loop\u201d challenge.</p> <p>Here is the complete code of the final approach to this challenge.</p> <pre><code>#include &lt;algorithm&gt; // std::transform\n#include &lt;iostream&gt; // std::cin/cout\n#include &lt;iterator&gt; // std::istream/ostream_iterator\n#include &lt;limits&gt; // std::numeric_limits\n#include &lt;map&gt; // std::map\n#include &lt;stdexcept&gt; // std::out_of_range\n#include &lt;type_traits&gt; // std::enable_if, std::is_integral, std::void_t\n\nusing PTYPE = int;  // problem type for several definitions\n\ntemplate &lt;typename T&gt;\nusing enable_if_integral = std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;;\n\ntemplate &lt;typename T = int, typename = enable_if_integral&lt;T&gt;&gt;\nclass Range {\n    struct StartStopStep {\n        const T start = 0;\n        const T stop = std::numeric_limits&lt;T&gt;::max();\n        const T step = 1;\n    } m_sss;\n\npublic:\n    Range(const StartStopStep&amp; sss) : m_sss{sss} {};\n    Range(const T stop) : m_sss{.stop=stop} {};\n    Range(const T start, const T stop, const T step = 1)\n        : m_sss{.start=start, .stop=stop, .step=step} {};\n\nprivate:\n    struct Iter {\n    private:\n        StartStopStep m_sss;\n        T m_pos;\n\n    public:\n        // Iterator tags\n        using iterator_category = std::forward_iterator_tag;\n        using difference_type   = std::ptrdiff_t;\n        using value_type        = T;\n        using reference         = value_type; // usually value_type &amp;\n        using pointer           = value_type; // usually value_type *\n\n        Iter(const StartStopStep &amp;sss) : m_sss{sss}, m_pos{m_sss.start} {};\n        Iter(const T &amp;pos) : m_sss{.stop=pos}, m_pos{pos}  {}; // end-of-range\n\n        auto operator *() const { return m_pos; }\n        auto operator -&gt;() const { return &amp;m_pos; }\n        auto&amp; operator ++() { // Prefix increment - increase until stop\n            m_pos = std::min(m_pos + m_sss.step, m_sss.stop);\n            return *this;\n        }\n        // Postfix increment\n        auto operator ++(int) { Iter tmp = *this; ++(*this); return tmp; }\n\n        auto operator ==(const Iter&amp; o) const { return m_pos == o.m_pos; }\n        auto operator !=(const Iter&amp; o) const { return m_pos != o.m_pos; }\n    };\n\npublic:\n    auto begin() const { return Iter{m_sss}; } // copy range, pos at start\n    auto end() const { return Iter{m_sss.stop}; } // place directly at end\n};\n\n// SFINAE to check for I being an Input iterator and delivering a variant\ntemplate &lt;typename T, typename Tag&gt;\nconstexpr bool is_it_tag_v =\n    std::is_base_of_v&lt;Tag, typename std::iterator_traits&lt;T&gt;::iterator_category&gt;;\n\ntemplate &lt;typename I&gt;\nconstexpr bool is_input_v = is_it_tag_v&lt;I, std::input_iterator_tag&gt;;\n\ntemplate &lt;typename O&gt;\nconstexpr bool is_output_v = is_it_tag_v&lt;O, std::output_iterator_tag&gt;;\n\ntemplate&lt;typename I, typename O&gt;\nconstexpr bool io_iterators_v = is_input_v&lt;I&gt; &amp;&amp; is_output_v&lt;O&gt;;\n\ntemplate &lt;typename T&gt;\nusing it_type = typename std::iterator_traits&lt;T&gt;::value_type;\n\ntemplate &lt;typename I, typename F, typename C&gt;\nusing i2f_type = std::invoke_result_t&lt;F, it_type&lt;I&gt;, C&gt;;\n\ntemplate&lt;typename, typename, typename, typename, typename = void&gt;\nconstexpr bool i2f2o_v = false;\n\ntemplate&lt;typename I, typename O, typename F, typename C&gt;\nconstexpr bool i2f2o_v&lt;I, O, F, C,\n    std::void_t&lt;decltype(std::declval&lt;O&gt;() = std::declval&lt;i2f_type&lt;I, F, C&gt;&gt;())&gt;\n    &gt; = true;\n\ntemplate &lt;typename C, typename = void&gt;\nconstexpr bool has_method_at = false;\n\ntemplate &lt;typename C&gt;\nconstexpr bool has_method_at&lt;C,\n    std::void_t&lt;decltype(std::declval&lt;C&gt;().at(PTYPE{}))&gt;&gt; = true;\n\ntemplate &lt;typename I, typename O, typename F, typename C&gt;\nusing enable_if_iof = std::enable_if_t&lt;\n    io_iterators_v&lt;I, O&gt; &amp;&amp; i2f2o_v&lt;I, O, F, C&gt; &amp;&amp; has_method_at&lt;C&gt;&gt;;\n\n// SFINAE is over\nauto numbers = std::unordered_map&lt;PTYPE, std::string&gt;{\n    {6, \"six\"}, {7, \"seven\"}, {8, \"eight\"}, {9, \"nine\"},\n    {1, \"one\"}, {2, \"two\"}, {3, \"three\"}, {4, \"four\"}, {5, \"five\"},\n};\n\ntemplate &lt;typename I, typename O, typename F, typename C,\n    typename = enable_if_iof&lt;I, O, F, C&gt;&gt;\nauto\nnum2words(I first, I last, O out, F n2w, const C &amp;container) {\n    auto _n2w = std::bind(n2w, std::placeholders::_1, container);\n    std::transform(first, last, out, _n2w);\n}\n\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;PTYPE&gt;{std::cin}; // prepare input iterator\n    auto a = *in++, b = *in++; // gather parameters\n    auto range = Range{a, b + 1};  // our range is half-open, need extra +1\n\n    using namespace std::string_literals;\n\n    auto n2w = [](auto i, const auto &amp;container) {\n        try {\n            return container.at(i);\n        } catch(const std::out_of_range &amp; /* e */) {\n            return (i % 2) ? \"odd\"s : \"even\"s;\n        }\n    };\n\n    num2words(\n        range.begin(), range.end(),\n        std::ostream_iterator&lt;std::string&gt;{std::cout, \"\\n\"},\n        n2w,\n        numbers\n    );\n\n    return 0;\n}\n</code></pre> <p>GitHub: 07-for-loop/for-loop-04.cpp </p> <ol> <li> <p>Wikipedia - https://en.wikipedia.org/wiki/Currying \u21a9</p> </li> </ol>"},{"location":"0080-arrays-introduction/","title":"Arrays Introduction","text":"<p>Title: Arrays Introduction Link: https://www.hackerrank.com/challenges/arrays-introduction/ </p>"},{"location":"0080-arrays-introduction/#variable-length-arrays","title":"Variable Length Arrays","text":"<p>Read some integers, store them in an array, and output them in reverse order. It does not sound difficult. Let us see what we can do.</p> <p>Remember we said that one of the reasons to use the problem sets available at HackerRank was the fact that it seemed partially abandoned. The editor was therefore not locked, and we could redo the entire solution, including the input and output\u2014parts that sometimes seem written by very motivated but inexperienced coders.</p> <p>In this case, the coder tells us the following:</p> <p>Unlike C, C++ allows dynamic allocation of arrays at runtime without special calls like malloc(). If <code>n = 10</code>, <code>int arr[n]</code> will create an array with space for <code>10</code> integers.</p> <p>Your humble author may not be the best coder in the world, but he surely knows something: Variable Length Arrays (aka VLA) are not part of the C++ standard.</p> <p>Furthermore, and unlike stated, the VLA functionality is part of the C standard. It has been part of it for many years. The question is whether the statement (at least for C++) can be proven to be true. Let us give it a try.</p> <pre><code>#include &lt;iostream&gt; // std::cin, std::cout\n\nint\nmain(int, char *[]) {\n    int N; // gather array size and prepare it\n    std::cin &gt;&gt; N;\n    int arr[N]; // NON-STANDARD C++ - Variable Length Array Extension\n\n    for (int i = 0; i &lt; N;)  // input loop\n        std::cin &gt;&gt; arr[i++];\n\n    while(N) // reverse output loop\n        std::cout &lt;&lt; arr[--N] &lt;&lt; \" \";\n\n    return 0;\n}\n</code></pre> <p>GitHub: 08-arrays-intro/arrays-intro-01.cpp </p> <p>Blistering Barnacles! It does work. Notice how we have marked the VLA line with the following comment: \u201cNON-STANDARD C++ - Variable Length Array Extension\u201d. Because it is a compiler extension. Originally, only GCC supported it, but it is also supported by clang today. It is now clear how the author came to the conclusion that C++ supports Variable Length Arrays: he/she gave it a try and it simply worked. This may (and likely will) break with other compilers, of course.</p> <p>Note</p> <p>This solution <code>01</code> can be compiled as <code>make 01 pedantic</code>. The <code>pedantic</code> target deactivates compiler extensions and that means that the build process will fail.</p>"},{"location":"0080-arrays-introduction/#real-standard-variable-length-arrays","title":"Real Standard Variable Length Arrays","text":"<p>Let us see how we do the same but using proper C++.</p> <pre><code>#include &lt;iostream&gt; // std::cin, std::cout\n\nint\nmain(int, char *[]) {\n    // gather array size and prepare it\n    int N;\n    std::cin &gt;&gt; N;\n    int *arr = new int[N]; // standard c++ - dynamic allocation\n\n    for (auto i = 0; i &lt; N;) // input loop\n        std::cin &gt;&gt; arr[i++];\n\n    while(N) // reverse output loop\n        std::cout &lt;&lt; arr[--N] &lt;&lt; \" \";\n\n    delete [] arr; // undo the dynamic allocation\n    return 0;\n}\n</code></pre> <p>GitHub: 08-arrays-intro/arrays-intro-02.cpp </p> <p>Rather than trusting that our compiler will understand, support, and properly manage VLAs, we resort to using the <code>new</code> and <code>delete</code> operators. Actually, we use the array variants: <code>new[]</code> and <code>delete[]</code>. These are real veterans of the History of C++ and were added to the language in 1985.</p> <p>We are using <code>new</code>, <code>delete</code>, and <code>std::cin</code> and <code>std::cout</code>. Replace those with <code>malloc</code>, <code>free</code>, <code>scanf</code>, and <code>printf</code> and we would have C code. Not the solution we are really looking for, but it is a step in the right direction.</p>"},{"location":"0080-arrays-introduction/#smart-pointers-iterators-and-algorithms","title":"Smart Pointers, Iterators and Algorithms","text":"<p>One of the pleasures of Modern C++, i.e., anything C++11 and newer, is that language designers understood that new facilities were needed to ease the burden on coders. Someone asked the rhetorical question about manual allocation/deallocation of memory for pointers/arrays and why that could not be managed with intelligence. And <code>std::unique_ptr&lt;T&gt;</code> was born (there is a <code>Deleter</code> template parameter that I am omitting here). As it happened with the <code>_v</code> variants of compile-time checks that help people, someone thought that no matter how good our <code>std::unique_ptr</code> was, a helper would be even better. C++14 brought <code>std::make_unique</code>.</p> <p>Let us use unique pointers together with iterators and algorithms.</p> <pre><code>#include &lt;algorithm&gt; // std::copy, std::copy_n\n#include &lt;iostream&gt; // std::cin, std::cout\n#include &lt;iterator&gt; // std::istream_iterator\n#include &lt;memory&gt; // std::make_unique\n\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin};\n    auto out = std::ostream_iterator&lt;int&gt;{std::cout, \" \"};\n\n    // gather array size and prepare it\n    auto N = *in++;\n    auto arr = std::make_unique&lt;int[]&gt;(N); // smart pointer\n\n    // solve\n    std::copy_n(in, N, arr.get());\n    std::copy_n(std::make_reverse_iterator(arr.get() + N), N, out);\n\n    return 0;\n}\n</code></pre> <p>GitHub: 08-arrays-intro/arrays-intro-03.cpp </p> <p>A unique pointer manages the allocation and deallocation of memory for us. We request an array of <code>N</code> (input parameter) integers and we get it. But the STL algorithms do not know how to work with smart pointers. Although it \u201ccontains\u201d a pointer, it does not have the classic <code>begin</code> and <code>end</code> methods to give us iterators. And for good reasons: it is holding a pointer to a memory location. The interpretation of that is really down to the programmer. Nothing prevents us from trying to access the <code>N + 1</code> memory location, and we will probably crash the program if we do so.</p> <p>But as we show in that example, we can still use the <code>n</code>-limited version of the copying algorithm, <code>std::copy_n</code>, and use the actual pointer that we retrieve with <code>std::unique_ptr&lt;T&gt;::get()</code>.</p> <p>Even better: we can use that pointer to get a reversed iterator with <code>std::make_reverse_iterator</code> to traverse the array backwards as requested by the problem description. When iterators launched, they were touted as glorified pointers\u2014and seeing that construction, we probably want to agree.</p> <p>Let us state what the problem is: <code>N</code> is present everywhere. And we want to have a solution as generic as possible.</p>"},{"location":"0080-arrays-introduction/#generalizing-smart-pointer-usage","title":"Generalizing Smart Pointer Usage","text":"<p>Although we still are going to use <code>N</code>, we are going to move to using <code>std::copy</code>. First, by reading integers until we hit the end of the input stream. Nothing fancy here.</p> <p>For the output, we are going to use a couple of helpers to define the beginning and the end of the array, to be able to make iterators out of it with <code>std::make_reverse_iterator</code>. The abstraction will help us, although we will still need <code>N</code>.</p> <pre><code>#include &lt;algorithm&gt; // std::copy, std::copy_n\n#include &lt;iostream&gt; // std::cin, std::cout\n#include &lt;iterator&gt; // std::istream_iterator\n#include &lt;memory&gt; // std::make_unique\n\ntemplate&lt;typename T&gt;\nT *abegin(const std::unique_ptr&lt;T[]&gt; &amp;p) {\n    return p.get();\n}\n\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin};\n    auto in_last = std::istream_iterator&lt;int&gt;{};\n    auto out = std::ostream_iterator&lt;int&gt;{std::cout, \" \"};  // delim is \" \"\n\n    // gather array size and prepare it\n    auto N = *in++;\n    auto arr = std::make_unique&lt;int[]&gt;(N); // smart pointer\n\n    // solve\n    std::copy(in, in_last, abegin(arr));\n    std::copy(\n        std::make_reverse_iterator(std::next(abegin(arr), N)),\n        std::make_reverse_iterator(abegin(arr)),\n        out\n    );\n\n    return 0;\n}\n</code></pre> <p>GitHub: 08-arrays-intro/arrays-intro-04.cpp </p> <p>We are getting closer to a general solution. <code>abegin</code> (for \u201carray begin\u201d) gives us the proper abstraction to understand that we can get a position within the array with <code>std::next</code>\u2014the last one, obviously, by moving the pseudo-begin by <code>N</code> positions. If you are wondering why <code>std::begin</code> is not being used here, the answer is simple: it does not work. The official reason is that the end of the array (pointer-based) cannot be known and therefore <code>std::end</code> cannot be calculated to have a <code>begin</code> to <code>end</code> traversal.</p>"},{"location":"0080-arrays-introduction/#going-vector","title":"Going Vector","text":"<p>The obvious approach to overcome all the aforementioned limitations is to go <code>std::vector</code>. This allows us to mark <code>N</code> with the attribute <code>[[maybe_unused]]</code>, to let the compiler know that even if we have to fetch a value from <code>std::cin</code> and store it in <code>N</code>, we will be ignoring that variable.</p> <p>First because we are reading until the end of the input to store things in our container. And later because our solution uses the iterators provided by the container to traverse the array backwards and solve the problem. We go backwards by using reverse iterators, with <code>rbegin</code> and <code>rend</code>.</p> <pre><code>#include &lt;algorithm&gt; // std::copy\n#include &lt;iostream&gt; // std::cin, std::cout\n#include &lt;iterator&gt; // std::istream, std::ostream_iterator, std::inserter\n#include &lt;vector&gt; // std::vector\n\ntemplate &lt;typename T&gt;\nusing it_type = typename std::iterator_traits&lt;T&gt;::value_type;\n\ntemplate &lt;typename I, typename O&gt;\nauto\nreverse_function(I first, I last, O out) {\n    auto v = std::vector&lt;it_type&lt;I&gt;&gt;{};\n    std::copy(first, last, std::back_inserter(v));\n    std::copy(v.rbegin(), v.rend(), out);\n}\n\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin};\n    [[maybe_unused]] auto N = *in++; // get number of ints, part of the input\n    reverse_function(\n        in,\n        std::istream_iterator&lt;int&gt;{},\n        std::ostream_iterator&lt;int&gt;{std::cout, \" \"} // delim is \" \"\n    );\n    return 0;\n}\n</code></pre> <p>GitHub: 08-arrays-intro/arrays-intro-05.cpp </p> <p>Notice how we use a new friend, <code>std::back_inserter(v)</code>, to insert elements at the \u201cback\u201d (i.e., using <code>push_back</code>) of the <code>std::vector</code>. This is our next target: generalizing the use of containers for the solution.</p> <p>Something important is that we use the <code>::value_type</code>, using our <code>it_type</code> helper, of our input iterator to instantiate the proper version of <code>std::vector</code> and make sure that it can hold the input values.</p>"},{"location":"0080-arrays-introduction/#let-the-containers-come-to-us","title":"Let the Containers Come To Us","text":"<p>But only if needed. In the latest solution we assume a couple of things:</p> <ul> <li> <p>The input iterator will only go forward. That means we have to store the incoming integers to be later able to output them in reverse order.</p> </li> <li> <p>That the ideal container to hold the integers (or whatever we may be storing) is an <code>std::vector</code>.</p> </li> <li> <p>We can control the type that will be held in the container.</p> </li> </ul> <p>The other assumptions are the ones we solved using SFINAE in the previous chapters, to check if the input (direct or transformed) can go to the output, if the template parameters are iterators and, and, and.</p> <p>Let us remove all those restrictions. For that, we are going to need the following things:</p> <ul> <li> <p>Lots of SFINAE checks.</p> </li> <li> <p>Compile-time branch selection by checking the properties of the iterators and choosing the appropriate way to work with a container to hold the input values, if needed.</p> </li> </ul> <p>Because we are going to model our solution to even be able to work without storing the values.</p> <p>Let us skip the well-known iterator checks we have from previous chapters and focus on a check we will repeat several times: <code>has_method_name</code>. We are going to see what API a given container has to select how to work with it. There are several <code>method_names</code> to check: <code>begin</code>, <code>end</code>, <code>rbegin</code>, <code>rend</code>, <code>push_back</code>, <code>push_front</code>, and <code>insert</code>. We will do it like this:</p> <pre><code>// has_begin\ntemplate &lt;typename, typename = void&gt;\nconstexpr bool has_begin_v = false;\n\ntemplate &lt;typename C&gt;\nconstexpr bool has_begin_v&lt;\n    C, std::void_t&lt;decltype(std::declval&lt;C&gt;().begin())&gt;&gt; = true;\n</code></pre> <p>GitHub: 08-arrays-intro/arrays-intro-06.cpp:38:44 </p> <p>For methods that take parameters, we have to add some <code>std::declval</code> complexity. See the case for <code>insert</code>:</p> <pre><code>// has_insert\ntemplate &lt;typename, typename = void&gt;\nconstexpr bool has_insert_v = false;\n\ntemplate &lt;typename C&gt;\nconstexpr bool has_insert_v&lt;\n    C,\n    std::void_t&lt;\n        decltype(\n            std::declval&lt;C&gt;().insert(\n                std::declval&lt;typename C::const_iterator&gt;(),\n                std::declval&lt;typename C::value_type&gt;()))&gt;&gt; = true;\n</code></pre> <p>GitHub: 08-arrays-intro/arrays-intro-06.cpp:94:105 </p> <p>For the sake of checking things under a different light, we will be checking for subclassing in the case of <code>std::stack&lt;T&gt;</code>. This container adaptor is actually the perfect fit for the problem description: we push things into it, and the retrieval always happens in <code>LIFO</code> order. Notice that it is a container adaptor and not a container. It relies on other containers to provide the functionality. It does feature a different interface, and we would have needed to check three method names: <code>push</code>, <code>top</code>, and <code>pop</code>. But this also works for us:</p> <pre><code>// is_stack\ntemplate &lt;typename C&gt;\nconstexpr bool is_stack_v =\n    std::is_base_of_v&lt;std::stack&lt;typename C::value_type&gt;, C&gt;;\n</code></pre> <p>GitHub: 08-arrays-intro/arrays-intro-06.cpp:107:110 </p> <p>The <code>bool</code> value is directly provided by an old friend from previous chapters: <code>std::is_base_of_v</code>.</p> <p>With all this in mind, let us see what is the logic to select different code branches.</p> <ul> <li> <p>If the input iterators are Bidirectional Iterators (or the superior Random Access Iterators), nothing will be stored.</p> <p>Our solution function is only concerned with iterators and not where these iterators come from and how they have come to point to the realm of a container holding the values. Only the properties of the iterators are important.</p> <p>If they are bidirectional, we can reverse them with our <code>std::make_reverse_iterator</code> friend and skip storing any values ourselves. Let us see how easy it seems.</p> </li> </ul> <pre><code>        // can directly traverse the input backwards, no storage needed\n        *oerror++ = \"[+]: Bidirectional Iterator for the Input\";\n        std::copy(\n            std::make_reverse_iterator(last),\n            std::make_reverse_iterator(first),\n</code></pre> <p>GitHub: 08-arrays-intro/arrays-intro-06.cpp:146:150 </p> <p>With standard Input Iterators, we will need a container to temporarily hold the input values. Hence the basic definition (still no SFINAE) of our solution function.</p> <pre><code>template &lt;typename I, typename O, typename C = std::stack&lt;it_type&lt;I&gt;&gt;&gt;\nauto\nreverse_function(I first, I last, O out) {\n</code></pre> <p>The default container is the magic <code>std::stack&lt;T&gt;</code> that perfectly fits the problem. But other options are possible, like using <code>std::vector</code>, <code>std::list</code> and others. Let us see the logic.</p> <pre><code>        *oerror++ = \"[+]: Non-Bidirectional Iterator for the Input\";\n        auto c = C{}; // container needed to store input and output in reverse\n\n        if constexpr (is_stack_v&lt;C&gt;) {\n            *oerror++ = \"[+]: Using Stack as container\";\n            std::for_each(first, last, [&amp;c](const auto &amp;x) { c.push(x); });\n            while(not c.empty()) {\n                *out = c.top();\n                c.pop();\n            }\n\n        } else if constexpr (has_push_front_v&lt;C&gt;) {\n            *oerror++ = \"[+]: Using push_front from container\";\n            std::copy(first, last, std::front_inserter(c));\n            std::copy(c.begin(), c.end(), out);\n\n        } else if constexpr (has_push_back_v&lt;C&gt;) {\n            *oerror++ = \"[+]: Using push_back from container\";\n            std::copy(first, last, std::back_inserter(c));\n            std::copy(c.rbegin(), c.rend(), out);\n\n        } else if constexpr (has_insert_v&lt;C&gt;) {\n            *oerror++ = \"[+]: Using insert from container\";\n            std::copy(first, last, std::inserter(c, c.begin()));\n            std::copy(c.rbegin(), c.rend(), out);\n        }\n</code></pre> <p>GitHub: 08-arrays-intro/arrays-intro-06.cpp:153:178 </p> <p>Notice how the C++17 beast <code>if constexpr</code> lets us formulate in an imperative and very natural form how we perform the selection of the different scenarios.</p> <p>If the container is not our LIFO container, we check what insertion method is supported. Some containers support all three: <code>push_back</code>, <code>push_front</code>, and <code>insert</code>, whereas others support only the latter. Choosing to check <code>push_front</code> first means that we can output in reverse order by traversing the container from the beginning to the end, without reversing iterators. The other options will force us to use <code>rbegin</code> and <code>rend</code>, because the elements will be pushed at the back of the container.</p> <p>Notice that we have added some informational messages instantiating an output iterator using <code>std::cerr</code>. This is because we can choose how to build this solution by defining <code>CASE0</code> through <code>CASE3</code> or letting the defaults be built.</p> <p>Doing <code>make 06 case2</code>, for example, will use the standard input iterators and an <code>std::list</code>. This will in turn select a <code>push_front</code> approach and that will be shown with the message being pushed over the standard error stream. Like this:</p> <pre><code>$ make 06 case2\ng++ -std=c++17 -DCASE2 -o build/arrays-intro-06 arrays-intro-06.cpp\n[+]: Non-Bidirectional Iterator for the Input\n[+]: Using push_front from container\n./build/arrays-intro-06 &lt; arrays-intro.input &gt; /tmp/tmp.RgprHlfogT.output\nSolution 06: SUCCESS\n\n\nmake: 'case2' is up to date.\n</code></pre> <p>Choosing <code>case0</code> will first store the values in an <code>std::vector</code> so the Bidirectional Iterators case plays along. No container will be instantiated inside the solution function.</p> <pre><code>$ make 06 case0\nCreating build dir\ng++ -std=c++17 -DCASE0 -o build/arrays-intro-06 arrays-intro-06.cpp\n[+]: Bidirectional Iterator for the Input\n./build/arrays-intro-06 &lt; arrays-intro.input &gt; /tmp/tmp.bfpOg7T5BO.output\nSolution 06: SUCCESS\n\n\nmake: 'case0' is up to date.\n</code></pre> <p>Have a look at the <code>main</code> function below to see how the <code>CASEX</code> definitions choose different scenarios.</p> <p>To support those code paths, we have to make sure that the containers support those things, and this is where the <code>has_method_name_v</code> and <code>is_stack_v</code> are used. Together with an extra check for type compliance between the container and the output operator.</p> <pre><code>// is_container_v\ntemplate&lt;typename C&gt;\nconstexpr bool is_container_v =\n    is_stack_v&lt;C&gt; or\n    (has_push_front_v&lt;C&gt; and has_begin_v&lt;C&gt; and has_end_v&lt;C&gt;) or\n    (has_push_back_v&lt;C&gt; and has_rbegin_v&lt;C&gt; and has_rend_v&lt;C&gt;) or\n    (has_insert_v&lt;C&gt; and has_begin_v&lt;C&gt; and has_rbegin_v&lt;C&gt; and has_rend_v&lt;C&gt;);\n\n// c2o (container to output iterator)\ntemplate&lt;typename, typename, typename = void&gt;\nconstexpr bool c2o_v = false;\n\ntemplate&lt;typename O, typename C&gt;\nconstexpr bool c2o_v&lt;\n    O, C,\n    std::void_t&lt;\n        decltype(\n            std::declval&lt;O&gt;() = std::declval&lt;typename C::value_type&gt;())&gt;&gt; = true;\n\n// enable_if\ntemplate &lt;typename I, typename O, typename C = void&gt;\nusing enable_if_ioc = std::enable_if_t&lt;\n    io_iterators_v&lt;I, O&gt; and i2o_v&lt;I, O&gt;\n    and is_container_v&lt;C&gt; and c2o_v&lt;O, C&gt;&gt;;\n\n// solution\ntemplate &lt;\n    typename I, typename O, typename C = std::stack&lt;it_type&lt;I&gt;&gt;,\n    typename = enable_if_ioc&lt;I, O, C&gt;&gt;\nauto\nreverse_function(I first, I last, O out) {\n</code></pre> <p>GitHub: 08-arrays-intro/arrays-intro-06.cpp:112:142 </p> <p>There is one new check that has been put in action above but for which no implementation has been shown: <code>is_bidir_v&lt;T&gt;</code> to test if an iterator supports moving in both directions. It uses the same machinery as the checks that test iterators to see if they are input or output iterators. See it below in the complete listing of this final solution.</p> <p>If you cannot see the <code>insert</code> path being chosen you are right. There is no use case, in the code, to use it. But the solution is generic enough, so that it can be used with an <code>std::map</code>. The input values could be <code>std::pair</code> instances. A map has neither <code>push_front</code> nor <code>push_back</code> but does support <code>insert</code>, <code>rbegin</code> and <code>rend</code>.</p>"},{"location":"0080-arrays-introduction/#summary","title":"Summary","text":"<p>We have gone from non-standard compiler extensions to create arrays and be bound by the size of the input, <code>N</code>, to using smart pointers and manage pseudo-iterators. Finally, we have come to show a solution that can even reverse the input without using intermediate storage and that can work with many different temporary containers.</p> <pre><code>#include &lt;algorithm&gt; // std::copy\n#include &lt;deque&gt; // std::deque\n#include &lt;iostream&gt; // std::cin, std::cout\n#include &lt;iterator&gt; // std::istream, std::ostream_iterator, std::inserter\n#include &lt;list&gt; // std::vector\n#include &lt;stack&gt; // std::stack\n#include &lt;vector&gt; // std::vector\n#include &lt;type_traits&gt; // std::void_t, std::enable_if ...\n\n// SFINAE to check for I being an Input iterator and delivering a variant\ntemplate &lt;typename T, typename Tag&gt;\nconstexpr bool is_it_tag_v =\n    std::is_base_of_v&lt;Tag, typename std::iterator_traits&lt;T&gt;::iterator_category&gt;;\n\ntemplate &lt;typename I&gt;\nconstexpr bool is_input_v = is_it_tag_v&lt;I, std::input_iterator_tag&gt;;\n\ntemplate &lt;typename O&gt;\nconstexpr bool is_output_v = is_it_tag_v&lt;O, std::output_iterator_tag&gt;;\n\ntemplate &lt;typename I&gt;\nconstexpr bool is_bidir_v = is_it_tag_v&lt;I, std::bidirectional_iterator_tag&gt;;\n\ntemplate&lt;typename I, typename O&gt;\nconstexpr bool io_iterators_v = is_input_v&lt;I&gt; &amp;&amp; is_output_v&lt;O&gt;;\n\ntemplate &lt;typename T&gt;\nusing it_type = typename std::iterator_traits&lt;T&gt;::value_type;\n\n// check if type returned by *I fits into O's operator=\ntemplate&lt;typename, typename, typename = void&gt;\nconstexpr bool i2o_v = false;\n\ntemplate&lt;typename I, typename O&gt;\nconstexpr bool i2o_v&lt;\n    I, O, std::void_t&lt;decltype(std::declval&lt;O&gt;() = *std::declval&lt;I&gt;())&gt;&gt; = true;\n\n// has_begin\ntemplate &lt;typename, typename = void&gt;\nconstexpr bool has_begin_v = false;\n\ntemplate &lt;typename C&gt;\nconstexpr bool has_begin_v&lt;\n    C, std::void_t&lt;decltype(std::declval&lt;C&gt;().begin())&gt;&gt; = true;\n\n// has_rbegin\ntemplate &lt;typename, typename = void&gt;\nconstexpr bool has_rbegin_v = false;\n\ntemplate &lt;typename C&gt;\nconstexpr bool has_rbegin_v&lt;\n    C, std::void_t&lt;decltype(std::declval&lt;C&gt;().rbegin())&gt;&gt; = true;\n\n// has_end\ntemplate &lt;typename, typename = void&gt;\nconstexpr bool has_end_v = false;\n\ntemplate &lt;typename C&gt;\nconstexpr bool has_end_v&lt;\n    C, std::void_t&lt;decltype(std::declval&lt;C&gt;().end())&gt;&gt; = true;\n\n// has_rend\ntemplate &lt;typename, typename = void&gt;\nconstexpr bool has_rend_v = false;\n\ntemplate &lt;typename C&gt;\nconstexpr bool has_rend_v&lt;\n    C, std::void_t&lt;decltype(std::declval&lt;C&gt;().rend())&gt;&gt; = true;\n\n// has_push_front\ntemplate &lt;typename, typename = void&gt;\nconstexpr bool has_push_front_v = false;\n\ntemplate &lt;typename C&gt;\nconstexpr bool has_push_front_v&lt;\n    C,\n    std::void_t&lt;\n        decltype(\n            std::declval&lt;C&gt;().push_front(\n                std::declval&lt;typename C::value_type&gt;()))&gt;&gt; = true;\n\n// has_push_back\ntemplate &lt;typename, typename = void&gt;\nconstexpr bool has_push_back_v = false;\n\ntemplate &lt;typename C&gt;\nconstexpr bool has_push_back_v&lt;\n    C,\n    std::void_t&lt;\n        decltype(\n            std::declval&lt;C&gt;().push_back(\n                std::declval&lt;typename C::value_type&gt;()))&gt;&gt; = true;\n\n// has_insert\ntemplate &lt;typename, typename = void&gt;\nconstexpr bool has_insert_v = false;\n\ntemplate &lt;typename C&gt;\nconstexpr bool has_insert_v&lt;\n    C,\n    std::void_t&lt;\n        decltype(\n            std::declval&lt;C&gt;().insert(\n                std::declval&lt;typename C::const_iterator&gt;(),\n                std::declval&lt;typename C::value_type&gt;()))&gt;&gt; = true;\n\n// is_stack\ntemplate &lt;typename C&gt;\nconstexpr bool is_stack_v =\n    std::is_base_of_v&lt;std::stack&lt;typename C::value_type&gt;, C&gt;;\n\n// is_container_v\ntemplate&lt;typename C&gt;\nconstexpr bool is_container_v =\n    is_stack_v&lt;C&gt; or\n    (has_push_front_v&lt;C&gt; and has_begin_v&lt;C&gt; and has_end_v&lt;C&gt;) or\n    (has_push_back_v&lt;C&gt; and has_rbegin_v&lt;C&gt; and has_rend_v&lt;C&gt;) or\n    (has_insert_v&lt;C&gt; and has_begin_v&lt;C&gt; and has_rbegin_v&lt;C&gt; and has_rend_v&lt;C&gt;);\n\n// c2o (container to output iterator)\ntemplate&lt;typename, typename, typename = void&gt;\nconstexpr bool c2o_v = false;\n\ntemplate&lt;typename O, typename C&gt;\nconstexpr bool c2o_v&lt;\n    O, C,\n    std::void_t&lt;\n        decltype(\n            std::declval&lt;O&gt;() = std::declval&lt;typename C::value_type&gt;())&gt;&gt; = true;\n\n// enable_if\ntemplate &lt;typename I, typename O, typename C = void&gt;\nusing enable_if_ioc = std::enable_if_t&lt;\n    io_iterators_v&lt;I, O&gt; and i2o_v&lt;I, O&gt;\n    and is_container_v&lt;C&gt; and c2o_v&lt;O, C&gt;&gt;;\n\n// solution\ntemplate &lt;\n    typename I, typename O, typename C = std::stack&lt;it_type&lt;I&gt;&gt;,\n    typename = enable_if_ioc&lt;I, O, C&gt;&gt;\nauto\nreverse_function(I first, I last, O out) {\n    auto oerror = std::ostream_iterator&lt;std::string&gt;(std::cerr, \"\\n\");\n\n    if constexpr (is_bidir_v&lt;I&gt;) {\n        // can directly traverse the input backwards, no storage needed\n        *oerror++ = \"[+]: Bidirectional Iterator for the Input\";\n        std::copy(\n            std::make_reverse_iterator(last),\n            std::make_reverse_iterator(first),\n            out);\n    } else {\n        *oerror++ = \"[+]: Non-Bidirectional Iterator for the Input\";\n        auto c = C{}; // container needed to store input and output in reverse\n\n        if constexpr (is_stack_v&lt;C&gt;) {\n            *oerror++ = \"[+]: Using Stack as container\";\n            std::for_each(first, last, [&amp;c](const auto &amp;x) { c.push(x); });\n            while(not c.empty()) {\n                *out = c.top();\n                c.pop();\n            }\n\n        } else if constexpr (has_push_front_v&lt;C&gt;) {\n            *oerror++ = \"[+]: Using push_front from container\";\n            std::copy(first, last, std::front_inserter(c));\n            std::copy(c.begin(), c.end(), out);\n\n        } else if constexpr (has_push_back_v&lt;C&gt;) {\n            *oerror++ = \"[+]: Using push_back from container\";\n            std::copy(first, last, std::back_inserter(c));\n            std::copy(c.rbegin(), c.rend(), out);\n\n        } else if constexpr (has_insert_v&lt;C&gt;) {\n            *oerror++ = \"[+]: Using insert from container\";\n            std::copy(first, last, std::inserter(c, c.begin()));\n            std::copy(c.rbegin(), c.rend(), out);\n        }\n    }\n}\n\n// main\nint\nmain(int, char *[]) {\n    using ptype = int;  // define problem type\n\n    // prepare standard input\n    auto sin = std::istream_iterator&lt;ptype&gt;{std::cin};\n    auto sin_last = std::istream_iterator&lt;ptype&gt;{};\n\n    [[maybe_unused]] auto N = *sin++; // Get initial (and ignore it) input\n\n#ifdef CASE0 // use a bidirectional iterator, no container in the solution\n    // Get things in a vector. // problem iterators are the vector iterators\n    auto v = std::vector&lt;ptype&gt;{};\n    std::copy(sin, sin_last, std::back_inserter(v));\n    auto in = v.begin();\n    auto in_last = v.end();\n#else // default case, direct input from standard input\n    // problem iterators are the standard input iterators\n    auto &amp;in = sin;\n    auto &amp;in_last = sin_last;\n#endif\n\n    using IType = std::decay_t&lt;decltype(in)&gt;;  // iterator type for the templates\n\n    // prepare output and the output iterator type for the templates\n    auto out = std::ostream_iterator&lt;ptype&gt;{std::cout, \" \"};\n    using OType = decltype(out);\n\n#ifdef CASE1 // push_back case\n    using CType = std::vector&lt;ptype&gt;;\n    reverse_function&lt;IType, OType, CType&gt;(in, in_last, out);\n#elif defined CASE2 // push_front case\n    using CType = std::list&lt;ptype&gt;;\n    reverse_function&lt;IType, OType, CType&gt;(in, in_last, out);\n#elif defined CASE3 // another push_front case\n    using CType = std::deque&lt;ptype&gt;;\n    reverse_function&lt;IType, OType, CType&gt;(in, in_last, out);\n#else  // default case ... use a stack\n    reverse_function(in, in_last, out);\n#endif\n    return 0;\n}\n</code></pre> <p>GitHub: 08-arrays-intro/arrays-intro-06.cpp </p>"},{"location":"0090-tortoise-and-hare/","title":"The Tortoise And The Hare","text":"<p>Title: Bit Array Link: https://www.hackerrank.com/challenges/bitset-1/problem </p> <p>The problem description would seem to indicate that one will have to scan an array of <code>N</code> elements and length 10<sup>8</sup>. But considering that the operation that fills the array restricts the integers to be modulo 2<sup>31</sup>, there will be a sequence repeating itself. But if the length of the array is restricted, one may hit the end before the sequence starts repeating.</p> <p>Therefore, finding the number of different integers boils down to detecting a cycle. The \u201cFloyd's Tortoise and Hare\u201d<sup></sup> algorithm is certainly a good choice.</p> <pre><code>#include &lt;iostream&gt; // std::cin, std::cout\n\nint\nmain(int, char *[]) {\n    // problem parameters (const and from input)\n    constexpr int mod = 1 &lt;&lt; 31;\n    int N, S, P, Q;  // variables for input\n    std::cin &gt;&gt; N &gt;&gt; S &gt;&gt; P &gt;&gt; Q;\n    // lambda to calculate next position\n    auto fmove = [P, Q](const auto &amp;x) { return (x * P + Q) % mod; };\n    auto tort = S % mod, hare = tort; // initial positions\n    // solve problem\n    auto n = 0;\n    while(++n &lt; N and ((tort = fmove(tort)) != (hare = fmove(fmove(hare)))));\n    std::cout &lt;&lt; n; // output result and go\n    return 0;\n}\n</code></pre> <p>GitHub: 09-tortoise-and-hare/tortoise-and-hare-01.cpp </p> <p>A single movement for the Tortoise is calculated with the lambda assigned to <code>fmove</code>. The Hare uses <code>fmove</code> twice in each round.</p> <p>Notice that we have to check if the array has been traversed before moving our heroes. Consider the simple case where <code>N = 1</code>. The solution will obviously be <code>1</code>, and there is no cycle to detect, although philosophically, one could say we are facing an eternal cycle.</p>"},{"location":"0090-tortoise-and-hare/#iterating-the-range","title":"Iterating the Range","text":"<p>Looking at the problem we can identify two sets of movements running in parallel, and each of those sets can lead to the solution.</p> <ol> <li> <p>Moving along the range <code>1 =&gt; N</code>, the maximum array length, and checking if <code>N</code> is reached</p> </li> <li> <p>Moving the Tortoise and the Hare and checking if they occupy the same array position before <code>N</code> is reached. In this case the distance traveled between <code>1</code> and <code>N</code> is the solution.</p> </li> </ol> <p>To address the first set of movements we will be using our <code>Range</code> virtual container, the one emulating Python's <code>range</code> that we developed for the \u201cFor Loop\u201d problem.</p> <p>The second one has been addressed with our lambda. However, the check in the <code>if</code> expression to see if the cycle has been detected will look smarter and more elegant by abusing the lambda expressions and packing the check in a single function.</p> <p>Given that we have find a cycle, or the lack of it, the standard <code>std::find_if</code> seems perfectly suited for the task. If the cycle is found, with the unary predicate we feed it with, we will know at which position. Else it will run until the length of the array is reached. This will also come as a natural result of using <code>std::find_if</code>, because the returned iterator will be at position <code>N</code>, right after the end of the array, that is a half-open interval <code>[1, N)</code>. Here are the lambda expressions.</p> <pre><code>    // Initialize the tortoise &amp; hare positions, and prepare calculating lambdas\n    auto tort = S % mod, hare = tort;\n    auto fmove = [P, Q](const auto &amp;x) { return (x * P + Q) % mod; };\n    auto ftort = [&amp;fmove, &amp;tort]() { return tort = fmove(tort); };\n    auto fhare = [&amp;fmove, &amp;hare]() { return hare = fmove(fmove(hare)); };\n    auto ftoha = [&amp;ftort, &amp;fhare](const auto &amp;) { return ftort() == fhare(); };\n\n    auto range = Range{1, N}; // Prepare a lazy evaluation Range from 1 to N\n    tortoise_and_hare(range.begin(), range.end(), out, ftoha); // solve\n</code></pre> <p>GitHub: 09-tortoise-and-hare/tortoise-and-hare-02.cpp:81:89 </p> <p>Notice how our <code>ftoha</code> cycle-detecting lambda defines a <code>const auto &amp;</code> argument for which we provide no name, as we simply ignore it. It is the position in the array. Position that is only relevant for the answer and not for the cycle detection.</p> <p>We have, of course, also resorted to input/output iterators to fetch the input parameters and to create a custom STL-like solution function. This can already take a function returning <code>bool</code> and taking a parameter matching the type of what dereferencing the iterator would give us.</p> <pre><code>template &lt;typename T&gt;\nusing it_type = typename std::iterator_traits&lt;T&gt;::value_type;\n\ntemplate &lt;typename T&gt;\nusing Predicate = std::function&lt;bool(const it_type&lt;T&gt; &amp;)&gt;;\n\ntemplate &lt;typename I, typename O&gt;\nauto\ntortoise_and_hare(I first, I last, O out, const Predicate&lt;I&gt; &amp;pred) {\n    // Find cycle (hare meets tortoise) along the range 1=&gt;N or end of range\n    *out++ = *std::find_if(first, last, pred);\n}\n</code></pre> <p>GitHub: 09-tortoise-and-hare/tortoise-and-hare-02.cpp:60:71 </p> <p>SFINAE here would help us with a check using <code>std::enable_if</code> that returns <code>Predicate&lt;I&gt;</code>, to give us the same type that we have manually defined, but after having checked the iterators. We will tackle that on our next iteration to solve the problem.</p> <p>Here is this entire solution.</p> <pre><code>#include &lt;algorithm&gt; // std::find_if\n#include &lt;functional&gt; // std::function\n#include &lt;iostream&gt; // std::cin, std::cout\n#include &lt;iterator&gt; // std::istream_iterator/ostream_iterator\n#include &lt;limits&gt; // std::numeric_limits\n#include &lt;type_traits&gt; // std::enable_if, std::is_integral, std::void_t\n\ntemplate &lt;typename T&gt;\nusing enable_if_integral = std::enable_if_t&lt;std::is_integral_v&lt;T&gt;&gt;;\n\ntemplate &lt;typename T = int, typename = enable_if_integral&lt;T&gt;&gt;\nclass Range {\n    struct StartStopStep {\n        const T start = 0;\n        const T stop = std::numeric_limits&lt;T&gt;::max();\n        const T step = 1;\n    } m_sss;\n\npublic:\n    Range(const StartStopStep&amp; sss) : m_sss{sss} {};\n    Range(const T stop) : m_sss{.stop=stop} {};\n    Range(const T start, const T stop, const T step = 1)\n        : m_sss{.start=start, .stop=stop, .step=step} {};\n\nprivate:\n    struct Iter {\n    private:\n        StartStopStep m_sss;\n        T m_pos;\n\n    public:\n        // Iterator tags\n        using iterator_category = std::forward_iterator_tag;\n        using difference_type   = std::ptrdiff_t;\n        using value_type        = T;\n        using reference         = value_type; // usually value_type &amp;\n        using pointer           = value_type; // usually value_type *\n\n        Iter(const StartStopStep &amp;sss) : m_sss{sss}, m_pos{m_sss.start} {};\n        Iter(const T &amp;pos) : m_sss{.stop=pos}, m_pos{pos}  {}; // end-of-range\n\n        auto operator *() const { return m_pos; }\n        auto operator -&gt;() const { return &amp;m_pos; }\n        auto&amp; operator ++() { // Prefix increment - increase until stop\n            m_pos = std::min(m_pos + m_sss.step, m_sss.stop);\n            return *this;\n        }\n        // Postfix increment\n        auto operator ++(int) { Iter tmp = *this; ++(*this); return tmp; }\n\n        auto operator ==(const Iter&amp; o) const { return m_pos == o.m_pos; }\n        auto operator !=(const Iter&amp; o) const { return m_pos != o.m_pos; }\n    };\n\npublic:\n    auto begin() const { return Iter{m_sss}; } // copy range, pos at start\n    auto end() const { return Iter{m_sss.stop}; } // place directly at end\n};\n\ntemplate &lt;typename T&gt;\nusing it_type = typename std::iterator_traits&lt;T&gt;::value_type;\n\ntemplate &lt;typename T&gt;\nusing Predicate = std::function&lt;bool(const it_type&lt;T&gt; &amp;)&gt;;\n\ntemplate &lt;typename I, typename O&gt;\nauto\ntortoise_and_hare(I first, I last, O out, const Predicate&lt;I&gt; &amp;pred) {\n    // Find cycle (hare meets tortoise) along the range 1=&gt;N or end of range\n    *out++ = *std::find_if(first, last, pred);\n}\n\nint\nmain(int, char *[]) {\n    // Prepare iterators for input and output\n    auto in = std::istream_iterator&lt;int&gt;{std::cin};\n    auto out = std::ostream_iterator&lt;int&gt;{std::cout};\n    // problem parameters (const and from input)\n    constexpr int mod = 1 &lt;&lt; 31;\n    auto N = *in++, S = *in++, P = *in++, Q = *in++;\n    // Initialize the tortoise &amp; hare positions, and prepare calculating lambdas\n    auto tort = S % mod, hare = tort;\n    auto fmove = [P, Q](const auto &amp;x) { return (x * P + Q) % mod; };\n    auto ftort = [&amp;fmove, &amp;tort]() { return tort = fmove(tort); };\n    auto fhare = [&amp;fmove, &amp;hare]() { return hare = fmove(fmove(hare)); };\n    auto ftoha = [&amp;ftort, &amp;fhare](const auto &amp;) { return ftort() == fhare(); };\n\n    auto range = Range{1, N}; // Prepare a lazy evaluation Range from 1 to N\n    tortoise_and_hare(range.begin(), range.end(), out, ftoha); // solve\n    return 0;\n}\n</code></pre> <p>GitHub: 09-tortoise-and-hare/tortoise-and-hare-02.cpp </p>"},{"location":"0090-tortoise-and-hare/#real-iterators","title":"Real Iterators","text":"<p>We have not really used proper iterators in the previous solution and this is something we can address by defining our custom iterators.</p> <p>Recall that <code>std::istream_iterator&lt;T&gt;(std::istream &amp;)</code> has a counterpart to mark the end of the iteration. This can be invoked as: <code>std::istream_iterator&lt;T&gt;()</code>. We are going to implement that concept with an iterator named: <code>CycleIterator</code>. As the name seems to indicate it will be in charge of finding if there is a cycle or get to the end of the defined range.</p> <p>Since we want to \u201cfind\u201d a cycle, using <code>std::find_if</code> seems semantically the best STL verb to use from the available algorithms. Recall that <code>std::find_if</code> needs a [bool-returning][2-star-bool]{target=_blank} predicate to indicate, in our case, that the cycle has been found and we get the dereferenced value of the current iterator position. The cycle detection cannot be done merely by looking at the current position, but that is, for example, what we have to obtain by dereferencing the iterator if the end of the range is hit.</p> <p>Houston, we need a dereferenced value that holds two values simultaneously. Nothing that cannot be solved with an <code>std::pair&lt;T, T2&gt;</code>. But let us be brave and use instead the more general <code>std::tuple</code> with just two types. We already used <code>std::pair</code> when using an <code>std::map</code> and now we will be able to use <code>std::get&lt;N&gt;(x)</code> to get the needed values.</p> <pre><code>template &lt;typename T = int&gt;\nstruct CycleIterator {\n    using CycleVal = std::tuple&lt;bool, T&gt;;\n\n    // Iterator tags\n    using iterator_category = std::forward_iterator_tag;\n    using difference_type   = std::ptrdiff_t;\n    using value_type        = CycleVal;\n    using reference         = value_type &amp;;\n    using pointer           = value_type *;\n</code></pre> <p>GitHub: 09-tortoise-and-hare/tortoise-and-hare-03.cpp:8:17 </p> <p>There is the definition of our tuple and how this is the value used in the iterator.</p> <p>We will also need to hold the current position in the range, the positions of the tortoise and the hare, and the current combo \u201ccycle detection + position\u201d inside the <code>std::tuple&lt;bool, int&gt;</code>.</p> <pre><code>    T m_pos; // array position\n\n    using FuncMove = std::function&lt;int(const int &amp;)&gt;;\n    const FuncMove m_fmove;\n\n    T m_tort, m_hare; // Positions of tortoise/hare\n    const T m_tsteps = T{1}, m_hsteps = T{2}; // Mover per cycle\n\n    CycleVal m_val; // cycle detected / array pos\n</code></pre> <p>GitHub: 09-tortoise-and-hare/tortoise-and-hare-03.cpp:19:27 </p> <p>Calculations are done in our <code>operator ++()</code>. Notice that we have commented out the <code>-&gt;</code> operator and the postfix increment. They are not really needed.</p> <pre><code>    // auto operator -&gt;() { return &amp;m_val; } // deref to calc\n    auto &amp;operator *() { return m_val; }\n\n    auto &amp;operator ++() { // Prefix increment\n        for (T i{m_tsteps}; i--; m_tort = m_fmove(m_tort));\n        for (T i{m_hsteps}; i--; m_hare = m_fmove(m_hare));\n        m_val = {m_tort == m_hare, ++m_pos};\n        return *this;\n    }\n    // Postfix increment\n    // auto operator ++(int) { CycleIterator tmp = *this; ++(*this); return tmp; }\n</code></pre> <p>GitHub: 09-tortoise-and-hare/tortoise-and-hare-03.cpp:40:50 </p> <p>Notice how we have customized how many times the tortoise and the hare can move. The default values in the constructor are <code>1</code> and <code>2</code>, but nothing prevents us from using other speeds.</p> <p>The constructor is something we need to look into.</p> <pre><code>    CycleIterator(\n        const T &amp;start, // start position of array length\n        const FuncMove &amp;fmove, // function that will move tortoise and hare\n        const T &amp;htstart = T{1},  // starting pos for tort/hare\n        const T &amp;tsteps = T{1},\n        const T &amp;hsteps = T{2} // steps for tort/hare\n    ) : m_pos{start - 1}, m_fmove{fmove},m_tort{htstart}, m_hare{htstart},\n        m_tsteps{tsteps}, m_hsteps{hsteps} { ++(*this); }\n\n    CycleIterator(const T &amp;stop) : m_pos{stop} {}\n</code></pre> <p>GitHub: 09-tortoise-and-hare/tortoise-and-hare-03.cpp:29:38 </p> <p>First, our \u201cend-of-range\u201d constructor at the end of the snippet. It takes the end position of the range, <code>N</code>, and is a no-op for all things.</p> <p>Then our regular constructor that takes the function that moves the tortoise and the hare and allows customizing where to start and how to move. Something important to notice:</p> <ul> <li> <p>The <code>start</code> position is taken with a <code>-1</code></p> </li> <li> <p>The prefix increment <code>++</code> is called during initialization. This will effectively restore <code>start</code> (adding <code>1</code>) and will calculate the initial first-jump positions of our competitors. If the first comparison happens to detect the cycle, the result will be <code>start</code> that we have restored to its original value.</p> </li> </ul> <p>Our solution function needs some explaining for sure.</p> <pre><code>template &lt;typename I, typename O&gt;\nauto\ntortoise_and_hare(I first, I last, O out) {\n    // Find if there is cycle (hare meets tortoise) along the range 1=&gt;N\n    // and output that point or the length of the range is the result\n    auto pred = [](const auto &amp;x) { return std::get&lt;0&gt;(x); };\n    *out++ = std::get&lt;1&gt;(*std::find_if(first, last, pred));\n}\n</code></pre> <p>GitHub: 09-tortoise-and-hare/tortoise-and-hare-03.cpp:56:63 </p> <p>We define a predicate <code>pred</code> that will get and return the first value of whatever has been dereferenced. We know it is a <code>bool</code> in the <code>std::tuple&lt;bool, int&gt;</code>.</p> <p>The final output over <code>out</code> is the second value, the <code>int</code>, be it because a cycle has been detected or because the end of the range has been reached.</p> <p>Unfortunately, we cannot let <code>pred</code> be a parameter, because it needs internal knowledge of the structure holding the cycle detection and the range position.</p> <p>The <code>main</code> function has now been cleaned of all lambda expressions but <code>fmove</code>, that goes into the <code>CycleIterator</code> to push the range of the tortoise and the hare.</p> <p>See the entire code, including the <code>main</code> function below.</p> <pre><code>#include &lt;algorithm&gt; // std::find_if\n#include &lt;functional&gt; // std::function\n#include &lt;iostream&gt; // std::cin, std::cout\n#include &lt;iterator&gt; // std::istream_iterator/ostream_iterator\n#include &lt;tuple&gt; // std::get, std::tuple\n#include &lt;type_traits&gt; // std::iterator_traits\n\ntemplate &lt;typename T = int&gt;\nstruct CycleIterator {\n    using CycleVal = std::tuple&lt;bool, T&gt;;\n\n    // Iterator tags\n    using iterator_category = std::forward_iterator_tag;\n    using difference_type   = std::ptrdiff_t;\n    using value_type        = CycleVal;\n    using reference         = value_type &amp;;\n    using pointer           = value_type *;\n\n    T m_pos; // array position\n\n    using FuncMove = std::function&lt;int(const int &amp;)&gt;;\n    const FuncMove m_fmove;\n\n    T m_tort, m_hare; // Positions of tortoise/hare\n    const T m_tsteps = T{1}, m_hsteps = T{2}; // Mover per cycle\n\n    CycleVal m_val; // cycle detected / array pos\n\n    CycleIterator(\n        const T &amp;start, // start position of array length\n        const FuncMove &amp;fmove, // function that will move tortoise and hare\n        const T &amp;htstart = T{1},  // starting pos for tort/hare\n        const T &amp;tsteps = T{1},\n        const T &amp;hsteps = T{2} // steps for tort/hare\n    ) : m_pos{start - 1}, m_fmove{fmove},m_tort{htstart}, m_hare{htstart},\n        m_tsteps{tsteps}, m_hsteps{hsteps} { ++(*this); }\n\n    CycleIterator(const T &amp;stop) : m_pos{stop} {}\n\n    // auto operator -&gt;() { return &amp;m_val; } // deref to calc\n    auto &amp;operator *() { return m_val; }\n\n    auto &amp;operator ++() { // Prefix increment\n        for (T i{m_tsteps}; i--; m_tort = m_fmove(m_tort));\n        for (T i{m_hsteps}; i--; m_hare = m_fmove(m_hare));\n        m_val = {m_tort == m_hare, ++m_pos};\n        return *this;\n    }\n    // Postfix increment\n    // auto operator ++(int) { CycleIterator tmp = *this; ++(*this); return tmp; }\n\n    auto operator ==(const CycleIterator&amp; o) const { return m_pos == o.m_pos; }\n    auto operator !=(const CycleIterator&amp; o) const { return not (*this == o); }\n};\n\ntemplate &lt;typename I, typename O&gt;\nauto\ntortoise_and_hare(I first, I last, O out) {\n    // Find if there is cycle (hare meets tortoise) along the range 1=&gt;N\n    // and output that point or the length of the range is the result\n    auto pred = [](const auto &amp;x) { return std::get&lt;0&gt;(x); };\n    *out++ = std::get&lt;1&gt;(*std::find_if(first, last, pred));\n}\n\nint\nmain(int, char *[]) {\n    // Prepare iterators for input and output\n    auto in = std::istream_iterator&lt;int&gt;{std::cin};\n    constexpr auto mod = 1 &lt;&lt; 31; // fixed constant\n    // problem parameters (const and from input)\n    auto N = *in++, S = *in++, P = *in++, Q = *in++;\n    // Prepare \"move\" lambda and solve\n    auto fmove = [P, Q](const auto &amp;x) { return (x * P + Q) % mod; };\n    tortoise_and_hare(\n        CycleIterator{1, fmove, S % mod},\n        CycleIterator{N},\n        std::ostream_iterator&lt;int&gt;{std::cout}\n    );\n    return 0;\n}\n</code></pre> <p>GitHub: 09-tortoise-and-hare/tortoise-and-hare-03.cpp </p>"},{"location":"0090-tortoise-and-hare/#real-real-iterators","title":"Real-Real Iterators","text":"<p>There is a fundamental problem in the design shown above because we place <code>N</code>, the end of the range, in the <code>end-of-range</code> iterator. That means that we departed from the <code>std::istream_iterator&lt;T&gt;()</code> design to mark the end of the range. It seemed natural to put that <code>N</code> there as a kind of <code>EOF</code> marker. We will work on changing that.</p> <p>However, the most fundamental flaw is the use of <code>std::tuple&lt;bool, int&gt;</code> as the magical tool to sometimes deliver the indication that the cycle has been detected and where (or if the end of the range has been reached). Although it seems ideal, we were actually forced to use such a construction because we let ourselves be misled by the semantics. In order to \u201cfind\u201d the cycle we deemed <code>std::find_if</code> as the right tool.</p> <p>Breaking out of the search for the cycle can only be done if the iterator itself signals the cycle has been found. It seems therefore redundant that we need a lambda accessing the first value inside our <code>std::tuple&lt;bool, int&gt;</code> and blindly returning it. The cycle has already been detected and the iteration could stop \u201con its own\u201d, i.e., by meeting the requirement of being equal to the <code>last</code> iterator.</p> <p>Going a couple of steps backwards and looking at the original problem definition, what we want is to \u201ccount\u201d the number of different integers before those integers start repeating. Let us therefore switch to using <code>std::count</code>.</p> <pre><code>template &lt;typename I, typename O&gt;\nauto\ntortoise_and_hare(I first, I last, O out) {\n#ifdef CASE1\n    *out++ = std::accumulate(first, last, 0); // +1 til cycle/end\n#else // default solution\n    *out++ = std::count(first, last, true); // count trues til cycle/end\n#endif\n}\n</code></pre> <p>GitHub: 09-tortoise-and-hare/tortoise-and-hare-04.cpp:60:68 </p> <p>We will be counting as long as the iterator returns <code>true</code>. As a bonus we also have another implementation using <code>std::accumulate</code>, that will start with an <code>init</code> value of <code>0</code> and add all the <code>true</code> instances, a value that obviously is converted to <code>1</code>.</p> <p>Correspondingly, our iterator will simply return <code>true</code> every time it is dereferenced. As simple as this.</p> <pre><code>    auto operator *() { return true; }\n</code></pre> <p>GitHub: 09-tortoise-and-hare/tortoise-and-hare-04.cpp:40:40 </p> <p>To do so we remove the <code>std::tuple&lt;bool, int&gt;</code> value holder and add a boolean marker for the end.</p> <pre><code>    T m_pos, m_posmax; // start/current pos / end of range\n\n    using FuncMove = std::function&lt;int(const int &amp;)&gt;;\n    const FuncMove m_fmove;\n\n    T m_tort, m_hare; // Positions of tortoise/hare\n    const T m_tsteps = T{1}, m_hsteps = T{2}; // Mover per cycle\n    bool m_end;\n\n    CycleIterator(\n        const T &amp;start, // steps for hare\n        const T &amp;stop, // steps for hare\n        const FuncMove &amp;fmove, // function that will move tortoise and hare\n        const T &amp;htstart = T{1},  // starting pos for tort/hare\n        const T &amp;tsteps = T{1}, // steps for tort\n        const T &amp;hsteps = T{2} // steps for hare\n    ) : m_pos{start}, m_posmax{stop}, m_fmove{fmove},\n        m_tort{htstart}, m_hare{htstart}, m_tsteps{tsteps}, m_hsteps{hsteps},\n        m_end(m_pos == m_posmax) {}\n\n    CycleIterator() : m_pos{std::numeric_limits&lt;T&gt;::max()}, m_end{true} {}\n</code></pre> <p>GitHub: 09-tortoise-and-hare/tortoise-and-hare-04.cpp:18:38 </p> <p>We have also changed the constructors, with the regular one taking the beginning and end of range and the \u201cend-of-range\u201d taking no parameters. The construction in <code>main</code> therefore changes. To be noted: the regular constructor no longer increments the iterator during initialization. But it is able to detect if the range is of zero length because <code>N</code> is <code>1</code>, i.e., the iteration has to immediately stop.</p> <pre><code>        tortoise_and_hare(\n            CycleIterator{1, N, fmove, S % mod},\n            CycleIterator{},\n            std::ostream_iterator&lt;int&gt;{std::cout}\n        );\n</code></pre> <p>GitHub: 09-tortoise-and-hare/tortoise-and-hare-04.cpp:81:85 </p> <p>Once the iterator detects the cycle it will mark itself as ended, making it \u201cequal\u201d to the \u201cend-of-range\u201d iterator. The detection and marking do happen inside the prefix increment operator.</p> <pre><code>    auto &amp;operator ++() { // Prefix increment\n        if (not m_end) {\n            for (T i{m_tsteps}; i--; m_tort = m_fmove(m_tort));\n            for (T i{m_hsteps}; i--; m_hare = m_fmove(m_hare));\n            m_end = (m_tort == m_hare) or (m_pos++ == m_posmax);\n        }\n        return *this;\n    }\n</code></pre> <p>GitHub: 09-tortoise-and-hare/tortoise-and-hare-04.cpp:43:50 </p> <p>To make sure that the iteration is stopped by the internal loops inside <code>std::count</code>, <code>std::accumulate</code> or a manual loop we could code ourselves, the <code>operator ==</code> has to be also tweaked to use the <code>m_end</code> marker and compare itself to the \u201cend-of-range\u201d iterator.</p> <pre><code>    auto operator ==(const CycleIterator&amp; o) const {\n        return m_end ? o.m_end : (not o.m_end and (m_pos == o.m_pos));\n    }\n</code></pre> <p>GitHub: 09-tortoise-and-hare/tortoise-and-hare-04.cpp:54:56 </p> <p>With all the pieces in place, our approach solves the problem neatly with either <code>std::count</code> or <code>std::accumulate</code> (compile and test with <code>make 04 case1</code> to use the latter).</p> <p>Should you implement your own solution, there are two test cases available. This is so because the sample test provided in the problem description is an end-of-range test case. We also need to verify we do not make it to the end if a cycle is found.</p> <p>Testing with the standard test case requires a simple make.</p> <pre><code>make 04\n</code></pre> <p>To test with the cycle-exists test case add a <code>test1</code> to the make clause.</p> <pre><code>make 04 test1\n</code></pre>"},{"location":"0090-tortoise-and-hare/#summary","title":"Summary","text":"<p>We finally have an iterator-based solution that is also customizable with custom ranges to traverse, start position for the tortoise and hare markers and additionally accepting a custom function to move the markers. Mission accomplished.</p> <p>Note</p> <p>SFINAE has been left out in this occasion to keep things shorter and because we have already done all the tests in previous solutions.</p> <p>The reader may have also noticed that <code>main</code> can now take several problems by reading problem inputs until the end-of-input is reached. This is not part of the problem description but it seemed like a nice final touch.</p> <p>Here is the code for the last, final, and great solution.</p> <pre><code>#include &lt;algorithm&gt; // std::count\n#include &lt;functional&gt; // std::function\n#include &lt;iostream&gt; // std::cin, std::cout\n#include &lt;iterator&gt; // std::istream_iterator/ostream_iterator\n#include &lt;limits&gt; // std::numeric_limits\n#include &lt;numeric&gt; // std::accumulate\n#include &lt;type_traits&gt; // std::enable_if, std::is_integral, std::void_t\n\ntemplate &lt;typename T = int&gt;\nstruct CycleIterator {\n    // Iterator tags\n    using iterator_category = std::forward_iterator_tag;\n    using difference_type   = std::ptrdiff_t;\n    using value_type        = T;\n    using reference         = value_type &amp;;\n    using pointer           = value_type *;\n\n    T m_pos, m_posmax; // start/current pos / end of range\n\n    using FuncMove = std::function&lt;int(const int &amp;)&gt;;\n    const FuncMove m_fmove;\n\n    T m_tort, m_hare; // Positions of tortoise/hare\n    const T m_tsteps = T{1}, m_hsteps = T{2}; // Mover per cycle\n    bool m_end;\n\n    CycleIterator(\n        const T &amp;start, // steps for hare\n        const T &amp;stop, // steps for hare\n        const FuncMove &amp;fmove, // function that will move tortoise and hare\n        const T &amp;htstart = T{1},  // starting pos for tort/hare\n        const T &amp;tsteps = T{1}, // steps for tort\n        const T &amp;hsteps = T{2} // steps for hare\n    ) : m_pos{start}, m_posmax{stop}, m_fmove{fmove},\n        m_tort{htstart}, m_hare{htstart}, m_tsteps{tsteps}, m_hsteps{hsteps},\n        m_end(m_pos == m_posmax) {}\n\n    CycleIterator() : m_pos{std::numeric_limits&lt;T&gt;::max()}, m_end{true} {}\n\n    auto operator *() { return true; }\n    // auto operator -&gt;() { return &amp;m_val; } // deref to calc\n\n    auto &amp;operator ++() { // Prefix increment\n        if (not m_end) {\n            for (T i{m_tsteps}; i--; m_tort = m_fmove(m_tort));\n            for (T i{m_hsteps}; i--; m_hare = m_fmove(m_hare));\n            m_end = (m_tort == m_hare) or (m_pos++ == m_posmax);\n        }\n        return *this;\n    }\n    // Postfix increment\n    // auto operator ++(int) { CycleIterator tmp = *this; ++(*this); return tmp; }\n\n    auto operator ==(const CycleIterator&amp; o) const {\n        return m_end ? o.m_end : (not o.m_end and (m_pos == o.m_pos));\n    }\n    auto operator !=(const CycleIterator&amp; o) const { return not (*this == o); }\n};\n\ntemplate &lt;typename I, typename O&gt;\nauto\ntortoise_and_hare(I first, I last, O out) {\n#ifdef CASE1\n    *out++ = std::accumulate(first, last, 0); // +1 til cycle/end\n#else // default solution\n    *out++ = std::count(first, last, true); // count trues til cycle/end\n#endif\n}\n\nint\nmain(int, char *[]) {\n    // Prepare iterators for input and output\n    auto in = std::istream_iterator&lt;int&gt;{std::cin};\n    auto in_last = std::istream_iterator&lt;int&gt;{};\n    constexpr auto mod = 1 &lt;&lt; 31; // fixed constant\n    while(in != in_last) {\n        // problem parameters (const and from input)\n        auto N = *in++, S = *in++, P = *in++, Q = *in++;\n        // Prepare \"move\" lambda and solve\n        auto fmove = [P, Q](const auto &amp;x) { return (x * P + Q) % mod; };\n        tortoise_and_hare(\n            CycleIterator{1, N, fmove, S % mod},\n            CycleIterator{},\n            std::ostream_iterator&lt;int&gt;{std::cout}\n        );\n    }\n    return 0;\n}\n</code></pre> <p>GitHub: 09-tortoise-and-hare/tortoise-and-hare-04.cpp </p>"},{"location":"0100-variable-sized-arrays/","title":"Variable Sized Arrays","text":"<p>Title: Variable Sized Arrays Link: https://www.hackerrank.com/challenges/variable-sized-arrays/problem </p>"},{"location":"0100-variable-sized-arrays/#direct-solution-with-vectors","title":"Direct Solution with Vectors","text":"<p>We are being challenged to take a number <code>n</code> of arrays and then take <code>q</code> pairs of integers, <code>i</code> and <code>j</code>, that will be used to search first over the list of <code>n</code> arrays with <code>i</code> and then the element <code>j</code> in the referenced array.</p> <p>Let us spare us using dynamically allocated arrays with <code>new[]</code> and then deallocating them with <code>delete[]</code> before ending the program (or having used an <code>std::unique_ptr</code>) and go directly for a manual solution featuring <code>std::vector</code>.</p> <pre><code>#include &lt;iostream&gt; // std::cin, std::cout\n#include &lt;vector&gt; // std::vector\n\nint\nmain(int, char *[]) {\n    // problem parameters (const and from input)\n    int n, q; // number of arrays, number of queries\n    std::cin &gt;&gt; n &gt;&gt; q;\n    // define matrix, create and gather array elements\n    auto vmatrix = std::vector&lt;std::vector&lt;int&gt;&gt;{};\n    for(int k; n--;) {\n        std::cin &gt;&gt; k;\n        auto &amp;vec = *vmatrix.emplace(vmatrix.end());\n        for(int ki; k--; vec.push_back(ki))\n            std::cin &gt;&gt; ki;\n    }\n    // run the queries\n    for(int i, j; q--;std::cout &lt;&lt; vmatrix[i][j] &lt;&lt; std::endl)\n        std::cin &gt;&gt; i &gt;&gt; j;\n    return 0;\n}\n</code></pre> <p>GitHub: 10-variable-sized-arrays/variable-sized-arrays-01.cpp </p> <p>As we already know we need a lot of <code>std::cin &gt;&gt; varname</code> boilerplate after having defined the variables. The only novelty here is that we use <code>std::vector::emplace</code>, to let the inner vectors be constructed for us.</p> <pre><code>        for(int ki; k--; vec.push_back(ki))\n</code></pre> <p>GitHub: 10-variable-sized-arrays/variable-sized-arrays-01.cpp:14:14 </p> <p>Since we get an iterator to where the new <code>std::vector&lt;int&gt;</code> has been positioned, we keep a reference and using <code>std::vector::push_back</code> is straightforward.</p> <p>To get the code in as few lines as possible, we use the \u201cdirty\u201d trick of defining the input variables in the <code>for</code> loop and then performing the storage or output operations in the final statement of the loop.</p>"},{"location":"0100-variable-sized-arrays/#iterator-based-solution","title":"Iterator-Based Solution","text":"<p>Converting to an iterator based solution is easy. Even better, the \u201creal\u201d solution takes less lines if we take into account the two extra <code>#include</code> files we need. We do, of course, apply the same \u201cdirty\u201d <code>for</code> trick to save some lines.</p> <pre><code>    for(; n--; in++) { // resync \"in\" iterator after copy action\n</code></pre> <p>GitHub: 10-variable-sized-arrays/variable-sized-arrays-02.cpp:14:14 </p> <p>Because the vector is being created for us, we can use the reference we keep to <code>std::copy_n</code> the <code>n</code> elements for each instance with <code>std::back_inserter</code>. We already used in a previous challenge in which we also worked with arrays. Let us remark the fact, that by using it we are in fact also using an iterator. It is created in the background for us and takes advantage of the <code>std::vector::push_back</code> method.</p>"},{"location":"0100-variable-sized-arrays/#prototyping-a-container","title":"Prototyping A Container","text":"<p>Given that we have a container, <code>std::vector</code>, holding another container, also an <code>std::vector</code>, it seems like natural that we try to prototype a container to do the work.</p> <p>To save us some work later during the refinement phase, let us already add some SFINAE checks. To do so we are going to resort to one of the oldest technologies in <code>C++</code> (coming from the <code>C</code> times), the preprocessor. Yes, that macro machinery that evoke the 80s.</p> <pre><code>// Macro for trait definitions\n#define DEFINE_HAS_METHOD(method) \\\ntemplate&lt;typename, typename = void&gt; \\\nconstexpr bool has_##method##_v = false; \\\ntemplate&lt;typename T&gt; \\\nconstexpr bool has_##method##_v&lt;T,\\\n    std::void_t&lt;decltype(std::declval&lt;T&gt;().method())&gt;&gt; = true;\n\n// Macro for trait definitions where a value_type arg is expected\n#define DEFINE_HAS_METHOD_ARG(method) \\\ntemplate&lt;typename, typename = void&gt; \\\nconstexpr bool has_##method##_v = false; \\\ntemplate&lt;typename T&gt; \\\nconstexpr bool has_##method##_v&lt;T, \\\n    std::void_t&lt;decltype(std::declval&lt;T&gt;().method(\\\n        std::declval&lt;typename T::value_type&gt;()))&gt;&gt; = true;\n\nDEFINE_HAS_METHOD(begin)\nDEFINE_HAS_METHOD(end)\nDEFINE_HAS_METHOD(rbegin)\nDEFINE_HAS_METHOD(rend)\nDEFINE_HAS_METHOD_ARG(push_back)\nDEFINE_HAS_METHOD_ARG(push_front)\n</code></pre> <p>GitHub: 10-variable-sized-arrays/variable-sized-arrays-03.cpp:8:30 </p> <p>Looking at that code the reason is obvious: \u201cDRY\u201d (Don't Repeat Yourself). With the <code>DEFINE_HAS_METHOD</code> and <code>DEFINE_HAS_METHOD_ARG</code> we avoid almost endlessly repeating the same boilerplate to look for methods in classes. Although not shown above, we also have a <code>has_insert_v</code> checker. This one looks for a method with two arguments and the macro would have taken exactly the same place as the only use we make of it.</p> <p>All those will be combined in a two extra checks to see if the template parameters for our container prototype are supported.</p> <pre><code>// is_container_v\ntemplate&lt;typename C&gt;\nconstexpr bool is_container_v =\n    (has_push_back_v&lt;C&gt; and has_begin_v&lt;C&gt; and has_end_v&lt;C&gt;) or\n    (has_push_front_v&lt;C&gt; and has_rbegin_v&lt;C&gt; and has_rend_v&lt;C&gt;) or\n    (has_insert_v&lt;C&gt; and has_begin_v&lt;C&gt; and has_end_v&lt;C&gt;);\n\n// enable_if\ntemplate &lt;typename ContOut, typename ContIn&gt;\nusing enable_if_containers =\n    std::enable_if_t&lt;is_container_v&lt;ContOut&gt; and is_container_v&lt;ContIn&gt;&gt;;\n\n// solution class\ntemplate &lt;\n    template &lt;typename&gt; class ContOut = std::vector,\n    template &lt;typename&gt; class ContIn = std::vector,\n    typename T = int,\n    typename = enable_if_containers&lt;ContOut&lt;ContIn&lt;T&gt;&gt;, ContIn&lt;T&gt;&gt;\n    &gt;\nclass VariableSizedArrays {\n    using Inner = ContIn&lt;T&gt;; // inner array\n    using Outer = ContOut&lt;Inner&gt;; // outer array\n</code></pre> <p>GitHub: 10-variable-sized-arrays/variable-sized-arrays-03.cpp:45:66 </p> <p><code>VariableSizedArrays</code> will also use the checks in combination with <code>if constexpr</code> to select the appropriate methods at compile time, to support our solution. For example, a <code>get_inserter</code> method will choose if <code>std::back_inserter</code> is the one to use or <code>std::front_inserter</code> is the one to go for.</p> <pre><code>    template &lt;typename C&gt;\n    auto get_inserter(C &amp;c) const {\n        // constexpr chooses the right iterator inserter for C\n        if constexpr (has_push_front_v&lt;C&gt;)\n            return std::front_inserter(c);\n        else if constexpr (has_push_back_v&lt;C&gt;)\n            return std::back_inserter(c);\n        else if constexpr (has_insert_v&lt;C&gt;)\n            return std::inserter(c, c.end());\n        // Unreachable SFINAE has checked before\n    }\n</code></pre> <p>GitHub: 10-variable-sized-arrays/variable-sized-arrays-03.cpp:80:90 </p> <p>This method works for the selection of the outer array and the inner arrays, the ones holding the values. And because we have used different methods for the insertion and that means a different positioning, we also need to use <code>if constexpr</code> to select the method taking us to a given position, the query, in the outer and inner arrays.</p> <pre><code>    template&lt;typename C&gt;\n    auto get_iterator(const C &amp;c, size_t s) const {\n        // constexpr chooses the right iterator to start with\n        if constexpr (has_push_front_v&lt;C&gt;)\n            return std::next(c.rbegin(), s);\n        else if constexpr (has_push_back_v&lt;C&gt; or has_insert_v&lt;C&gt;)\n            return std::next(c.begin(), s);\n        // Unreachable SFINAE has checked before\n    }\n</code></pre> <p>GitHub: 10-variable-sized-arrays/variable-sized-arrays-03.cpp:70:78 </p> <p>Both methods are used to implement the <code>read_array</code> and <code>query</code> methods, the ones doing the work for the outside world, i.e., for <code>main</code>.</p> <pre><code>    template &lt;typename I&gt;\n    auto read_array(I &amp;in, size_t n) {\n        // read n values of type \"S\" from \"in\" to a container Inner\n        // add the container to our outer container\n        auto inner = Inner{};\n        std::copy_n(in, n, get_inserter(inner));\n        *get_inserter(m_c)++ = inner;\n    }\n\n    auto query(size_t j, size_t i) const {\n        return *get_iterator(*get_iterator(m_c, i), j);\n    }\n</code></pre> <p>GitHub: 10-variable-sized-arrays/variable-sized-arrays-03.cpp:93:104 </p> <p>The final solution offers a <code>CASE1</code> option (build and test with <code>make 03 case1</code>) that uses <code>std::deque</code> for both the inner and outer arrays, selecting <code>std::deque::push_front</code> and <code>std::front_inserter</code> for the implementation of the private methods supporting the external interface.</p> <pre><code>#include &lt;algorithm&gt; // std::cin, std::cout\n#include &lt;deque&gt; // std::deque\n#include &lt;iostream&gt; // std::cin, std::cout\n#include &lt;iterator&gt; // std::istream, std::ostream_iterator, std::inserter\n#include &lt;vector&gt; // std::vector\n#include &lt;type_traits&gt; // std::void_t, std::enable_if ...\n\n// Macro for trait definitions\n#define DEFINE_HAS_METHOD(method) \\\ntemplate&lt;typename, typename = void&gt; \\\nconstexpr bool has_##method##_v = false; \\\ntemplate&lt;typename T&gt; \\\nconstexpr bool has_##method##_v&lt;T,\\\n    std::void_t&lt;decltype(std::declval&lt;T&gt;().method())&gt;&gt; = true;\n\n// Macro for trait definitions where a value_type arg is expected\n#define DEFINE_HAS_METHOD_ARG(method) \\\ntemplate&lt;typename, typename = void&gt; \\\nconstexpr bool has_##method##_v = false; \\\ntemplate&lt;typename T&gt; \\\nconstexpr bool has_##method##_v&lt;T, \\\n    std::void_t&lt;decltype(std::declval&lt;T&gt;().method(\\\n        std::declval&lt;typename T::value_type&gt;()))&gt;&gt; = true;\n\nDEFINE_HAS_METHOD(begin)\nDEFINE_HAS_METHOD(end)\nDEFINE_HAS_METHOD(rbegin)\nDEFINE_HAS_METHOD(rend)\nDEFINE_HAS_METHOD_ARG(push_back)\nDEFINE_HAS_METHOD_ARG(push_front)\n\n// has_insert\ntemplate &lt;typename, typename = void&gt;\nconstexpr bool has_insert_v = false;\n\ntemplate &lt;typename C&gt;\nconstexpr bool has_insert_v&lt;\n    C,\n    std::void_t&lt;\n        decltype(\n            std::declval&lt;C&gt;().insert(\n                std::declval&lt;typename C::const_iterator&gt;(),\n                std::declval&lt;typename C::value_type&gt;()))&gt;&gt; = true;\n\n// is_container_v\ntemplate&lt;typename C&gt;\nconstexpr bool is_container_v =\n    (has_push_back_v&lt;C&gt; and has_begin_v&lt;C&gt; and has_end_v&lt;C&gt;) or\n    (has_push_front_v&lt;C&gt; and has_rbegin_v&lt;C&gt; and has_rend_v&lt;C&gt;) or\n    (has_insert_v&lt;C&gt; and has_begin_v&lt;C&gt; and has_end_v&lt;C&gt;);\n\n// enable_if\ntemplate &lt;typename ContOut, typename ContIn&gt;\nusing enable_if_containers =\n    std::enable_if_t&lt;is_container_v&lt;ContOut&gt; and is_container_v&lt;ContIn&gt;&gt;;\n\n// solution class\ntemplate &lt;\n    template &lt;typename&gt; class ContOut = std::vector,\n    template &lt;typename&gt; class ContIn = std::vector,\n    typename T = int,\n    typename = enable_if_containers&lt;ContOut&lt;ContIn&lt;T&gt;&gt;, ContIn&lt;T&gt;&gt;\n    &gt;\nclass VariableSizedArrays {\n    using Inner = ContIn&lt;T&gt;; // inner array\n    using Outer = ContOut&lt;Inner&gt;; // outer array\n\n    Outer m_c; // outer container, keeps the other arrays in pace\n\n    template&lt;typename C&gt;\n    auto get_iterator(const C &amp;c, size_t s) const {\n        // constexpr chooses the right iterator to start with\n        if constexpr (has_push_front_v&lt;C&gt;)\n            return std::next(c.rbegin(), s);\n        else if constexpr (has_push_back_v&lt;C&gt; or has_insert_v&lt;C&gt;)\n            return std::next(c.begin(), s);\n        // Unreachable SFINAE has checked before\n    }\n\n    template &lt;typename C&gt;\n    auto get_inserter(C &amp;c) const {\n        // constexpr chooses the right iterator inserter for C\n        if constexpr (has_push_front_v&lt;C&gt;)\n            return std::front_inserter(c);\n        else if constexpr (has_push_back_v&lt;C&gt;)\n            return std::back_inserter(c);\n        else if constexpr (has_insert_v&lt;C&gt;)\n            return std::inserter(c, c.end());\n        // Unreachable SFINAE has checked before\n    }\n\npublic:\n    template &lt;typename I&gt;\n    auto read_array(I &amp;in, size_t n) {\n        // read n values of type \"S\" from \"in\" to a container Inner\n        // add the container to our outer container\n        auto inner = Inner{};\n        std::copy_n(in, n, get_inserter(inner));\n        *get_inserter(m_c)++ = inner;\n    }\n\n    auto query(size_t j, size_t i) const {\n        return *get_iterator(*get_iterator(m_c, i), j);\n    }\n};\n\n// main solution\nint\nmain(int, char *[]) {\n    // prepare iterators for input/output\n    auto in = std::istream_iterator&lt;int&gt;{std::cin};\n    auto out = std::ostream_iterator&lt;int&gt;{std::cout, \"\\n\"};\n    // problem parameters (const and from input)\n    auto n = *in++, q = *in++; // number of arrays, number of queries\n    // define matrix, create and gather array elements\n#ifdef CASE1\n    auto vsa = VariableSizedArrays&lt;std::deque, std::deque&gt;{};\n#else\n    auto vsa = VariableSizedArrays{};\n#endif\n    for(; n--; in++) // resync \"in\" iterator after copy action\n        vsa.read_array(in, *in++); // *in++ = k, number of elements\n    // run the queries\n    while(q--)\n        *out++ = vsa.query(*in++, *in++);\n\n    return 0;\n}\n</code></pre> <p>GitHub: 10-variable-sized-arrays/variable-sized-arrays-03.cpp </p>"},{"location":"0100-variable-sized-arrays/#an-almost-real-container","title":"An (almost) real container","text":"<p>The container prototype we crafted above does the job, but it feels awkward. It has no <code>begin</code>, no <code>end</code> and no <code>push_xxx</code> methods and that means we have to resort to handmade <code>read_array</code> and <code>query</code> methods.</p> <p>Let us therefore implement those container methods to have an (almost) real container. <code>begin</code> and <code>end</code> will have to return an iterator and that means we have to also code one inside the container class.</p> <p>And Houston ... we have a problem. Iterators are supposed to work linearly and the distance from one point to another must be linear because it has to be integer-like. It is in the standard. Nevertheless, we can work around the \u201climitations\u201d by tagging our iterator as n RandomAccessIterator.</p> <p>In the case of other iterator types, moving the iterator forward or backwards is done in this fashion. Going forward, for example:</p> <pre><code>   --distance;\n   ++iterator;\n</code></pre> <p>When distance reaches <code>0</code>, the iterator is no longer <code>++</code>ed. The iterator can only operated inside the increment operator without actually knowing what the value of <code>distance</code> is.</p> <p>But for a RandomAccessIterator the movement works like this:</p> <pre><code>   random_it += distance\n</code></pre> <p>The iterator itself has to move using the <code>distance</code>. That is exactly what we are going to \u201cabuse\u201d by creating a 2-D distance, that will always take us from the beginning of the container to the position the query wants resolved.</p> <p>Here is our Distance/Position implementation</p> <pre><code>    struct ReIterator {\n        using pos_t = std::pair&lt;int, int&gt;;\n\n        template &lt;typename Pair&gt;\n        struct PosT {\n            typename Pair::first_type first;\n            typename Pair::second_type second;\n\n            PosT(const Pair&amp; pos) : first{pos.first}, second{pos.second} {};\n\n            template &lt;typename P&gt;\n            auto operator ==(const P &amp;) const { return false; }\n            auto operator ==(const Pair &amp;p) const {\n                return p.first == first and p.second == second;\n            }\n        };\n        using Pos = PosT&lt;pos_t&gt;;\n</code></pre> <p>GitHub: 10-variable-sized-arrays/variable-sized-arrays-04.cpp:66:82 </p> <p>Ideally we would have used an <code>std::pair&lt;int, int&gt;</code> directly, but reality killed the cat. The library implementation used by GCC relies on the fact that the distance for iterators has to be integer-like and makes a comparison with <code>1</code> and <code>-1</code>. Hence the need to wrap our <code>std:pair&lt;int, int&gt;</code> to provide the proper comparison operator and avoid chaos during compilation.</p> <p>That distance definition will be used in the <code>operator +=</code> to move to the desired position. The implementation does not consider the current position: it does simply take the given position as the new point the iterator has moved to. That position will later be used when the iterator is dereferenced with the operator <code>*</code>.</p> <pre><code>        auto &amp;operator +=(const Pos &amp;pos) {\n            m_pos = pos;\n            return *this;\n        }\n\n        constexpr auto operator *() const {\n            using InnerT = typename std::iterator_traits&lt;I&gt;::value_type;\n            auto inner = *std::next(m_it, m_pos.first);\n            // constexpr chooses the right iterator to start with\n            if constexpr (has_push_front_v&lt;InnerT&gt;)\n                return *std::next(inner.rbegin(), m_pos.second);\n            else if constexpr (has_push_back_v&lt;InnerT&gt; or has_insert_v&lt;InnerT&gt;)\n                return *std::next(inner.begin(), m_pos.second);\n            // Unreachable SFINAE has checked before\n        }\n</code></pre> <p>GitHub: 10-variable-sized-arrays/variable-sized-arrays-04.cpp:99:113 </p> <p>As it can be seen, the dereferencing uses a real iterator passed during construction, <code>m_it</code> to find first the inner container and then move into the final position within it.</p> <p>Our container chooses if the iterator from which the position is calculated, will be <code>begin</code> or <code>rbegin</code> from the outer array container.</p> <pre><code>    constexpr auto get_begin_end(bool begin) const {\n        // constexpr chooses the right iterator to start with\n        if constexpr (has_push_front_v&lt;Outer&gt;)\n            return begin ? ReIterator(m_c.rbegin()) : ReIterator(m_c.rend());\n        else if constexpr (has_push_back_v&lt;Outer&gt; or has_insert_v&lt;Outer&gt;)\n            return begin ? ReIterator(m_c.begin()) : ReIterator(m_c.end());\n        // Unreachable SFINAE has checked before\n    }\n\npublic:\n    using value_type = T; // needed to support std::back_inserter\n\n    auto begin() const { return get_begin_end(true); }\n    auto end() const { return get_begin_end(false); }\n</code></pre> <p>GitHub: 10-variable-sized-arrays/variable-sized-arrays-04.cpp:135:148 </p> <p>To complete the container, we reuse the previous <code>get_inserter</code> to implement the <code>push_back</code> method.</p> <pre><code>    constexpr auto push_back(const T &amp;t) {\n        if constexpr (has_push_front_v&lt;Outer&gt;)\n            return *get_inserter(*(--m_c.rend())) = t;\n        else if constexpr (has_push_back_v&lt;Outer&gt; or has_insert_v&lt;Outer&gt;)\n            return *get_inserter(*(--m_c.end())) = t;\n        // Unreachable SFINAE has checked before\n    }\n</code></pre> <p>GitHub: 10-variable-sized-arrays/variable-sized-arrays-04.cpp:155:161 </p> <p>With the container in place, we can now use the standard library tools to store the input arrays and to execute the queries. Creating an array with the standard template parameters is now a matter of directly applying <code>std::copy_n</code>.</p> <pre><code>#else\n    auto vsa = VariableSizedArrays{};\n#endif\n    for(; n--; in++) // resync \"in\" iterator after copy action\n        std::copy_n(in, *in++, std::back_inserter(++vsa)); // *in++ = k\n</code></pre> <p>GitHub: 10-variable-sized-arrays/variable-sized-arrays-04.cpp:173:177 </p> <p>And executing the query a matter of moving the <code>begin</code> iterator with a 2-D distance, i.e., a pair of integers to the required destination and dereferencing the resulting iterator.</p> <pre><code>    auto &amp;&amp;vsa = variable_sized_arrays(in, n); // get matrix\n    while(in != in_last) // run queries until input is exhausted\n        *out++ = *std::next(vsa.begin(), {{*in++, *in++}}); // *in++ =&gt; i, j\n</code></pre> <p>GitHub: 10-variable-sized-arrays/variable-sized-arrays-04.cpp:191:193 </p>"},{"location":"0100-variable-sized-arrays/#summary","title":"Summary","text":"<p>As in previous examples we have iterated from a straightforward solution to an iterator based solution and we have moved a step further by implementing a container that does the iteration for us. The container uses a 2-D distance to reach the destination desired by the query. We have even removed the limitation on the number of queries by testing for the end of input before we stop reading values.</p> <p>Here is the complete code.</p> <pre><code>#include &lt;algorithm&gt; // std::cin, std::cout\n#include &lt;deque&gt; // std::deque\n#include &lt;iostream&gt; // std::cin, std::cout\n#include &lt;iterator&gt; // std::istream, std::ostream_iterator, std::inserter\n#include &lt;vector&gt; // std::vector\n#include &lt;type_traits&gt; // std::void_t, std::enable_if ...\n\n// Macro for trait definitions\n#define DEFINE_HAS_METHOD(method) \\\ntemplate&lt;typename, typename = void&gt; \\\nconstexpr bool has_##method##_v = false; \\\ntemplate&lt;typename T&gt; \\\nconstexpr bool has_##method##_v&lt;T,\\\n    std::void_t&lt;decltype(std::declval&lt;T&gt;().method())&gt;&gt; = true;\n\n// Macro for trait definitions where a value_type arg is expected\n#define DEFINE_HAS_METHOD_ARG(method) \\\ntemplate&lt;typename, typename = void&gt; \\\nconstexpr bool has_##method##_v = false; \\\ntemplate&lt;typename T&gt; \\\nconstexpr bool has_##method##_v&lt;T, \\\n    std::void_t&lt;decltype(std::declval&lt;T&gt;().method(\\\n        std::declval&lt;typename T::value_type&gt;()))&gt;&gt; = true;\n\nDEFINE_HAS_METHOD(begin)\nDEFINE_HAS_METHOD(end)\nDEFINE_HAS_METHOD(rbegin)\nDEFINE_HAS_METHOD(rend)\nDEFINE_HAS_METHOD_ARG(push_back)\nDEFINE_HAS_METHOD_ARG(push_front)\n\n// has_insert\ntemplate &lt;typename, typename = void&gt;\nconstexpr bool has_insert_v = false;\n\ntemplate &lt;typename C&gt;\nconstexpr bool has_insert_v&lt;\n    C,\n    std::void_t&lt;\n        decltype(\n            std::declval&lt;C&gt;().insert(\n                std::declval&lt;typename C::const_iterator&gt;(),\n                std::declval&lt;typename C::value_type&gt;()))&gt;&gt; = true;\n\n// is_container_v\ntemplate&lt;typename C&gt;\nconstexpr bool is_container_v =\n    (has_push_back_v&lt;C&gt; and has_begin_v&lt;C&gt; and has_end_v&lt;C&gt;) or\n    (has_push_front_v&lt;C&gt; and has_rbegin_v&lt;C&gt; and has_rend_v&lt;C&gt;) or\n    (has_insert_v&lt;C&gt; and has_begin_v&lt;C&gt; and has_end_v&lt;C&gt;);\n\n// enable_if\ntemplate &lt;typename ContOut, typename ContIn&gt;\nusing enable_if_containers =\n    std::enable_if_t&lt;is_container_v&lt;ContOut&gt; and is_container_v&lt;ContIn&gt;&gt;;\n\n// solution class\ntemplate &lt;\n    template &lt;typename&gt; class ContOut = std::vector,\n    template &lt;typename&gt; class ContIn = std::vector,\n    typename T = int,\n    typename = enable_if_containers&lt;ContOut&lt;ContIn&lt;T&gt;&gt;, ContIn&lt;T&gt;&gt;\n    &gt;\nclass VariableSizedArrays {\n    template &lt;typename I&gt;\n    struct ReIterator {\n        using pos_t = std::pair&lt;int, int&gt;;\n\n        template &lt;typename Pair&gt;\n        struct PosT {\n            typename Pair::first_type first;\n            typename Pair::second_type second;\n\n            PosT(const Pair&amp; pos) : first{pos.first}, second{pos.second} {};\n\n            template &lt;typename P&gt;\n            auto operator ==(const P &amp;) const { return false; }\n            auto operator ==(const Pair &amp;p) const {\n                return p.first == first and p.second == second;\n            }\n        };\n        using Pos = PosT&lt;pos_t&gt;;\n\n        // Iterator tags\n        using iterator_category = std::random_access_iterator_tag;\n        using difference_type   = Pos;\n        using value_type        = T;\n        using reference         = value_type &amp;; // usually value_type &amp;\n        using pointer           = value_type *; // usually value_type *\n\n        I m_it;\n        Pos m_pos = pos_t{0, 0};\n\n        ReIterator(I it) : m_it{it} {}\n\n        auto &amp;operator ++() { return *this; } // nop - needed by std::advance\n        auto &amp;operator --() { return *this; } // nop - needed by std::advance\n\n        auto &amp;operator +=(const Pos &amp;pos) {\n            m_pos = pos;\n            return *this;\n        }\n\n        constexpr auto operator *() const {\n            using InnerT = typename std::iterator_traits&lt;I&gt;::value_type;\n            auto inner = *std::next(m_it, m_pos.first);\n            // constexpr chooses the right iterator to start with\n            if constexpr (has_push_front_v&lt;InnerT&gt;)\n                return *std::next(inner.rbegin(), m_pos.second);\n            else if constexpr (has_push_back_v&lt;InnerT&gt; or has_insert_v&lt;InnerT&gt;)\n                return *std::next(inner.begin(), m_pos.second);\n            // Unreachable SFINAE has checked before\n        }\n\n        auto operator ==(const ReIterator&amp; o) const { return m_it == o.m_it; }\n        auto operator !=(const ReIterator&amp; o) const { return m_it != o.m_it; }\n    };\n\n    using Inner = ContIn&lt;T&gt;; // inner array\n    using Outer = ContOut&lt;Inner&gt;; // outer array\n    Outer m_c; // outer container, keeps the other arrays in pace\n\n    template &lt;typename C&gt;\n    auto get_inserter(C &amp;c) const {\n        // constexpr chooses the right iterator inserter for C\n        if constexpr (has_push_front_v&lt;C&gt;)\n            return std::front_inserter(c);\n        else if constexpr (has_push_back_v&lt;C&gt;)\n            return std::back_inserter(c);\n        else if constexpr (has_insert_v&lt;C&gt;)\n            return std::inserter(c, c.end());\n        // Unreachable SFINAE has checked before\n    }\n\n    constexpr auto get_begin_end(bool begin) const {\n        // constexpr chooses the right iterator to start with\n        if constexpr (has_push_front_v&lt;Outer&gt;)\n            return begin ? ReIterator(m_c.rbegin()) : ReIterator(m_c.rend());\n        else if constexpr (has_push_back_v&lt;Outer&gt; or has_insert_v&lt;Outer&gt;)\n            return begin ? ReIterator(m_c.begin()) : ReIterator(m_c.end());\n        // Unreachable SFINAE has checked before\n    }\n\npublic:\n    using value_type = T; // needed to support std::back_inserter\n\n    auto begin() const { return get_begin_end(true); }\n    auto end() const { return get_begin_end(false); }\n\n    auto &amp;operator ++() {\n        *get_inserter(m_c)++ = Inner{};\n        return *this;\n    }\n\n    constexpr auto push_back(const T &amp;t) {\n        if constexpr (has_push_front_v&lt;Outer&gt;)\n            return *get_inserter(*(--m_c.rend())) = t;\n        else if constexpr (has_push_back_v&lt;Outer&gt; or has_insert_v&lt;Outer&gt;)\n            return *get_inserter(*(--m_c.end())) = t;\n        // Unreachable SFINAE has checked before\n    }\n};\n\ntemplate &lt;typename I&gt;\nauto\nvariable_sized_arrays(I &amp;in, size_t n) {\n#ifdef CASE1\n    auto vsa = VariableSizedArrays&lt;std::deque, std::deque&gt;{};\n#elif defined CASE2\n    auto vsa = VariableSizedArrays&lt;std::deque, std::vector&gt;{};\n#elif defined CASE3\n    auto vsa = VariableSizedArrays&lt;std::vector, std::deque&gt;{};\n#else\n    auto vsa = VariableSizedArrays{};\n#endif\n    for(; n--; in++) // resync \"in\" iterator after copy action\n        std::copy_n(in, *in++, std::back_inserter(++vsa)); // *in++ = k\n\n    return vsa;\n}\n\nint\nmain(int, char *[]) {\n    // prepare iterators for input/output\n    auto in = std::istream_iterator&lt;int&gt;{std::cin};\n    auto in_last = std::istream_iterator&lt;int&gt;{};\n    auto out = std::ostream_iterator&lt;int&gt;{std::cout, \"\\n\"};\n    // problem parameters (const and from input)\n    auto n = *in++;\n    [[maybe_unused]] auto q = *in++; // num arrays, num queries\n    auto &amp;&amp;vsa = variable_sized_arrays(in, n); // get matrix\n    while(in != in_last) // run queries until input is exhausted\n        *out++ = *std::next(vsa.begin(), {{*in++, *in++}}); // *in++ =&gt; i, j\n    return 0;\n}\n</code></pre> <p>GitHub: 10-variable-sized-arrays/variable-sized-arrays-04.cpp </p>"},{"location":"0110-jumping-in-the-clouds-revisited/","title":"Jumping On The Clouds - Revisited","text":"<p>Title: Jumping On The Clouds - Revisited Link: https://www.hackerrank.com/challenges/jumping-on-the-clouds-revisited/ </p>"},{"location":"0110-jumping-in-the-clouds-revisited/#skipping-the-obvious","title":"Skipping The Obvious","text":"<p>Given that we have already gone for the obvious solution in all previous challenges, we are going to go directly for an iterator-based solution to spare us some lines of text and code.</p> <p>The challenge demands that we read a number of <code>int</code> values, to be stored in an <code>std::vector&lt;int&gt;</code>, and a constant <code>k</code> that will determine the next jump inside the array of <code>int</code> values.</p> <p>For each jump the initial <code>e</code> (energy value) of <code>100</code> will be decremented by <code>1</code>, with an extra decrement of <code>2</code> if the position we landed on contains a <code>true</code>, non zero, value. The jump trip is over when the new position is the initial position.</p> <pre><code>#include &lt;algorithm&gt; // std::copy_n\n#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iterator&gt; // std::istream/ostream_iterator\n#include &lt;vector&gt; // std::vector\n\ntemplate &lt;typename I, typename O&gt;\nauto\nfinal_energy(I first, O out, int n, int k, int e) {\n    auto cloud = first;\n    do {\n        auto i = std::distance(first, cloud); // &gt;= 0\n        cloud = std::next(first, (i + k) % n); // next is at (i + k) % n\n        e -= 1 + (*cloud * 2); // jump - 1, on non-zero cloud == 1 .. +2\n    } while(cloud != first);\n    *out++ = e;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Main\n///////////////////////////////////////////////////////////////////////////////\nint\nmain(int, char *[]) {\n    constexpr auto e = 100;  // starting energy level\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto in_last = std::istream_iterator&lt;int&gt;{}; // input iterator end\n    auto out = std::ostream_iterator&lt;int&gt;{std::cout, \"\\n\"}; // output iterator\n    for(; in != in_last; in++) { // resync \"in\" after copy_n operation\n        auto n = *in++, k = *in++; // input parameters\n        auto c = std::vector&lt;bool&gt;{}; // storage\n        std::copy_n(in, n, std::back_inserter(c)); // copy input\n        final_energy(c.begin(), out, n, k, e);\n    }\n    return 0;\n}\n</code></pre> <p>GitHub: 11-jumping-on-the-clouds-ii/jumping-on-the-clouds-ii-01.cpp </p> <p>As we did previously, we prepare our solution to solve any number of inputs by checking for end-if-input with <code>std::istream_iterator&lt;int&gt;{}</code>.</p> <p>Once the input is gathered the problem is easily solved with a <code>do-while</code> loop, instead of the usual <code>while</code> and that is because there is always a first jump. Action that could actually take us to the beginning. Notice that we only need the <code>first</code> iterator, because the jump calculation formula, <code>(i + k) % n</code> ensures that we never get a new position greater than <code>n</code>.</p>"},{"location":"0110-jumping-in-the-clouds-revisited/#mimicking-stdistream_iteratort","title":"Mimicking std::istream_iterator&lt;T","text":"<p>The happy hour idea to improve the solution of this problem comes from looking at the STL. In the problem we use</p> <pre><code>    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto in_last = std::istream_iterator&lt;int&gt;{}; // input iterator end\n</code></pre> <p>GitHub: 11-jumping-on-the-clouds-ii/jumping-on-the-clouds-ii-01.cpp:24:25 </p> <p>We can quickly make an analogy: we traverse the array (<code>std::vector&lt;int&gt;</code>) until we hit the end of the trip. The fact that the end is the initial position shall not distract us. We can create an iterator that executes the jumps for us until it comes back to the original position. Our iterator will simply take the iterator from the <code>std::vector&lt;int&gt;</code> that determines the initial position and jump to the next.</p> <p>Rather than hardcoding the jump in our iterator, it will accept a function to calculate the position. The only parameter the function has to take is the actual position.</p> <pre><code>template &lt;typename It, typename T = int&gt;\nstruct JumpingIterator {\n    // Iterator tags\n    using iterator_category = std::random_access_iterator_tag;\n    using difference_type   = std::ptrdiff_t;\n    using value_type        = T;\n    using reference         = value_type &amp;;\n    using pointer           = value_type *;\n\n    const It m_itfirst;\n    It m_itcur;\n    using FunctionMove = std::function&lt;int(int)&gt;;\n    FunctionMove m_fmove;\n\n    bool m_end = false;\n\n    JumpingIterator(It first, const FunctionMove &amp;fmove)\n        : m_itfirst{first}, m_itcur{first}, m_fmove(fmove) {}\n\n    JumpingIterator() : m_end{true} {}\n</code></pre> <p>GitHub: 11-jumping-on-the-clouds-ii/jumping-on-the-clouds-ii-02.cpp:8:27 </p> <p>That is our iterator basic definition with member attributes and constructors. The wrapped-iterator itself is a template parameter, since we do not know in advance what will come to us.</p> <pre><code>    auto operator *() { return *m_itcur; }\n\n    auto &amp;operator ++() { // Prefix increment\n        if (not m_end) {\n            auto d = std::distance(m_itfirst, m_itcur); // &gt;= 0\n            m_itcur = std::next(m_itfirst, m_fmove(d));\n            m_end = m_itfirst == m_itcur;\n        }\n        return *this;\n    }\n</code></pre> <p>GitHub: 11-jumping-on-the-clouds-ii/jumping-on-the-clouds-ii-02.cpp:30:39 </p> <p>The <code>*</code> dereferencing operator will simply return the value of the current position. The actual job is done in the prefix increment <code>++</code> operator, where the current distance to the start is calculated and the jump is executed using the function <code>m_fmove</code> that was given during construction. To ensure no extra jumps happen, the <code>m_end</code> flag is checked and calculated also here.</p> <pre><code>template &lt;typename I, typename FMove, typename FEnergy&gt;\nauto\nminus_energy(I first, FMove fmove, FEnergy fenergy) {\n    return std::accumulate(\n        JumpingIterator&lt;I&gt;(first, fmove), // first\n        JumpingIterator&lt;I&gt;{}, // last\n        0, // init\n        fenergy // binary op\n    );\n}\n</code></pre> <p>GitHub: 11-jumping-on-the-clouds-ii/jumping-on-the-clouds-ii-02.cpp:49:58 </p> <p>With such a powerful iterator in the hand we can resort to using <code>std::accumulate</code> to calculate how much energy will be deducted after all jumps have been performed. And once again the formula is a function parameter, <code>fenergy</code>. We do not want to write code in the solution that can come as a parameter.</p> <p>We have taken the <code>typename O</code> template parameter out of the equation. And this is because it feels redundant to also pass the <code>e</code>, initial energy level, as a parameter. Our solution function gives us the energy that will be deducted and we can directly deduct it from the initial energy and output the result, all in the <code>main</code> loop.</p> <pre><code>        auto n = *in++, k = *in++; // input parameters\n        auto fenergy = [](auto acc, auto x) { return acc - (1 + (x * 2)); };\n        auto fmove = [&amp;n, &amp;k](auto x) { return (x + k) % n; };\n        auto c = std::vector&lt;bool&gt;{}; // storage\n        std::copy_n(in, n, std::back_inserter(c)); // copy input\n        *out++ = e + minus_energy(c.begin(), fmove, fenergy); // solve\n</code></pre> <p>GitHub: 11-jumping-on-the-clouds-ii/jumping-on-the-clouds-ii-02.cpp:70:75 </p> <p>Our <code>JumpingIterator</code> is ready and passes all tests. We have marked it as an</p> <p><code>std::random_access_iterator_tag</code> because it jumps randomly inside the array range. Granted, it is not a random jump, it is a jump determined by the constant <code>k</code> and the range length <code>n</code>, but it fits the description of a RandomAccessIterator.</p> <p>Here is the complete code.</p> <pre><code>#include &lt;algorithm&gt; // std::copy_n\n#include &lt;functional&gt; // std::function\n#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iterator&gt; // std::istream/ostream_iterator\n#include &lt;numeric&gt; // std::accumulate\n#include &lt;vector&gt; // std::vector\n\ntemplate &lt;typename It, typename T = int&gt;\nstruct JumpingIterator {\n    // Iterator tags\n    using iterator_category = std::random_access_iterator_tag;\n    using difference_type   = std::ptrdiff_t;\n    using value_type        = T;\n    using reference         = value_type &amp;;\n    using pointer           = value_type *;\n\n    const It m_itfirst;\n    It m_itcur;\n    using FunctionMove = std::function&lt;int(int)&gt;;\n    FunctionMove m_fmove;\n\n    bool m_end = false;\n\n    JumpingIterator(It first, const FunctionMove &amp;fmove)\n        : m_itfirst{first}, m_itcur{first}, m_fmove(fmove) {}\n\n    JumpingIterator() : m_end{true} {}\n\n    auto operator -&gt;() { return &amp;(*m_itcur); }\n    auto operator *() { return *m_itcur; }\n\n    auto &amp;operator ++() { // Prefix increment\n        if (not m_end) {\n            auto d = std::distance(m_itfirst, m_itcur); // &gt;= 0\n            m_itcur = std::next(m_itfirst, m_fmove(d));\n            m_end = m_itfirst == m_itcur;\n        }\n        return *this;\n    }\n    // Postfix increment\n    auto operator ++(int) { JumpingIterator tmp = *this; ++(*this); return tmp; }\n\n    auto operator ==(const JumpingIterator&amp; o) const {\n        return m_end ? o.m_end : (not o.m_end and (m_itcur == o.m_itcur));\n    }\n    auto operator !=(const JumpingIterator&amp; o) const { return not (*this == o); }\n};\n\ntemplate &lt;typename I, typename FMove, typename FEnergy&gt;\nauto\nminus_energy(I first, FMove fmove, FEnergy fenergy) {\n    return std::accumulate(\n        JumpingIterator&lt;I&gt;(first, fmove), // first\n        JumpingIterator&lt;I&gt;{}, // last\n        0, // init\n        fenergy // binary op\n    );\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Main\n///////////////////////////////////////////////////////////////////////////////\nint\nmain(int, char *[]) {\n    constexpr auto e = 100; // starting energy level\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto in_last = std::istream_iterator&lt;int&gt;{}; // input iterator end\n    auto out = std::ostream_iterator&lt;int&gt;{std::cout, \"\\n\"}; // output iterator\n    for(; in != in_last; in++) { // resync \"in\" after copy_n operation\n        auto n = *in++, k = *in++; // input parameters\n        auto fenergy = [](auto acc, auto x) { return acc - (1 + (x * 2)); };\n        auto fmove = [&amp;n, &amp;k](auto x) { return (x + k) % n; };\n        auto c = std::vector&lt;bool&gt;{}; // storage\n        std::copy_n(in, n, std::back_inserter(c)); // copy input\n        *out++ = e + minus_energy(c.begin(), fmove, fenergy); // solve\n    }\n    return 0;\n}\n</code></pre> <p>GitHub: 11-jumping-on-the-clouds-ii/jumping-on-the-clouds-ii-02.cpp </p>"},{"location":"0110-jumping-in-the-clouds-revisited/#adding-sfinae","title":"Adding SFINAE","text":"<p>Yes, once again we are going to do some dirty work. Someone has to do it! And we do it because we have, for example, define as parameters the functions that move the iterator and calculate energy deduction. Hence the need to ensure that they take the right number and type of arguments and deliver the expected result.</p> <p>In the case of the iterator the check does not happen in the <code>struct</code> definition itself, but in the constructor. This is the earliest moment at which we can pass the <code>fmove</code> function, and the check has to therefore take place there.</p> <pre><code>    template &lt;typename F, typename = enable_if_fmove&lt;F&gt;&gt;\n    JumpingIterator(It first, const F &amp;fmove)\n        : m_itfirst{first}, m_itcur{first}, m_fmove(fmove) {}\n</code></pre> <p>GitHub: 11-jumping-on-the-clouds-ii/jumping-on-the-clouds-ii-03.cpp:53:55 </p> <p>The other checks are all made when the templates parameters are defined. We have had to resort to long strings of beloved <code>decltype</code> / <code>std::declval&lt;T&gt;</code> married couple checks. Applying, for example <code>std::is_integral</code> to the result of <code>std::invoke_result_t</code> to check if the output type of the <code>fmove</code> and <code>fenergy</code> parameters is a match would not work even if it seems optimal.</p> <p>The full code is presented here.</p> <pre><code>#include &lt;algorithm&gt; // std::copy_n\n#include &lt;functional&gt; // std::function\n#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iterator&gt; // std::istream/ostream_iterator\n#include &lt;numeric&gt; // std::accumulate\n#include &lt;vector&gt; // std::vector\n#include &lt;type_traits&gt; // std::enable_if, std::is_integral, std::void_t\n\n// SFINAE to check for It being an Input iterator and T and integer-like\ntemplate &lt;typename T, typename Tag&gt;\nconstexpr bool is_it_tag_v =\n    std::is_base_of_v&lt;Tag, typename std::iterator_traits&lt;T&gt;::iterator_category&gt;;\n\ntemplate &lt;typename I&gt;\nconstexpr bool is_input_v = is_it_tag_v&lt;I, std::input_iterator_tag&gt;;\n\ntemplate &lt;typename It, typename T&gt;\nusing enable_if_iter_int =\n    std::enable_if_t&lt;is_input_v&lt;It&gt; and std::is_integral_v&lt;T&gt;&gt;;\n\nusing FunctionMove = std::function&lt;int(int)&gt;;\n\ntemplate&lt;typename, typename = void&gt;\nconstexpr bool is_fmove_v = false;\n\ntemplate&lt;typename F&gt;\nconstexpr bool is_fmove_v&lt;F,\n    std::void_t&lt;\n        decltype(\n            std::declval&lt;FunctionMove&gt;()(0) ==\n            std::declval&lt;std::invoke_result_t&lt;F, int&gt;&gt;()\n        )&gt;&gt; = true;\n\ntemplate&lt;typename F&gt;\nusing enable_if_fmove = std::enable_if_t&lt;is_fmove_v&lt;F&gt;&gt;;\n\ntemplate &lt;\n    typename It, typename T = int, typename = enable_if_iter_int&lt;It, T&gt;&gt;\nstruct JumpingIterator {\n    // Iterator tags\n    using iterator_category = std::random_access_iterator_tag;\n    using difference_type   = std::ptrdiff_t;\n    using value_type        = T;\n    using reference         = value_type &amp;;\n    using pointer           = value_type *;\n\n    const It m_itfirst;\n    It m_itcur;\n    FunctionMove m_fmove;\n\n    bool m_end = false;\n\n    template &lt;typename F, typename = enable_if_fmove&lt;F&gt;&gt;\n    JumpingIterator(It first, const F &amp;fmove)\n        : m_itfirst{first}, m_itcur{first}, m_fmove(fmove) {}\n\n    JumpingIterator() : m_end{true} {}\n\n    auto operator -&gt;() { return &amp;(*m_itcur); }\n    auto operator *() { return *m_itcur; }\n\n    auto &amp;operator ++() { // Prefix increment\n        if (not m_end) {\n            m_itcur = std::next(\n                m_itfirst,\n                m_fmove(std::distance(m_itfirst, m_itcur))\n            );\n            m_end = m_itfirst == m_itcur;\n        }\n        return *this;\n    }\n    // Postfix increment\n    auto operator ++(int) { JumpingIterator tmp = *this; ++(*this); return tmp; }\n\n    auto operator ==(const JumpingIterator&amp; o) const {\n        return m_end ? o.m_end : (not o.m_end and (m_itcur == o.m_itcur));\n    }\n    auto operator !=(const JumpingIterator&amp; o) const { return not (*this == o); }\n};\n\n// SFINAE for the solution function\nusing FunctionEnergy = std::function&lt;int(int, int)&gt;;\n\ntemplate&lt;typename, typename = void&gt;\nconstexpr bool is_fenergy_v = false;\n\ntemplate&lt;typename F&gt;\nconstexpr bool is_fenergy_v&lt;F,\n    std::void_t&lt;\n        decltype(\n            std::declval&lt;FunctionEnergy&gt;()(0, 0) ==\n            std::declval&lt;std::invoke_result_t&lt;F, int, int&gt;&gt;()\n        )&gt;&gt; = true;\n\ntemplate &lt;typename I, typename FMove, typename FEnergy&gt;\nusing enable_if_iter_fmove_fenergy = std::enable_if_t&lt;\n    is_input_v&lt;I&gt; and is_fmove_v&lt;FMove&gt; and is_fenergy_v&lt;FEnergy&gt;&gt;;\n\ntemplate &lt;typename I, typename FMove, typename FEnergy,\n    typename = enable_if_iter_fmove_fenergy&lt;I, FMove, FEnergy&gt;&gt;\nauto\nminus_energy(I first, FMove fmove, FEnergy fenergy) {\n    return std::accumulate(\n        JumpingIterator&lt;I&gt;(first, fmove), // first\n        JumpingIterator&lt;I&gt;{}, // last\n        0, // init\n        fenergy // binary op\n    );\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// Main\n///////////////////////////////////////////////////////////////////////////////\nint\nmain(int, char *[]) {\n    constexpr auto e = 100; // starting energy level\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto in_last = std::istream_iterator&lt;int&gt;{}; // input iterator end\n    auto out = std::ostream_iterator&lt;int&gt;{std::cout, \"\\n\"}; // output iterator\n    for(; in != in_last; in++) { // resync \"in\" after copy_n operation\n        auto n = *in++, k = *in++; // input parameters\n        auto fenergy = [](auto acc, auto x) { return acc - (1 + (x * 2)); };\n        auto fmove = [&amp;n, &amp;k](auto x) { return (x + k) % n; };\n        auto c = std::vector&lt;bool&gt;{}; // storage\n        std::copy_n(in, n, std::back_inserter(c)); // copy input\n        *out++ = e + minus_energy(c.begin(), fmove, fenergy); // solve\n    }\n    return 0;\n}\n</code></pre> <p>GitHub: 11-jumping-on-the-clouds-ii/jumping-on-the-clouds-ii-03.cpp </p>"},{"location":"0120-angry-professor/","title":"The Angry Professor","text":"<p>Title: Angry Professor Link: https://www.hackerrank.com/challenges/angry-professor </p> <p>In this challenge we can have several test cases with a single input. Each test case has the total number <code>n</code> of students that could attend a class and the minimum number of attendants, the threshold <code>k</code>, when the class is bound to start, for the professor not to cancel the class. The input has <code>n</code> integer values, with negative and zero values indicating early or on-time arrival. Positive values are used for a late arrival.</p> <p>And the output uses plain English, \u201cYES\u201d and \u201cNO\u201d* to let us know if the class was canceled.</p> <p>Having multiple test cases has one implication: we have to consume the input of a test case before we can proceed to the next. That implication leads directly to the use an intermediate storage like <code>std::vector&lt;int&gt;</code> and that pushes us in the direction of going once again for an iterator-based solution rather than showing a plain old approach.</p> <pre><code>#include &lt;algorithm&gt; // std::copy_n\n#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iterator&gt; // std::istream/ostream_iterator, std::back_inserter\n#include &lt;vector&gt; // std::vector\n\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto out = std::ostream_iterator&lt;std::string&gt;{std::cout, \"\\n\"}; // out iter\n    const auto fearly = [](const auto &amp;x) { return x &lt;= 0; };\n    for(auto t = *in++; t--; ++in) { // resync \"in\" after copy_n operation\n        const auto n = *in++, k = *in++; // students and threshold\n        auto c = std::vector&lt;int&gt;{}; // storage\n        std::copy_n(in, n, std::back_inserter(c)); // copy input\n        const auto students = std::count_if(c.begin(), c.end(), fearly);\n        *out++ = students &lt; k ? \"YES\" : \"NO\"; // canceled if less than k\n    }\n    return 0;\n}\n</code></pre> <p>GitHub: 12-angry-professor/angry-professor-01.cpp </p> <p>The code is easy to summarize</p> <ul> <li> <p>Create the input and output iterators.</p> </li> <li> <p>Prepare a lambda expression to determine an early arrival, i.e.. <code>x &lt;= 0</code>.</p> </li> <li> <p>Read the number of test cases, to perform a loop until it is exhausted.</p> </li> <li> <p>Read <code>n</code>, <code>k</code> (arrival times, threshold) and the <code>n</code> elements into a vector.</p> </li> <li> <p>Use <code>std::count_if</code> with our lambda to count early arrivals</p> </li> <li> <p>Output if the class is canceled by comparing to the threshold <code>k</code>.</p> </li> </ul> <p>We should be happy after solving the problem in <code>18</code> lines. The code provided by HackerRank simply to manage the input is <code>101</code> lines long. Granted, <code>3</code> of those lines are the skeleton for the function the coder has to fill in. Had we used the header <code>#include &lt;bits/stdc++.h&gt;</code> instead of the standard headers, we would have also saved <code>3</code> lines.</p>"},{"location":"0120-angry-professor/#iterator-attack","title":"Iterator Attack","text":"<p>The previous solution does not take into account that the threshold, <code>k</code>, could be met without having to check the arrival times of all students. <code>std::count_if</code> counts from the beginning until the end, regardless of what the actual <code>count</code> is.</p> <p>The algorithm will of course check on every iteration if the first iterator, <code>c.begin()</code> is already equal to the last, <code>c.end()</code>, and proceed to increase, <code>++</code> the first if not. That is what we are going to take advantage of with our brilliant idea: an iterator, <code>CountUntilIter</code> that will be and <code>end</code> iterator as soon as the expected count (our threshold <code>k</code>) has been reached. And we will avoid going over the entire range if it is not needed.</p> <p>Our iterator takes the container for its construction and the threshold <code>k</code>. To make it flexible it does also take a function that accepts and <code>int</code>, our type in the problem, and returns a <code>bool</code>. The container is used to get the <code>begin</code> and <code>end</code> iterators.</p> <pre><code>    auto operator *() {\n        auto ret = m_fearly(*m_first);\n        if (not m_end and ret)\n            m_end = m_until == (m_count += ret);\n        return ret;\n    }\n    auto &amp;operator ++() { // Prefix increment\n        if (not m_end)\n            m_end = ++m_first == m_last;\n        return *this;\n    }\n    auto operator ==(const CountUntilIter&amp; o) const {\n        return o.m_end ? m_end : m_first == o.m_first;\n    }\n</code></pre> <p>GitHub: 12-angry-professor/angry-professor-02.cpp:33:46 </p> <p>The lines above contain the secret sauce. During dereferencing with <code>*</code>, the current value is passed to the early detection function we got in the constructor. The result (<code>true</code> or <code>false</code>) is added to a running count and compared to the <code>until</code> (the threshold) value we also got during construction, to determine if the end has been reached and pose as an iterator having met its end.</p> <p>During <code>++</code> pre-increment, the iterator being moved forward is also checked against the real end of the range, to also mark itself as ended. This time for real!</p> <p>And during comparison, to be done with an <code>end</code> iterator, the mark we have set it is used to indicate equality to the end.</p> <pre><code>        const auto students = std::count(\n            CountUntilIter{c, k, fearly},\n            CountUntilIter&lt;decltype(c)&gt;{},\n            true\n        );\n</code></pre> <p>GitHub: 12-angry-professor/angry-professor-02.cpp:64:68 </p> <p>The iterator is applied with <code>std::count</code> the \u201cif-less\u201d variant that looks only for a specific value, <code>true</code> in our case. The algorithm does not know that <code>CountUntilIter</code> will perform a sudden jump to its end, but will break out early on that event.</p> <p>We have also taken the chance to use an <code>std::array</code> to hold the cancellation answer, simply for the sake of it. We did the same with some of the initial challenges, such as <code>Hello, World!</code>.</p> <p>And because \u201cwe can\u201d, we have also done, as usual, away with using <code>t</code>, the number of test cases, and keep on reading until we hit the end-of-input, being therefore capable of solving any number of cases. If needed be, of course.</p> <p>Here is the entire code of this second <code>71</code> lines solution, still well under the <code>101</code> yet-to-be-solved proposal from HackerRank.</p> <pre><code>#include &lt;array&gt; // std::array\n#include &lt;algorithm&gt; // std::copy_n\n#include &lt;functional&gt; // std::function\n#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iterator&gt; // std::istream/ostream_iterator, std::back_inserter\n#include &lt;vector&gt; // std::vector\n\ntemplate &lt;typename C&gt;\nstruct CountUntilIter {\n    // Iterator tags\n    using iterator_category = std::forward_iterator_tag;\n    using difference_type   = std::ptrdiff_t;\n    using value_type        = typename C::value_type;\n    using reference         = value_type &amp;;\n    using pointer           = value_type *;\n\n    typename C::const_iterator m_first;\n    typename C::const_iterator m_last;\n    int m_until;\n    int m_count = 0;\n\n    using FuncEarly = std::function&lt;bool(int)&gt;;\n    FuncEarly m_fearly;\n\n    bool m_end = true;\n\n    CountUntilIter(const C &amp;c, int until, FuncEarly fearly)\n        : m_first{c.cbegin()}, m_last{c.cend()}, m_until{until},\n          m_fearly{fearly}, m_end{m_count &gt;= m_until or m_first == m_last} {};\n\n    CountUntilIter() {}\n\n    auto operator *() {\n        auto ret = m_fearly(*m_first);\n        if (not m_end and ret)\n            m_end = m_until == (m_count += ret);\n        return ret;\n    }\n    auto &amp;operator ++() { // Prefix increment\n        if (not m_end)\n            m_end = ++m_first == m_last;\n        return *this;\n    }\n    auto operator ==(const CountUntilIter&amp; o) const {\n        return o.m_end ? m_end : m_first == o.m_first;\n    }\n    auto operator !=(const CountUntilIter&amp; o) const { return not (*this == o); }\n};\n\n// Main\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto in_last = std::istream_iterator&lt;int&gt;{}; // input iterator end\n    auto out = std::ostream_iterator&lt;std::string&gt;{std::cout, \"\\n\"}; // out iter\n    constexpr auto canceled = std::array{\"NO\", \"YES\"};\n    const auto fearly = [](const auto &amp;x) { return x &lt;= 0; };\n\n    [[maybe_unused]] auto t = *in++; // number of testcases (unused)\n    for(; in != in_last; ++in) { // resync \"in\" after copy_n operation\n        const auto n = *in++, k = *in++; // students and threshold\n        auto c = std::vector&lt;int&gt;{}; // storage\n        std::copy_n(in, n, std::back_inserter(c)); // copy input\n        const auto students = std::count(\n            CountUntilIter{c, k, fearly},\n            CountUntilIter&lt;decltype(c)&gt;{},\n            true\n        );\n        *out++ = canceled[students &lt; k];\n    }\n    return 0;\n}\n</code></pre> <p>GitHub: 12-angry-professor/angry-professor-02.cpp </p>"},{"location":"0120-angry-professor/#rethinking-the-iterator-approach","title":"Rethinking The Iterator Approach","text":"<p>On second thought, we have probably overdone ourselves just a little bit with our <code>CountUntilIter</code> design. The question is we, after all, do really need an iterator or we need to overcome <code>std::count</code> (with and without <code>if</code>) algorithm design, to be able to break out of the counting sequence if a threshold is reached.</p> <p>Let us therefore design a <code>count_n_until_k_if</code> algorithm to rule where all other counting algorithms fail to deliver.</p> <pre><code>template &lt;typename I, typename F&gt;\nauto\ncount_n_until_k_if(I first, int n, int k, F fnk) {\n    auto count = 0;\n    for (; n-- and count != k; ++first)\n        count += fnk(*first);\n\n    return count;\n}\n</code></pre> <p>GitHub: 12-angry-professor/angry-professor-03.cpp:7:15 </p> <p>Et voil\u00e1! Our algorithm takes a <code>first</code> iterator, expected to be an InputIterator, takes also the maximum number of elements to check, <code>n</code> and what threshold, <code>k</code> to check for after the current value of the range has gone through the function <code>fnk</code>. The <code>for</code> look will interrupted if the running <code>count</code> reaches <code>k</code>.</p> <p>The full code is here.</p> <pre><code>#include &lt;array&gt; // std::array\n#include &lt;algorithm&gt; // std::copy_n\n#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iterator&gt; // std::istream/ostream_iterator, std::back_inserter\n#include &lt;vector&gt; // std::vector\n\ntemplate &lt;typename I, typename F&gt;\nauto\ncount_n_until_k_if(I first, int n, int k, F fnk) {\n    auto count = 0;\n    for (; n-- and count != k; ++first)\n        count += fnk(*first);\n\n    return count;\n}\n\n// Main\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto in_last = std::istream_iterator&lt;int&gt;{}; // input iterator end\n    auto out = std::ostream_iterator&lt;std::string&gt;{std::cout, \"\\n\"}; // out iter\n    constexpr auto canceled = std::array{\"NO\", \"YES\"};\n    auto fearly = [](const auto &amp;x) { return x &lt;= 0; };\n    [[maybe_unused]] auto t = *in++; // number of testcases (unused)\n    for(; in != in_last; ++in) { // resync \"in\" after copy_n operation\n        const auto n = *in++, k = *in++; // students and threshold\n        auto c = std::vector&lt;int&gt;{}; // storage\n        std::copy_n(in, n, std::back_inserter(c)); // copy input\n        const auto students = count_n_until_k_if(c.begin(), n, k, fearly);\n        *out++ = canceled[students &lt; k];\n    }\n    return 0;\n}\n</code></pre> <p>GitHub: 12-angry-professor/angry-professor-03.cpp </p>"},{"location":"0120-angry-professor/#storage-less-counting","title":"Storage-less Counting","text":"<p>At the beginning of this chapter we stated that we had to store the input, because we had to consume it. But again on second thought, the key is not to store, but to consume if it is needed.</p> <p>And here is were C++17 comes to the rescue again with <code>if constexpr</code>.</p> <pre><code>template &lt;typename I, typename F, typename = enable_if_iter_fnk&lt;I, F&gt;&gt;\nauto\ncount_n_until_k_if(I first, int n, int k, F fnk) {\n    auto count = 0;\n    for (; n-- and count != k; ++first)\n        count += fnk(*first);\n\n    if constexpr (is_istream_iter_v&lt;I&gt;)\n        for(; n &gt;= 0; --n, ++first); // consume \"n\" elements from istream_iter\n\n    return count;\n}\n</code></pre> <p>GitHub: 12-angry-professor/angry-professor-04.cpp:37:48 </p> <p>You probably noticed that we were not taking an iterator pair, <code>first</code> and <code>last</code> and that was a forward-thinking decision to accommodate an <code>std::istream_iterator</code>. With it our algorithm must no go until the end-of-range, because we would be reading past the next <code>n</code> elements and consuming the input and elements of subsequent challenges.</p> <p>We only have to consume <code>n</code> elements. If the <code>for</code> loop was interrupted early, the <code>if constexpr</code> checks if the input iterator <code>first</code> is of type <code>std::istream_iterator</code>, adding the currently calculated iterator <code>value_type</code>. If the check succeeds, as many elements as needed will be consumed, until the boundary of the next challenge, or the end-of-input, is reached.</p> <p>In this case we added a complete set of SFINAE checks for the iterator and the value-check function. And we also added a <code>CASE1</code> with full storage in an <code>std::vector</code> to check the algorithm under both <code>if constexpr</code> results.</p> <p>(And yet, the code is at <code>70</code> lines, well below the HackerRank proposal).</p> <pre><code>#include &lt;array&gt; // std::array\n#include &lt;algorithm&gt; // std::copy_n\n#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iterator&gt; // std::istream/ostream_iterator, std::back_inserter\n#include &lt;vector&gt; // std::vector\n#include &lt;type_traits&gt; // std::void_t, std::enable_if ...\n\n// get iterator type\ntemplate &lt;typename I&gt;\nusing it_type = typename std::iterator_traits&lt;I&gt;::value_type;\n\n// check if iterator is input iterator\ntemplate &lt;typename T, typename Tag&gt;\nconstexpr bool is_it_tag_v =\n    std::is_base_of_v&lt;Tag, typename std::iterator_traits&lt;T&gt;::iterator_category&gt;;\n\ntemplate &lt;typename I&gt;\nconstexpr bool is_input_v = is_it_tag_v&lt;I, std::input_iterator_tag&gt;;\n\n// check if iterator is std::istream_iterator\ntemplate &lt;template &lt;typename&gt; class B, typename I&gt;\nconstexpr bool is_base_of_iter_v = std::is_base_of_v&lt;B&lt;it_type&lt;I&gt;&gt;, I&gt;;\n\ntemplate &lt;typename I&gt;\nconstexpr bool is_istream_iter_v = is_base_of_iter_v&lt;std::istream_iterator, I&gt;;\n\n// check function invocation and return type\ntemplate&lt;typename I, typename F&gt;\nconstexpr bool is_fnk =\n    std::is_same_v&lt;bool, std::invoke_result_t&lt;F, it_type&lt;I&gt;&gt;&gt;;\n\n// enabling check for custom count algorithm\ntemplate&lt;typename I, typename F&gt;\nusing enable_if_iter_fnk = std::enable_if_t&lt;is_input_v&lt;I&gt; and is_fnk&lt;I, F&gt;&gt;;\n\n// custom count algorithm\ntemplate &lt;typename I, typename F, typename = enable_if_iter_fnk&lt;I, F&gt;&gt;\nauto\ncount_n_until_k_if(I first, int n, int k, F fnk) {\n    auto count = 0;\n    for (; n-- and count != k; ++first)\n        count += fnk(*first);\n\n    if constexpr (is_istream_iter_v&lt;I&gt;)\n        for(; n &gt;= 0; --n, ++first); // consume \"n\" elements from istream_iter\n\n    return count;\n}\n\n// Main\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto in_last = std::istream_iterator&lt;int&gt;{}; // input iterator end\n    auto out = std::ostream_iterator&lt;std::string&gt;{std::cout, \"\\n\"}; // out iter\n    constexpr auto canceled = std::array{\"NO\", \"YES\"};\n    auto fearly = [](const auto &amp;x) { return x &lt;= 0; };\n    [[maybe_unused]] auto t = *in++; // number of testcases (unused)\n    for(; in != in_last; ++in) { // resync \"in\" after copy_n operation\n        const auto n = *in++, k = *in++; // students and threshold\n#ifdef CASE1\n        auto c = std::vector&lt;int&gt;{}; // storage\n        std::copy_n(in, n, std::back_inserter(c)); // copy input\n        auto &amp;&amp;first = c.begin();\n#else\n        auto first = in;\n#endif\n        const auto students = count_n_until_k_if(first, n, k, fearly);\n        *out++ = canceled[students &lt; k];\n    }\n    return 0;\n}\n</code></pre> <p>GitHub: 12-angry-professor/angry-professor-04.cpp </p>"},{"location":"0130-angry-professor-reloaded/","title":"The Angry Professor - Reloaded","text":"<p>Title: Angry Professor Link: https://www.hackerrank.com/challenges/angry-professor </p> <p>During the previous chapter there were two \u201con second thought\u201d moments. Let us keep on second guessing ourselves by looking for alternatives.</p>"},{"location":"0130-angry-professor-reloaded/#poor-mans-sorting-approach","title":"Poor Man's Sorting Approach","text":"<p>Whilst thinking about how the problem could be solved by looking at the standard library, the idea of sorting the <code>std::vector&lt;int&gt;</code> was an option. But sorting the array and then looking for the boundary where arrival times turn to positive seemed like a very expensive idea.</p> <p>And this is where <code>std::partition</code> enters the game arena. It offers us the possibility to sort, but without sorting. It delivers two \u201cpartitions\u201d (hence the name), where the guarantee is that the elements on the first half meet a logical condition we provide and the elements on the other half do not.</p> <p>Even better, the return value tells us, with an iterator, exactly where the boundary is, i.e., the \u201cpivot\u201d point. Given that we already have a range and a logical condition too, <code>x &lt;= 0</code> there is no harm in trying.</p> <pre><code>template &lt;typename C, typename F&gt;\nauto\ncount_early_students(C &amp;cont, const F &amp;fnk) {\n    const auto pivot = std::partition(cont.begin(), cont.end(), fnk);\n    return std::distance(cont.begin(), pivot);\n}\n</code></pre> <p>GitHub: 13-angry-prof-reloaded/angry-prof-reloaded-01.cpp:8:13 </p> <p>As easy as that. We partition the container, notice we take a non-const reference to it, using a logical condition. The same as in all cases in the previous chapter. And having the \u201cpivot\u201d point as the return value, the number of early students is simply the <code>std::distance</code> from the beginning to the \u201cpivot\u201d point.</p> <p>This is probably less than ideal. We modify the container and this may not be a desired side effect in real challenges. Not taking a non-const reference could, and would, be probably worse because we would be making a copy of the container, making the operation really expensive in terms of time and memory.</p> <p>The full code for this solution.</p> <pre><code>#include &lt;array&gt; // std::array\n#include &lt;algorithm&gt; // std::copy_n, std::partition\n#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iterator&gt; // std::istream/ostream_iterator, std::back_inserter\n#include &lt;vector&gt; // std::vector\n\n// custom count algorithm\ntemplate &lt;typename C, typename F&gt;\nauto\ncount_early_students(C &amp;cont, const F &amp;fnk) {\n    const auto pivot = std::partition(cont.begin(), cont.end(), fnk);\n    return std::distance(cont.begin(), pivot);\n}\n\n// Main\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto in_last = std::istream_iterator&lt;int&gt;{}; // input iterator end\n    auto out = std::ostream_iterator&lt;std::string&gt;{std::cout, \"\\n\"}; // out iter\n    constexpr auto canceled = std::array{\"NO\", \"YES\"};\n    const auto fearly = [](const auto &amp;x) { return x &lt;= 0; };\n    [[maybe_unused]] auto t = *in++; // number of testcases (unused)\n    for(; in != in_last; ++in) { // resync \"in\" after copy_n operation\n        const auto n = *in++, k = *in++; // students and threshold\n        auto c = std::vector&lt;int&gt;{}; // storage\n        std::copy_n(in, n, std::back_inserter(c)); // copy input\n        const auto students = count_early_students(c, fearly);\n        *out++ = canceled[students &lt; k];\n    }\n    return 0;\n}\n</code></pre> <p>GitHub: 13-angry-prof-reloaded/angry-prof-reloaded-01.cpp </p>"},{"location":"0130-angry-professor-reloaded/#filtering-the-input-during-insertion","title":"Filtering The Input During Insertion","text":"<p>The thought of modifying the container brings us another idea: modify the container right at the beginning, before it is even in the container by filtering out the late arrival times.</p> <p>We just said that modifying the container in-place or copying it were bad ideas, but what about if we only care about the content meeting our logical condition. Those \u201cearly-students\u201d may not only make the class possible, it may logical to think they might be rewarded somehow at some point in time.</p> <p>Our <code>std::vector&lt;int&gt;</code> building approach gives us the perfect entry point to implement this idea. Because we do not copy into a container built with a fixed number of empty elements, we do \u201cinsert\u201d with <code>std::back_inserter(c)</code>. Let us replace that \u201cinserter\u201d with our custom version, returning our custom output iterator instead of what the standard library gives us.</p> <p>We only need to rely on the container providing a <code>push_back</code> method for insertion (hence the name <code>back_inserter</code>). The initial function called is just a helper and we create our own helper now.</p> <pre><code>template&lt;typename C, typename F&gt;\nauto\nbool_back_inserter(C &amp;c, const F &amp;fearly) {\n    return bool_back_insert_iterator&lt;C, F&gt;(c, fearly);\n</code></pre> <p>GitHub: 13-angry-prof-reloaded/angry-prof-reloaded-02.cpp:38:42 </p> <p>Unlike the <code>std::back_inserter</code> and to support flexible filtering, we take a second argument: the function that takes the element to be inserted and returns <code>true</code> or <code>false</code>, or something convertible to a <code>bool</code>.</p> <p>We already did an OutputIterator with our \u201cHello, World!\u201d challenge, because we needed the \u201c, \u201d string as the separator, but first starting with the second element. Building on that experience, we know that only the <code>operator =</code> method is operational and all other are <code>no-op</code>. Here is our operational method.</p> <pre><code>    using ContValType = typename C::value_type;\n\n    // Only Operational Method\n    auto &amp;operator =(const ContValType &amp;value) const {\n        if (m_f(value))\n            m_c.push_back(value);\n        return *this;\n    }\n</code></pre> <p>GitHub: 13-angry-prof-reloaded/angry-prof-reloaded-02.cpp:29:36 </p> <p>It is not rocket science, but not far from it. The value, of the type contained in the container is given to the custom logical function taken during construction. If the check passed, the value is inserted. If not, so be it and we let value continue its travel into the unknown.</p> <p>This, of course, simplifies how we approach the problem in the main loop, as there is no longer a call to any solution function, because the problem is automatically solved by the <code>size</code> of the constructed container.</p> <pre><code>        std::copy_n(in, n, bool_back_inserter(c, fearly)); // copy input\n        *out++ = canceled[c.size() &lt; static_cast&lt;unsigned int&gt;(k)];\n</code></pre> <p>GitHub: 13-angry-prof-reloaded/angry-prof-reloaded-02.cpp:57:58 </p> <p>Done and dusted! The only criticism here is that we lose some information by not string the late arrival times. Whether we would need them is another story.</p> <p>Let us present the code of this solution.</p> <pre><code>#include &lt;array&gt; // std::array\n#include &lt;algorithm&gt; // std::copy_n, std::partition\n#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iterator&gt; // std::istream/ostream_iterator\n#include &lt;vector&gt; // std::vector\n\ntemplate &lt;typename C, typename F&gt;\nstruct bool_back_insert_iterator {\n    // needed for an iterator\n    using iterator_category = std::output_iterator_tag;\n    using value_type = void;\n    using difference_type = void;\n    using pointer = void;\n    using reference = void;\n    using container_type = C;\n\n    C &amp;m_c; // wrapped container\n    const F &amp;m_f; // filtering function\n\n    // constructor replicating the wrapped iterator's constructor\n    bool_back_insert_iterator(C &amp;c, const F &amp;f) : m_c{c}, m_f{f} {}\n\n    // no-ops because only the assignment (= operator does something)\n    auto *operator -&gt;() const { return this; } // we wouldn't need this\n    auto &amp;operator *() const { return *this; }\n    auto &amp;operator ++() const { return *this; } // ++prefix\n    auto &amp;operator ++(int) const { return *this; } // postfix++\n\n    using ContValType = typename C::value_type;\n\n    // Only Operational Method\n    auto &amp;operator =(const ContValType &amp;value) const {\n        if (m_f(value))\n            m_c.push_back(value);\n        return *this;\n    }\n};\n\ntemplate&lt;typename C, typename F&gt;\nauto\nbool_back_inserter(C &amp;c, const F &amp;fearly) {\n    return bool_back_insert_iterator&lt;C, F&gt;(c, fearly);\n}\n\n// Main\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto in_last = std::istream_iterator&lt;int&gt;{}; // input iterator end\n    auto out = std::ostream_iterator&lt;std::string&gt;{std::cout, \"\\n\"}; // out iter\n    constexpr auto canceled = std::array{\"NO\", \"YES\"};\n    const auto fearly = [](const auto &amp;x) { return x &lt;= 0; };\n    [[maybe_unused]] auto t = *in++; // number of testcases (unused)\n    for(; in != in_last; ++in) { // resync \"in\" after copy_n operation\n        const auto n = *in++, k = *in++; // students and threshold\n        auto c = std::vector&lt;int&gt;{}; // storage\n        std::copy_n(in, n, bool_back_inserter(c, fearly)); // copy input\n        *out++ = canceled[c.size() &lt; static_cast&lt;unsigned int&gt;(k)];\n    }\n    return 0;\n}\n</code></pre> <p>GitHub: 13-angry-prof-reloaded/angry-prof-reloaded-02.cpp </p>"},{"location":"0130-angry-professor-reloaded/#bonus-sfinae-enabled-version","title":"Bonus SFINAE-Enabled Version","text":"<p>The same version but with the SFINAE checks in place to make sure we have something container-like for the insertion and the proper logical check function. Simply because we can. And because we can, we have reused the preprocessor macros to check for the presence of a method, to look for <code>push_back</code>, <code>push_front</code> and <code>insert</code>. Rather than having an \u201cinserter\u201d that is hardcoded to only push at the back, we can support containers that insert using different methods.</p> <p>Notice that the resulting <code>has_method_v</code> construct does also check for the presence of <code>::value_type</code>, because if it is not there, <code>std::void_t</code> will fail to deliver and the SFINAE check will fail. That is all we need to check to believe that the type is a container, even it is faking it.</p> <p>We use <code>::value_type</code> in our <code>operator =</code> implementation to keep it generic and to see if the logical check function can be invoked with that value type. This is where we will again apply <code>if constexpr</code> magic to choose the proper insertion method.</p> <p>And because we are no longer bound to <code>push_back</code> we have changed the names of our helper and iterator marvels, to remove <code>back</code> from the name and use a proper <code>filter</code> name prefix for them.</p> <p>Before presenting the new monster code, let us double down on the small number-of-lines joke. Recall that HackerRank proposes <code>101</code> lines just to gather the input, including <code>3</code> for the skeleton of the solution. In all previous instances we were always well under that line count. This time we have <code>118</code> and that means that for all instances and purposes we have overtaken the HackerRank proposal. And that even if we consider solving the problem, because a trivial solution with the <code>std::vector&lt;int&gt;</code> in the hand can be compressed into a one liner.</p> <p>Let us go for the code.</p> <pre><code>#include &lt;array&gt; // std::array\n#include &lt;algorithm&gt; // std::copy_n, std::partition\n#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iterator&gt; // std::istream/ostream_iterator\n#include &lt;vector&gt; // std::vector\n#include &lt;type_traits&gt; // std::void_t, std::enable_if ...\n\n// get container value type\ntemplate &lt;typename C&gt;\nusing cont_type = typename C::value_type;\n\n// Macro for trait definitions where a value_type arg is expected\n#define DEFINE_HAS_METHOD_V(method) \\\ntemplate&lt;typename, typename = void&gt; \\\nconstexpr bool has_##method##_v = false; \\\ntemplate&lt;typename T&gt; \\\nconstexpr bool has_##method##_v&lt;T,\\\n    std::void_t&lt;decltype(std::declval&lt;T&gt;().method())&gt;&gt; = true;\n\n#define DEFINE_HAS_METHOD_V_ARG(method) \\\ntemplate&lt;typename, typename = void&gt; \\\nconstexpr bool has_##method##_v = false; \\\ntemplate&lt;typename T&gt; \\\nconstexpr bool has_##method##_v&lt;T, \\\n    std::void_t&lt;decltype(std::declval&lt;T&gt;().method(\\\n        std::declval&lt;cont_type&lt;T&gt;&gt;()))&gt;&gt; = true;\n\nDEFINE_HAS_METHOD_V_ARG(push_back)\nDEFINE_HAS_METHOD_V_ARG(push_front)\nDEFINE_HAS_METHOD_V(end)\n\n// has_insert_v\ntemplate &lt;typename, typename = void&gt;\nconstexpr bool has_insert_v = false;\n\ntemplate &lt;typename C&gt;\nconstexpr bool has_insert_v&lt;C,\n    std::void_t&lt;decltype(std::declval&lt;C&gt;().insert(\n            std::declval&lt;typename C::const_iterator&gt;(),\n            std::declval&lt;cont_type&lt;C&gt;&gt;()))&gt;&gt; = true;\n\n// is_container_v\ntemplate &lt;typename C&gt;\nconstexpr bool is_container_v = has_push_back_v&lt;C&gt; or has_push_front_v&lt;C&gt;\n    or (has_insert_v&lt;C&gt; and has_end_v&lt;C&gt;);\n\n// check function invocation and return type\ntemplate&lt;typename C, typename F&gt;\nconstexpr bool is_f =\n    std::is_convertible_v&lt;std::invoke_result_t&lt;F, cont_type&lt;C&gt;&gt;, bool&gt;;\n\n// enabling check for custom count algorithm\ntemplate&lt;typename C, typename F&gt;\nusing enable_if_cont_func = std::enable_if_t&lt;is_container_v&lt;C&gt; and is_f&lt;C, F&gt;&gt;;\n\n// custom back insertion iterator filtering out on false check\ntemplate &lt;typename C, typename F, typename = enable_if_cont_func&lt;C, F&gt;&gt;\nstruct filter_insert_iterator {\n    // needed for an iterator\n    using iterator_category = std::output_iterator_tag;\n    using value_type = void;\n    using difference_type = void;\n    using pointer = void;\n    using reference = void;\n    using container_type = C;\n\n    C &amp;m_c; // wrapped container\n    const F &amp;m_f; // filtering function\n\n    // constructor replicating the wrapped iterator's constructor\n    filter_insert_iterator(C &amp;c, const F &amp;f) : m_c{c}, m_f{f} {}\n\n    // no-ops because only the assignment (= operator does something)\n    auto *operator -&gt;() const { return this; } // we wouldn't need this\n    auto &amp;operator *() const { return *this; }\n    auto &amp;operator ++() const { return *this; } // ++prefix\n    auto &amp;operator ++(int) const { return *this; } // postfix++\n\n    using ContValType = typename C::value_type;\n\n    // Only Operational Method\n    auto &amp;operator =(const ContValType &amp;value) const {\n        if (m_f(value)) {\n            if constexpr (has_push_back_v&lt;C&gt;)\n                m_c.push_back(value);\n            else if constexpr (has_push_front_v&lt;C&gt;)\n                m_c.push_front(value);\n            else if constexpr (has_insert_v&lt;C&gt;)\n                m_c.insert(m_c.end(), value);\n            // SFINAE checks prevent we get to this point\n        }\n        return *this;\n    }\n};\n\n// helper function\ntemplate&lt;typename C, typename F, typename = enable_if_cont_func&lt;C, F&gt;&gt;\nauto\nfilter_inserter(C &amp;c, const F &amp;fearly) {\n    return filter_insert_iterator&lt;C, F&gt;(c, fearly);\n}\n\n// Main\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto in_last = std::istream_iterator&lt;int&gt;{}; // input iterator end\n    auto out = std::ostream_iterator&lt;std::string&gt;{std::cout, \"\\n\"}; // out iter\n    constexpr auto canceled = std::array{\"NO\", \"YES\"};\n    const auto fearly = [](const auto &amp;x) { return x &lt;= 0; };\n    [[maybe_unused]] auto t = *in++; // number of testcases (unused)\n    for(; in != in_last; ++in) { // resync \"in\" after copy_n operation\n        const auto n = *in++, k = *in++; // students and threshold\n        auto c = std::vector&lt;int&gt;{}; // storage\n        std::copy_n(in, n, filter_inserter(c, fearly)); // copy input\n        *out++ = canceled[c.size() &lt; static_cast&lt;unsigned int&gt;(k)];\n    }\n    return 0;\n}\n</code></pre> <p>GitHub: 13-angry-prof-reloaded/angry-prof-reloaded-03.cpp </p>"},{"location":"0140-angry-prof-again/","title":"The Angry Professor - Again","text":"<p>Title: Angry Professor Link: https://www.hackerrank.com/challenges/angry-professor </p>"},{"location":"0140-angry-prof-again/#adding-to-the-x_of-standard-family","title":"Adding to the \u201cx_of\u201d Standard Family","text":"<p>Let us remain with the \u201cAngry Professor\u201d and on a new second thought moment let us consider if we do not need our custom iterator at all. We have counted, partitioned and iterated, but we have missed the entire point. Our goal is to count we have \u201cat least k students of n\u201d, with <code>n</code> being the entire range, of course.</p> <p>And the standard library has three algorithms with the <code>_of_</code>, namely: <code>std::all_of</code>, <code>std::any_of</code> and <code>std::none_of</code>. It is obvious that as we needed, these algorithms can break out early if the condition that is being tested fails. Unfortunately they do not test for <code>n</code> elements or \u201cat least\u201d <code>n</code>.</p> <p>Let us roll our own <code>n_of</code>. Here is the main code skipping all SFINAE definitions we already know so well.</p> <pre><code>template&lt;typename I, typename F, typename = enable_if_n_of&lt;I, F&gt;&gt;\nauto\nn_of(I first, I last, ssize_t n, const F &amp;f, bool at_least = false) {\n    it_difftype&lt;I&gt; dist;\n    if constexpr (is_random_it_v&lt;I&gt;)\n        dist = std::abs(std::distance(first, last));\n\n    for(; n &gt;= at_least and first != last; ++first) {\n        if constexpr (is_random_it_v&lt;I&gt;)\n            if ((unsigned) dist-- &lt; n)\n                break;\n\n        n -= static_cast&lt;bool&gt;(f(*first));\n    }\n    return not n;\n}\n</code></pre> <p>GitHub: 14-angry-prof-again/angry-prof-again-01.cpp:41:56 </p> <p>Because calculating the <code>std::distance</code> between <code>first</code> and <code>last</code> can be expensive for non RandomAccessIterator instances, we add an <code>if constexpr</code> guard, to only add the calculation, and later the optimization, for that type of iterators.</p> <p>The idea is that if the distance to the end is less than the amount of needed items to find <code>n</code> items, we can already break early out.</p> <p>The algorithm is of course simple: see if we have exactly <code>n</code> elements as determined by function <code>f</code>, a unary predicate returning something convertible to <code>bool</code>. Notice that we have a parameter <code>bool at_least = false</code>. If we set it to <code>true</code>, the algorithm will return <code>true</code> as soon as the n<sup>th</sup> element has been found. We do not care if more <code>true</code> matches could uncover more items, because we are only asking for \u201cat least\u201d <code>n</code> matches.</p> <p>Our problem can be solved as soon as we have enough, i.e., \u201cat least\u201d, students arriving early, If more arrive, the more the merrier, but it does not have any implication in deciding whether the class is canceled or held.</p> <p>If <code>at_least == false</code>, the algorithm will check more elements to see if more than \u201cexactly\u201d <code>n</code> elements are found and return <code>false</code> in that case.</p> <pre><code>        const auto early_students = n_of(c.begin(), c.end(), k, fearly, true);\n</code></pre> <p>GitHub: 14-angry-prof-again/angry-prof-again-01.cpp:71:71 </p> <p>And this is how we use it in our solution. Nice and easy, exactly as a standard library algorithm. The complete code is here.</p> <pre><code>#include &lt;array&gt; // std::array\n#include &lt;algorithm&gt; // std::copy_n, std::partition\n#include &lt;cmath&gt; // std::abs\n#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iterator&gt; // std::istream/ostream_iterator, std::back_inserter\n#include &lt;vector&gt; // std::vector\n#include &lt;type_traits&gt; // std::void_t, std::enable_if ...\n\n// get iterator value_type\ntemplate &lt;typename T&gt;\nusing it_type = typename std::iterator_traits&lt;T&gt;::value_type;\n\n// get iterator difference type\ntemplate &lt;typename T&gt;\nusing it_category = typename std::iterator_traits&lt;T&gt;::iterator_category;\n\ntemplate &lt;typename T&gt;\nusing it_difftype = typename std::iterator_traits&lt;T&gt;::difference_type;\n\n// Check if an iterator is a class/subclass of a given tag\ntemplate &lt;typename T, typename Tag&gt;\nconstexpr bool is_it_tag_v = std::is_base_of_v&lt;Tag, it_category&lt;T&gt;&gt;;\n\ntemplate &lt;typename I&gt;\nconstexpr bool is_input_it_v = is_it_tag_v&lt;I, std::input_iterator_tag&gt;;\n\ntemplate &lt;typename I&gt;\nconstexpr bool is_random_it_v = is_it_tag_v&lt;I, std::random_access_iterator_tag&gt;;\n\n// check function invocation and return type convertibility to bool\ntemplate&lt;typename I, typename F&gt;\nconstexpr bool is_f_v =\n    std::is_convertible_v&lt;std::invoke_result_t&lt;F, it_type&lt;I&gt;&gt;, bool&gt;;\n\n// check if input iterator and function can be called and delivers as expected\ntemplate&lt;typename I, typename F&gt;\nusing enable_if_n_of =\n    std::enable_if_t&lt;(is_input_it_v&lt;I&gt; or is_random_it_v&lt;I&gt;) and is_f_v&lt;I, F&gt;&gt;;\n\n// n_of implementation\ntemplate&lt;typename I, typename F, typename = enable_if_n_of&lt;I, F&gt;&gt;\nauto\nn_of(I first, I last, ssize_t n, const F &amp;f, bool at_least = false) {\n    it_difftype&lt;I&gt; dist;\n    if constexpr (is_random_it_v&lt;I&gt;)\n        dist = std::abs(std::distance(first, last));\n\n    for(; n &gt;= at_least and first != last; ++first) {\n        if constexpr (is_random_it_v&lt;I&gt;)\n            if ((unsigned) dist-- &lt; n)\n                break;\n\n        n -= static_cast&lt;bool&gt;(f(*first));\n    }\n    return not n;\n}\n\n// Main\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto in_last = std::istream_iterator&lt;int&gt;{}; // input iterator end\n    auto out = std::ostream_iterator&lt;std::string&gt;{std::cout, \"\\n\"}; // out iter\n    constexpr auto canceled = std::array{\"NO\", \"YES\"};\n    const auto fearly = [](const auto &amp;x) { return x &lt;= 0; };\n    [[maybe_unused]] auto t = *in++; // number of testcases (unused)\n    for(; in != in_last; ++in) { // resync \"in\" after copy_n operation\n        const auto n = *in++, k = *in++; // students and threshold\n        auto c = std::vector&lt;int&gt;{}; // storage\n        std::copy_n(in, n, std::back_inserter(c)); // copy input\n        const auto early_students = n_of(c.begin(), c.end(), k, fearly, true);\n        *out++ = canceled[not early_students];\n    }\n    return 0;\n}\n</code></pre> <p>GitHub: 14-angry-prof-again/angry-prof-again-01.cpp </p>"},{"location":"0140-angry-prof-again/#following-the-stl-path","title":"Following The STL Path","text":"<p>https://cppreference.com  gives us a nice indication as to how <code>std::all_of</code>, and family members, may be implemented and that is by using the <code>std::find_if</code> family. The <code>_of</code> algorithms will test if <code>first</code> algorithm made it to the <code>last</code>, or if it did not to return the <code>bool</code> value that it is expected. For example.</p> cppreference potential implementation of any_of<pre><code>template&lt;class InputIt, class UnaryPred&gt;\nconstexpr bool any_of(InputIt first, InputIt last, UnaryPred p)\n{\n    return std::find_if(first, last, p) != last;\n}\n</code></pre> <p>Let us go that route too by creating an <code>find_n_if</code> algorithm. This will be the engine then of our <code>n_of</code> algorithm.</p> <pre><code>// find_n_if implementation\ntemplate&lt;typename I, typename F, typename = enable_if_n_of&lt;I, F&gt;&gt;\nauto\nfind_n_if(I first, I last, ssize_t n, const F &amp;f, bool at_least = false) {\n    it_difftype&lt;I&gt; dist;\n    if constexpr (is_random_it_v&lt;I&gt;)\n        dist = std::abs(std::distance(first, last));\n\n    for(; n &gt;= at_least and first != last; ++first) {\n        if constexpr (is_random_it_v&lt;I&gt;)\n            if ((unsigned) dist-- &lt; n)\n                break;\n\n        n -= static_cast&lt;bool&gt;(f(*first));\n    }\n    // The loop may have been interrupted early. If n is not 0, either not\n    // enough items were found or too many (at least if fase) =&gt; return last\n    return n ? last : first;\n}\n\n// n_of implementation\ntemplate&lt;typename I, typename F, typename = enable_if_n_of&lt;I, F&gt;&gt;\nauto\nn_of(I first, I last, ssize_t n, const F &amp;f, bool at_least = false) {\n    return find_n_if(first, last, n, f, at_least) != last;\n}\n</code></pre> <p>GitHub: 14-angry-prof-again/angry-prof-again-02.cpp:40:65 </p> <p>It would seem as if we only had to rename <code>n_of</code> to <code>find_n_if</code> and then get a new <code>n_of</code> written that simply checks if the end of the range has been reached. But how the return value in <code>find_n_if</code> is calculated has changed.</p> <pre><code>    // The loop may have been interrupted early. If n is not 0, either not\n    // enough items were found or too many (at least if fase) =&gt; return last\n    return n ? last : first;\n</code></pre> <p>GitHub: 14-angry-prof-again/angry-prof-again-02.cpp:55:57 </p> <p>Had we added no optimization checking for the remaining distance to the end for RandomAccessIterator types, we could simply return the last position reached by <code>first</code>. The same happens when it comes to finding exactly <code>n</code> elements, because the loop can be interrupted early. In both cases <code>first</code> is never incremented to make it to the end of the range.</p> <p>But the return value of <code>find_n_if</code> has to be <code>last</code> if not enough (or exactly) elements have been found. Hence the extra check to return the current position of <code>first</code> on success, delivering the position to the caller or actually <code>last</code> if some elements could have still been found but the loop was interrupted early.</p> <p>Obviously and because the parameters for both functions are the same, the same set of SFINAE constraints apply to both.</p> <p>Let us get it over with this challenge with a last \u201ccomplete source code\u201d entry.</p> <pre><code>#include &lt;array&gt; // std::array\n#include &lt;algorithm&gt; // std::copy_n, std::partition\n#include &lt;cmath&gt; // std::abs\n#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iterator&gt; // std::istream/ostream_iterator, std::back_inserter\n#include &lt;vector&gt; // std::vector\n#include &lt;type_traits&gt; // std::void_t, std::enable_if ...\n\n// get iterator value_type\ntemplate &lt;typename T&gt;\nusing it_type = typename std::iterator_traits&lt;T&gt;::value_type;\n\n// get iterator difference type\ntemplate &lt;typename T&gt;\nusing it_category = typename std::iterator_traits&lt;T&gt;::iterator_category;\n\ntemplate &lt;typename T&gt;\nusing it_difftype = typename std::iterator_traits&lt;T&gt;::difference_type;\n\n// Check if an iterator is a class/subclass of a given tag\ntemplate &lt;typename T, typename Tag&gt;\nconstexpr bool is_it_tag_v = std::is_base_of_v&lt;Tag, it_category&lt;T&gt;&gt;;\n\ntemplate &lt;typename I&gt;\nconstexpr bool is_input_it_v = is_it_tag_v&lt;I, std::input_iterator_tag&gt;;\n\ntemplate &lt;typename I&gt;\nconstexpr bool is_random_it_v = is_it_tag_v&lt;I, std::random_access_iterator_tag&gt;;\n\n// check function invocation and return type convertibility to bool\ntemplate&lt;typename I, typename F&gt;\nconstexpr bool is_f_v =\n    std::is_convertible_v&lt;std::invoke_result_t&lt;F, it_type&lt;I&gt;&gt;, bool&gt;;\n\n// check if input iterator and function can be called and delivers as expected\ntemplate&lt;typename I, typename F&gt;\nusing enable_if_n_of =\n    std::enable_if_t&lt;(is_input_it_v&lt;I&gt; or is_random_it_v&lt;I&gt;) and is_f_v&lt;I, F&gt;&gt;;\n\n// find_n_if implementation\ntemplate&lt;typename I, typename F, typename = enable_if_n_of&lt;I, F&gt;&gt;\nauto\nfind_n_if(I first, I last, ssize_t n, const F &amp;f, bool at_least = false) {\n    it_difftype&lt;I&gt; dist;\n    if constexpr (is_random_it_v&lt;I&gt;)\n        dist = std::abs(std::distance(first, last));\n\n    for(; n &gt;= at_least and first != last; ++first) {\n        if constexpr (is_random_it_v&lt;I&gt;)\n            if ((unsigned) dist-- &lt; n)\n                break;\n\n        n -= static_cast&lt;bool&gt;(f(*first));\n    }\n    // The loop may have been interrupted early. If n is not 0, either not\n    // enough items were found or too many (at least if fase) =&gt; return last\n    return n ? last : first;\n}\n\n// n_of implementation\ntemplate&lt;typename I, typename F, typename = enable_if_n_of&lt;I, F&gt;&gt;\nauto\nn_of(I first, I last, ssize_t n, const F &amp;f, bool at_least = false) {\n    return find_n_if(first, last, n, f, at_least) != last;\n}\n\n// Main\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto in_last = std::istream_iterator&lt;int&gt;{}; // input iterator end\n    auto out = std::ostream_iterator&lt;std::string&gt;{std::cout, \"\\n\"}; // out iter\n    constexpr auto canceled = std::array{\"NO\", \"YES\"};\n    const auto fearly = [](const auto &amp;x) { return x &lt;= 0; };\n    [[maybe_unused]] auto t = *in++; // number of testcases (unused)\n    for(; in != in_last; ++in) { // resync \"in\" after copy_n operation\n        const auto n = *in++, k = *in++; // students and threshold\n        auto c = std::vector&lt;int&gt;{}; // storage\n        std::copy_n(in, n, std::back_inserter(c)); // copy input\n        const auto early_students = n_of(c.begin(), c.end(), k, fearly, true);\n        *out++ = canceled[not early_students];\n    }\n    return 0;\n}\n</code></pre> <p>GitHub: 14-angry-prof-again/angry-prof-again-02.cpp </p>"},{"location":"0150-running-median/","title":"Running Median","text":"<p>Title: Find the Running Median Link: https://www.hackerrank.com/challenges/find-the-running-median/ </p>"},{"location":"0150-running-median/#a-set-is-not-a-set","title":"A Set is not a \"Set","text":"<p>The problem gives us first an int. This is the number of values to read. After we read each value, we have a \u201cset\u201d of integer values and we have to print the running median. I.e,: the value of the int located in the middle (of the sorted \u201cset\u201d) for an odd count of integers and the mean of the two values in the middle if the count is even.</p> <p>Given that the problem is specifically talking about a \u201cset\u201d, let us use an <code>std::set</code> to solve the problem. It is ideal because the \u201cset\u201d is always sorted. We will just insert the value and look for the values in the middle.</p> <pre><code>#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iomanip&gt; // std::setprecision, ...\n#include &lt;iterator&gt; // std::istream/ostream_iterator, std::back_inserter\n#include &lt;set&gt; // std::set\n\n// Main\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto out = std::ostream_iterator&lt;double&gt;{std::cout, \"\\n\"}; // out iter\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(1);\n    auto s = std::set&lt;int&gt;{};\n    for(auto t = *in++; t--;) { // number of elements until exhausted\n        s.insert(*in++);\n        auto left = static_cast&lt;int&gt;((s.size() - 1) / 2);\n        double val = static_cast&lt;double&gt;(*std::next(s.begin(), left));\n        if (not (s.size() % 2))\n            val = (val + *std::next(s.begin(), left + 1)) / 2;\n        *out++ = val;\n    }\n    return 0;\n}\n</code></pre> <p>GitHub: 15-running-median/running-median-01.cpp </p> <p>Easy, compact, down to 21 lines with no major efforts and it passes our local basic test.</p> <ul> <li> <p>We insert the next value</p> </li> <li> <p>We get an iterator to the middle of the <code>std::set</code> (already auto-sorted) and the value located there</p> </li> <li> <p>If the size even we get another iterator to the next value, add it to our previous value and calculate the average</p> </li> <li> <p>Output.</p> </li> </ul> <p>The devil, as always, is in the details. We have a second test with more integer values that fails to pass.</p> <pre><code>$ make 01 test01 | less\nCreating build dir\ng++ -std=c++17 -o build/running-median-01 running-median-01.cpp\n./build/running-median-01 &lt; running-median.input01 &gt; /tmp/tmp.g7s4f2Zt3o.output\nSolution 01: FAILED\n---- Expected Output Begin ----\n...\n---- Expected Output End ----\n---- Output Being ----\n...\n---- Output End ----\n---- Diff Begin ----\n--- running-median.output01\n+++ /tmp/tmp.g7s4f2Zt3o.output\n@@ -480,41 +480,36 @@\n 51079.5\n 51055.0\n 51079.5\n+51079.5\n 51055.0\n ...\n</code></pre> <p>And the failure has to be given to the use of \u201cset\u201d in the problem description. The input can, and will, have repeated values. What was declared to be a \u201cset\u201d is actually not a set.</p>"},{"location":"0150-running-median/#a-multiset-is-a-set","title":"A MultiSet is a \"Set","text":"<p>The standard library is generous and in this case offers us an <code>std::multiset</code> that directly fulfills our requirements. It is a \u201cset\u201d that can host multiple repeated keys and it is still sorted.</p> <pre><code>#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iomanip&gt; // std::setprecision, ...\n#include &lt;iterator&gt; // std::istream/ostream_iterator, std::back_inserter\n#include &lt;set&gt; // std::multiset\n\n// Main\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto out = std::ostream_iterator&lt;double&gt;{std::cout, \"\\n\"}; // out iter\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(1); // fixed 1 decimal\n    auto s = std::multiset&lt;int&gt;{}; // allow repeated keys\n    for(auto t = *in++; t--;) { // number of elements until exhausted\n        s.insert(*in++); // add to multi-set\n        auto left = static_cast&lt;int&gt;((s.size() - 1) / 2); // pos of left val\n        auto itleft = std::next(s.begin(), left); // iterator to left median val\n        auto outval = static_cast&lt;double&gt;(*itleft);\n        if (not (s.size() % 2)) // median is avg of 2 values if size is even\n            outval = (outval + *(++itleft)) / 2;\n        *out++ = outval;\n    }\n    return 0;\n}\n</code></pre> <p>GitHub: 15-running-median/running-median-02.cpp </p> <p>We have added 1 line of code to keep a reference to the <code>itleft</code> iterator. This is to optimize the <code>std::next(s.begin, distance)</code> calls. We had two of them and we only have one. The second can be a simple <code>*(*++itleft)</code> to get the next position and dereference it.</p> <p>This passes the basic local test and the additional <code>test01</code> item with repeated values. But once again this is not the full solution. This code will fail in many test cases with a \u201cTime Limit Exceeded\u201d message.</p>"},{"location":"0150-running-median/#the-floating-iterator-in-the-middle","title":"The Floating Iterator in the Middle","text":"<p>Even if we have optimized away one of the <code>std::next</code> calls the other one is terribly expensive. It may not seem so, but the iterator of an <code>std::multiset</code> (and <code>std::set</code> too) is a BidirectionalIterator and cannot be propelled to our required position with the operator <code>+=</code>. It only supports <code>++</code> and <code>--</code>. This means that <code>std::next</code> behind the scenes has to execute <code>++</code> from the beginning for as many times as we want to move the iterator.</p> <p>For a local case that is not a problem, but we may be talking of sets hosting millions of elements.</p> <p>The solution is clear, we need an iterator that keeps floating in the middle of the set after we insert a value. Sometimes it will have to move 1 position forward or backwards after we insert and change the size of the set to be \u201codd\u201d or \u201ceven\u201d. But it will be a single <code>++</code> or <code>--</code> operation.</p> <p>We are changing the complexity of that bit from <code>O(n)</code> to <code>O(1)</code>, i.e., from linear to constant time (and sometimes we will not even move the iterator). The other complexity factors in the problem remain constant.</p> <pre><code>#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iomanip&gt; // std::setprecision, ...\n#include &lt;iterator&gt; // std::istream/ostream_iterator, std::back_inserter\n#include &lt;set&gt; // std::multiset\n\n// Main\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto out = std::ostream_iterator&lt;double&gt;{std::cout, \"\\n\"}; // out iter\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(1); // fixed 1 decimal\n    auto s = std::multiset&lt;int&gt;{}; // allow repeated keys\n    auto rmed = s.end(); // running median iterator\n    for(auto t = *in++, odd = 1, val = 0, rval = 0; t--; odd = not odd) {\n        s.insert(val = *in++); // add to multi-set and store in \"val\"\n        rmed = (val &gt;= rval) ? std::next(rmed, odd) : std::prev(rmed, not odd);\n        auto outval = static_cast&lt;double&gt;(rval = *rmed); // rval for next round\n        if (not odd) // median is avg of 2 values if size is even\n            outval = (outval + static_cast&lt;double&gt;(*std::next(rmed))) / 2;\n        *out++ = outval;\n    }\n    return 0;\n}\n</code></pre> <p>GitHub: 15-running-median/running-median-03.cpp </p> <p>Wow! Even adding that logic we have kept the same line count: <code>22</code>. Our trick is to use initially <code>auto rmed = s.end()</code> to get the iterator we will float around the middle point. Choosing <code>s.end</code> is just cosmetic to indicate we just need an iterator and not really the value behind it. At that point in time we could also have gone for <code>s.begin()</code>. With an empty <code>std::multiset</code> both point to the same position.</p> <p>The key is the logic to keep the iterator afloat.</p> <pre><code>        rmed = (val &gt;= rval) ? std::next(rmed, odd) : std::prev(rmed, not odd);\n</code></pre> <p>GitHub: 15-running-median/running-median-03.cpp:16:16 </p> <p>The one-liner could have been written as:</p> Unfolded Iterator Logic<pre><code>if (val &gt;= rval)\n    if (odd)\n        rmed = std::next(rmed);\nelse if (not odd)\n        rmed = std::prev(rmed);\n</code></pre> <p>Translated: if the new inserted val is equal or greater than the midpoint we currently val (<code>rval =&gt; running val</code>) and if the insertion has made the size of the container to be <code>odd</code>, move the iterator to the right (forward) one position. Else and if the size if now <code>even</code>, move the iterator one position to the left (backwards).</p> <p>Yes, we used old tricks such as assignments when a parameter is passed to save a couple of lines. Example: <code>s.insert(val = *in++);</code>. In this case <code>val</code> is assigned the value of the dereferenced iterator and this value is also the parameter for <code>insert</code>. The instantiation of the <code>for</code> loop has also gotten a bit more of noise.</p>"},{"location":"0150-running-median/#not-all-containers-can-be-floated","title":"Not All Containers Can Be Floated","text":"<p>It would seem that if we apply the \u201cFloating Iterator\u201d technique to another container we would also succeed. But we will not. See it here applied to an <code>std::list</code>, that also has an \u201cBidirectionalIterator\u201d.</p> <pre><code>#include &lt;algorithm&gt; // std::cout/cin\n#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iomanip&gt; // std::setprecision, ...\n#include &lt;iterator&gt; // std::istream/ostream_iterator, std::back_inserter\n#include &lt;list&gt; // std::list\n\n// Main\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto out = std::ostream_iterator&lt;double&gt;{std::cout, \"\\n\"}; // out iter\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(1); // fixed 1 decimal\n    auto l = std::list&lt;int&gt;{}; // allow repeated keys\n    auto rmed = l.begin(); // running median iterator, ref to end\n    auto inspos = rmed;\n    for(auto t = *in++, odd = 1, rval = 0; t--; odd = not odd) {\n        auto val = *in++; // fetch next val\n        if (val &gt;= rval) {\n            auto fpos = [val](auto x) { return val &lt;= x; }; // to find insert pos\n            inspos = std::find_if(std::next(rmed), l.end(), fpos); // find the pos\n        } else {\n            auto fpos = [val](auto x) { return val &lt; x; }; // to find insert pos\n            inspos = std::find_if(l.begin(), rmed, fpos); // find the pos\n        }\n        l.insert(inspos, val); // insert val just before inspos\n        rmed = (val &gt;= rval) ? std::next(rmed, odd) : std::prev(rmed, not odd);\n        auto outval = static_cast&lt;double&gt;(rval = *rmed);\n        if (not odd) // median is avg of 2 values if size is even\n            outval = (outval + static_cast&lt;double&gt;(*std::next(rmed))) / 2;\n        *out++ = outval;\n    }\n    return 0;\n}\n</code></pre> <p>GitHub: 15-running-median/running-median-04.cpp </p> <p>The motto here is: \u201cFind the Difference\u201d. And the difference is in the application of <code>std::find_if</code> to locate the insertion point. Where our <code>std::multiset</code> handled the insertion in the background, <code>std::list</code> needs that we find the insertion point.</p> <p>The complexity of insertion in <code>std::multiset</code> instances is <code>O(log n)</code> and not linear, because the implementation is done with \u201cred-black trees\u201d or a similar structure.</p> <p>In our code above we have tried to reduce the <code>O(n)</code> complexity, by only looking for the insertion point on the half before/after the floating iterator. But that will not change things by an order of magnitude.</p> <p>All this means this solution will fail due to the complexity.</p>"},{"location":"0150-running-median/#summary","title":"Summary","text":"<p>Let us summarize it here with a well-known saying: \u201cComplexity killed the cat\u201d. We had to move from an initial <code>std::set</code> to an <code>std::multiset</code> to account for multiple repeated keys and had to \u201cinvent\u201d a floating iterator to triumph over the complexity requirements of the problem.</p> <p>But as we have proven, the \u201cFloating Iterator\u201d is not the panacea that will cure all evil. An <code>std::list</code> with its Bidirectional Iterator and linear nature (it is a list) cannot achieve the complexity target.</p> <p>Let us see what the next chapter will bring to us.</p>"},{"location":"0160-running-median-ii/","title":"Running Median II","text":"<p>Title: Find the Running Median Link: https://www.hackerrank.com/challenges/find-the-running-median/ </p>"},{"location":"0160-running-median-ii/#the-complexity-conundrum","title":"The Complexity Conundrum","text":"<p>As we saw with the previous examples, \u201cComplexity Killed The Cat\u201d, because as soon as we did not have an efficient insertion method to keep the container sorted, even our Floating Iterator approach was not enough. Even if it reduced the operations to calculate the running media to a single iterator increment/decrement operation and not always.</p> <p>The only other way to reduce complexity may be to look at a container hosting a \u201cRandomAccessIterator\u201d. This is the only iterator that can \u201crandomly\u201d jump and therefore must not be incremented <code>n</code> times (expensive) to reach the expected destination. A single operation suffices.</p> <p>Let us give <code>std::vector&lt;T&gt;</code> a try. The problem that one can foresee is clear:</p> <ul> <li> <p>An insertion is expensive.</p> </li> <li> <p>Re-allocations and copies to fit new and old elements in a contiguous array.</p> </li> </ul> <p>Here is the code and it beats all test cases, when not using <code>CASE1</code>.</p> <pre><code>#include &lt;algorithm&gt; // std::cout/cin\n#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iomanip&gt; // std::setprecision, ...\n#include &lt;iterator&gt; // std::istream/ostream_iterator, std::back_inserter\n#include &lt;vector&gt; // std::vector\n\n// Main\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto out = std::ostream_iterator&lt;double&gt;{std::cout, \"\\n\"}; // out iter\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(1); // fixed 1 decimal\n    auto v = std::vector&lt;int&gt;{};\n    for(auto t = *in++, odd = 1; t--; odd = not odd) {\n        auto val = *in++; // fetch next val\n#ifdef CASE1\n        const auto fgreater = [&amp;val](const auto &amp;x) { return val &gt; x; };\n        auto idx = std::find_if(v.begin(), v.end(), fgreater);\n#else\n        constexpr auto fgreater = std::greater&lt;int&gt;{};\n        auto idx = std::lower_bound(v.begin(), v.end(), val, fgreater);\n#endif\n        v.insert(idx, val); // insert val just before idx\n        auto left = static_cast&lt;int&gt;((v.size() - 1) / 2);\n        auto outval = static_cast&lt;double&gt;(v[left]);\n        if (not odd) // median is avg of 2 values if size is even\n            outval = (outval + static_cast&lt;double&gt;(v[left + 1])) / 2;\n        *out++ = outval;\n    }\n    return 0;\n}\n</code></pre> <p>GitHub: 16-running-median-ii/running-median-ii-01.cpp </p> <p>As it was the case with the <code>std::list</code> implementation we need to look for the insertion point to keep things always sorted. The \u201cgood case\u201d is to use <code>std::lower_bound</code>. If you wonder why that is the case, it is because it uses the goodies from RandomAccessIterator to gives us the insertion point by repeatedly partitioning the range, until it finds its target.</p> <p>The \u201cbad case\u201d mimics what we did with <code>std::list</code> by using <code>std::find</code> to get the insertion point. It works but it is again so expensive that complexity-limited test cases will be failed.</p> <p>After that the contiguous nature of <code>std::vector</code> offers us another advantage: we do not need to float an iterator along the running median. Using the <code>operator []</code> is enough to get to the running media point in just a single operation and to the next position in cases where the size is even (after the insertion).</p> <p>Having to move items to make place for the inserted element and to reallocate and copy elements if needed is not enough to kill the benefits of the low complexity of the RandomAccessIterator that <code>std::vector</code> features.</p>"},{"location":"0160-running-median-ii/#living-on-the-heap","title":"Living On The Heap","text":"<p>This is not a matter of a second though and also not having second thoughts about the previous implementations. The breadcrumbs leading to this problem on HackerRank show this: \u201cData Structures &gt; Heap &gt; Find the Running Median\u201d. It may well be that we missed the entire point of the challenge by thinking too much outside of the box with our <code>std::multiset</code> solution and focusing then on the complexity with the additional <code>std::vector</code> approach.</p> <p>The Heap-Wish is fulfilled with a new <code>std::priority_queue</code> implementation.</p> <pre><code>#include &lt;functional&gt; // std::greater\n#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iomanip&gt; // std::setprecision, ...\n#include &lt;iterator&gt; // std::istream/ostream_iterator, std::back_inserter\n#include &lt;queue&gt; // std::priority_queue\n#include &lt;vector&gt; // std::vector\n\n// Main\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto out = std::ostream_iterator&lt;double&gt;{std::cout, \"\\n\"}; // out iter\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(1); // fixed 1 decimal\n    auto ql = std::priority_queue&lt;int&gt;{}; // left heap / right heap (inverted)\n    auto qr = std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt;{};\n    for(auto t = *in++, odd = 0; t--; odd = not odd) {\n        odd ? ql.push(*in++)    : qr.push(*in++);\n        odd ? qr.push(ql.top()) : ql.push(qr.top());\n        odd ? ql.pop()          : qr.pop();\n        auto rmed = static_cast&lt;double&gt;(ql.top());\n        if (odd) // was odd, we made it even\n            rmed = (rmed + static_cast&lt;double&gt;(qr.top())) / 2;\n        *out++ = rmed;\n    }\n    return 0;\n}\n</code></pre> <p>GitHub: 16-running-median-ii/running-median-ii-02.cpp </p> <p>The queue acts like a heap, keeping always the largest element at the top. Unless, of course, a comparison function like <code>std::greater&lt;T&gt;</code> is given to keep the minimum element at the top.</p> <p>Combining a left heap (max-at-the-top) and a right heap (min-at-the-top) we can simulate the Floating Iterator approach, because we have direct access to the elements that allow us to calculate the running median.</p> <pre><code>        odd ? ql.push(*in++)    : qr.push(*in++);\n        odd ? qr.push(ql.top()) : ql.push(qr.top());\n        odd ? ql.pop()          : qr.pop();\n</code></pre> <p>GitHub: 16-running-median-ii/running-median-ii-02.cpp:17:19 </p> <p>These three lines are the key. Push to one heap, depending on parity, and move (<code>top</code> + <code>pop</code>) to the other heap to keep them balanced (in \u201codd\u201d cases the left heap has one element more as the right heap)</p> <p>The one-liners are an \u201codd\u201d construction with the formatting showing that we perform the same operations during each round, but with the roles of the heaps swapped. We would ideally use polymorphism to avoid having to know on which heap we operate. However, <code>std::priority_queue&lt;int&gt;</code> and its counterpart <code>std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt;</code> are different types. And we are not in the business of using <code>void *</code> to duck types.</p>"},{"location":"0160-running-median-ii/#type-erasure-polymorphism","title":"Type Erasure Polymorphism","text":"<p>What we need is to create our own inheritance chain to make the types polymorphic, i.e., create a wrapper with templates that mimic the needed interface and then create our templated \u201csubclasses\u201d. This is called Type Erasure, although nobody is erasing actually anything. The type is being hidden behind another type. This new type does usually present the same interface, but it can actually adapt interfaces effectively mixing real different types. Our types are only different because of the comparison function, <code>std::less</code> vs <code>std::greater</code>. For all intent and purposes they are polymorphic and we use Type Erasure to present them as such.</p> <pre><code>// Type Erasure Idiom for the Heap\ntemplate&lt;typename T&gt;\nstruct Heap {\n    virtual ~Heap() = default;\n\n    auto *get_basepointer() { return this; }\n\n    // abstract interface\n    virtual void push(const T &amp;) = 0;\n    virtual T top() const = 0;\n    virtual void pop() = 0;\n    virtual size_t size() const = 0;\n};\n\ntemplate&lt;typename T, template &lt;typename&gt; typename Comp = std::less&gt;\nstruct MyHeap : Heap&lt;T&gt; {\n    using PrioQ = std::priority_queue&lt;T, std::vector&lt;T&gt;, Comp&lt;T&gt;&gt;;\n    PrioQ m_prioq;\n\n    void push(const T &amp;x) override { m_prioq.push(x); }\n    T top() const override { return m_prioq.top(); }\n    void pop() override { m_prioq.pop(); }\n    size_t size() const override { return m_prioq.size(); }\n};\n</code></pre> <p>GitHub: 16-running-median-ii/running-median-ii-03.cpp:8:32 </p> <p>The only difference with regards to usual implementations is that the base class takes a template parameter <code>T</code>. That is to avoid having to specify the type taken by <code>push</code> and returned by <code>top</code>. Luckily we can directly calculate <code>T</code> in the <code>MyHeap</code> implementation, by looking at <code>PrioQ::value_type</code>. Both our heaps use the same <code>T</code>, and <code>int</code>, and will therefore be subclasses of our <code>Heap&lt;T&gt;</code> abstract base class. Notice that we have there a <code>get_basepointer</code> method, so that any subclass can get a pointer to <code>Heap&lt;T&gt;</code> to work to easily work with polymorphism.</p> <pre><code>    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(1); // fixed 1 decimal\n    auto ql = MyHeap&lt;int&gt;{}; // left heap (max at top)\n    auto qr = MyHeap&lt;int, std::greater&gt;{}; // right heap (min at top)\n    auto *qlp = ql.get_basepointer(), *qrp = qr.get_basepointer();\n    for(auto t = *in++; t--; std::swap(qlp, qrp)) {\n        qlp-&gt;push(*in++); // push to get it sorted\n        qrp-&gt;push(qlp-&gt;top()); // balance to other side moving top\n        qlp-&gt;pop(); // complete move by removing the moved value\n        auto rmed = static_cast&lt;double&gt;(qrp-&gt;top()); // side we really pushed to\n        if (qlp-&gt;size() == qrp-&gt;size()) // same size -- use other side too\n            rmed = (rmed + static_cast&lt;double&gt;(qlp-&gt;top())) / 2;\n        *out++ = rmed;\n    }\n</code></pre> <p>GitHub: 16-running-median-ii/running-median-ii-03.cpp:38:50 </p> <p>We create the heaps and get the pointers to them. The same <code>auto</code> allows us to get the pointer for both because we are getting a pointer to <code>Heap&lt;int&gt;</code>, i.e.: the same type. This is where polymorphism starts to show up. As it does in the <code>for</code> loop where we use <code>std::swap(qlp, qrp)</code>, to swap the pointers in the variables. Were they not compatible, we could not do that.</p> <p>The algorithm operates now without knowing if we are in an <code>odd</code> or <code>even</code> case and simply pushes to one heap, sorting the values, and the balances whatever is at the top to the other side. Instead of keeping tabs with the parity of the count, we simply compare the size of the polymorphic queues to know if we need just one value for the running median or the average of two.</p> <p>This solution, as it previous non-polymorphic implementation, passes all the tests. Mission accomplished.</p> <pre><code>#include &lt;functional&gt; // std::greater\n#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iomanip&gt; // std::setprecision, ...\n#include &lt;iterator&gt; // std::istream/ostream_iterator\n#include &lt;queue&gt; // std::priority_queue\n#include &lt;vector&gt; // std::vector\n\n// Type Erasure Idiom for the Heap\ntemplate&lt;typename T&gt;\nstruct Heap {\n    virtual ~Heap() = default;\n\n    auto *get_basepointer() { return this; }\n\n    // abstract interface\n    virtual void push(const T &amp;) = 0;\n    virtual T top() const = 0;\n    virtual void pop() = 0;\n    virtual size_t size() const = 0;\n};\n\ntemplate&lt;typename T, template &lt;typename&gt; typename Comp = std::less&gt;\nstruct MyHeap : Heap&lt;T&gt; {\n    using PrioQ = std::priority_queue&lt;T, std::vector&lt;T&gt;, Comp&lt;T&gt;&gt;;\n    PrioQ m_prioq;\n\n    void push(const T &amp;x) override { m_prioq.push(x); }\n    T top() const override { return m_prioq.top(); }\n    void pop() override { m_prioq.pop(); }\n    size_t size() const override { return m_prioq.size(); }\n};\n\n// Main\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto out = std::ostream_iterator&lt;double&gt;{std::cout, \"\\n\"}; // out iter\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(1); // fixed 1 decimal\n    auto ql = MyHeap&lt;int&gt;{}; // left heap (max at top)\n    auto qr = MyHeap&lt;int, std::greater&gt;{}; // right heap (min at top)\n    auto *qlp = ql.get_basepointer(), *qrp = qr.get_basepointer();\n    for(auto t = *in++; t--; std::swap(qlp, qrp)) {\n        qlp-&gt;push(*in++); // push to get it sorted\n        qrp-&gt;push(qlp-&gt;top()); // balance to other side moving top\n        qlp-&gt;pop(); // complete move by removing the moved value\n        auto rmed = static_cast&lt;double&gt;(qrp-&gt;top()); // side we really pushed to\n        if (qlp-&gt;size() == qrp-&gt;size()) // same size -- use other side too\n            rmed = (rmed + static_cast&lt;double&gt;(qlp-&gt;top())) / 2;\n        *out++ = rmed;\n    }\n    return 0;\n}\n</code></pre> <p>GitHub: 16-running-median-ii/running-median-ii-03.cpp </p>"},{"location":"0160-running-median-ii/#variant-pseudo-polymorphism","title":"Variant (Pseudo-)Polymorphism","text":"<p>The question is whether we really need polymorphism with C++17 or we can use modern facilities to achieve the same effect without resorting to tricks like creating our own hierarchy to achieve Type Erasure.</p> <p>We are only really interested in reaching the <code>push</code>, <code>top</code> and <code>top</code> methods of our heaps, the methods of the based <code>std::priority_queue</code> instances we use as heaps. Recall that when were addressing the \u201cTypes, Types, Types \u201d challenge, we resorted to using <code>std::variant</code>, a newcomer in C++17 described as a type-safe union that can therefore hold different types, always one at time.</p> <p>That is going to be our key cornerstone to implement the variant-polymorphism: we will have an <code>std::variant</code> holding the types of both heaps, the left one (max-at-the-top) and the right one (min-at-the-top). We will then have two variants, each holding an instance of the heaps and we will use them to push, balance, calculate the running media and then swap them as we did before. Without having to define a chain hierarchy to implement Type Erasure.</p> <pre><code>#include &lt;functional&gt; // std::greater\n#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iomanip&gt; // std::setprecision, ...\n#include &lt;iterator&gt; // std::istream/ostream_iterator, std::back_inserter\n#include &lt;queue&gt; // std::priority_queue\n#include &lt;variant&gt; // std::variant, std::visit\n#include &lt;vector&gt; // std::vector\n\n// Main\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto out = std::ostream_iterator&lt;double&gt;{std::cout, \"\\n\"}; // out iter\n    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(1); // fixed 1 decimal\n    using LHeap = std::priority_queue&lt;int&gt;;\n    using RHeap = std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt;&gt;;\n    using VHeap = std::variant&lt;LHeap, RHeap&gt;;\n    auto vql = VHeap{LHeap{}}, vqr = VHeap{RHeap{}};\n    const auto visitor = [&amp;in, &amp;out](auto &amp;&amp;ql, auto &amp;&amp;qr) {\n        ql.push(*in++); // push to get it sorted\n        qr.push(ql.top()); // balance to other side moving top\n        ql.pop(); // complete move by removing the moved value\n        auto rmed = static_cast&lt;double&gt;(qr.top()); // side we really pushed to\n        if (ql.size() == qr.size()) // same size -- use other side too\n            rmed = (rmed + static_cast&lt;double&gt;(ql.top())) / 2;\n        *out++ = rmed;\n    };\n    for(auto t = *in++; t--; std::swap(vql, vqr))\n        std::visit(visitor, vql, vqr);\n    return 0;\n}\n</code></pre> <p>GitHub: 16-running-median-ii/running-median-ii-04.cpp </p> <p>The only drawback in the code above, if we could say so, is that the push-balance-calculate has to be placed in a lambda expression. This goes into <code>std::visit</code>, the functionality that will feed our heaps to the algorithm. Using <code>std::visit</code> is the key, because it passes the type being held in the <code>std::variant</code> without forcing us to know it beforehand or using the index.</p> <p>Given that a lambda expression can declare its parameters to be of type <code>auto</code>, the combination is ideal.</p> <p>The algorithm is exactly the same as in the previous solution but no pointers are involved.</p>"},{"location":"0170-tree-traversal/","title":"Tree Traversal","text":"<p>Title: Tree: qqqqqqqPreorder Traversal Link: https://www.hackerrank.com/challenges/tree-preorder-traversal </p> <p>Although we refer above to the \u201cPreorder Traversal\u201d problem, there is actually an entire family of traversal problems: preorder, postorder, in-order, top-view order, height-of-a-tree, that we will be addressing with a single generic codebase. That is what the magic of conditional compilation can help us with.</p>"},{"location":"0170-tree-traversal/#the-standard-binary-tree-structure","title":"The Standard Binary Tree Structure","text":"<p>The problem as presented has to be solved by filling out a single function that receives a pre-constructed binary tree with the standard tree-pointer approach. This can be seen in the C++11 and C++14 editors, with nothing but the <code>main</code> function in the C++20 version. Remember that is the reason we chose to use Hackerrank problems: we could take on the entire problem, including the input and the output.</p> Tree Standard Structure<pre><code>class Node {\n    public:\n        int data;\n        Node *left;\n        Node *right;\n        Node(int d) {\n            data = d;\n            left = NULL;\n            right = NULL;\n        }\n};\n</code></pre> <p>Pointers and <code>NULL</code> values are going to be used for insertion, look-up and everything one may conceive. The questions being: do we really need pointers?, do we really need to define such a structure?.</p> <p>And considering we are using Modern C++ and C++17 the answer is: No. It is not that we are going to reinvent the wheel, because a tree can also be seen and manipulated as an array. That means this problem has been solved by many generations of coders. We are simply going to tackle it with the tools of the standard library and the presents of C++17, wherever possible.</p>"},{"location":"0170-tree-traversal/#a-flat-map-approach","title":"A flat map approach","text":"<p>The input goes from <code>1</code> to <code>n</code>, but we do not know in which order the integers are going to be be delivered and allocating up to <code>n</code> positions of memory is, obviously, a no-go. We are going to use a mapping structure to hold the <code>parent =&gt; children</code> relationship, i.e., <code>key =&gt; value</code>. We need no specific ordering just to keep a reference to the <code>root</code> value to know where to start our traversal.</p> <p>Let us see the bits holding the data of our tree.</p> <pre><code>class StdTree {\n    static constexpr auto NullTreeVal = int{};\n    using Children = std::pair&lt;int, int&gt;;\n    static constexpr auto NullChildren = Children{NullTreeVal, NullTreeVal};\n\n    std::unordered_map&lt;int, Children&gt; m_tree;\n    int m_root = NullTreeVal;\n</code></pre> <p>GitHub: 17-tree-traversal/tree-traversal-01.cpp:7:13 </p> <p>A binary tree has two children: left and right. That is why the <code>std::pair&lt;int, int&gt;</code> seems to be ideally suited to hold the values. We need a <code>NULL</code> equivalent value and given the lowest input value will be <code>1</code> we can use the default <code>int</code> value, that we get by using a default constructor.</p> <p>Every time we create a node we need <code>NULL</code> children and that is why create a static pair holding null-children.</p> <p>The real data is held in an <code>std::unordered_map&lt;int, Children&gt;</code>, with the addition of <code>int m_root</code>, our member attribute holding the top of the tree.</p> <p>This approach is giving us two major advantages over a standard tree structure:</p> <ul> <li> <p>No manual memory management. The <code>std::unordered_map</code> and the <code>std::pair</code> are doing all of it for us.</p> </li> <li> <p>If we ever wanted to quickly find out the values of the children of any given parent, we could deliver without having to first find out where that parent is located.</p> </li> </ul> <p>To insert in the tree we use a public and private interface, both methods with the same name, by simply using overloading. The public part:</p> <pre><code>    auto insert(int data) {\n        if (m_root != NullTreeVal) // root already defined?\n            return insert(data, m_root); // yes, insert\n\n        m_tree[m_root = data] = NullChildren; // set m_root with empty children\n    }\n</code></pre> <p>GitHub: 17-tree-traversal/tree-traversal-01.cpp:36:41 </p> <p>And the private overload.</p> <pre><code>    auto insert(int data, int &amp;node) {\n        auto &amp;child = data &lt; node ? m_tree[node].first : m_tree[node].second;\n        if (child == NullTreeVal) { // not in tree, add with empty children\n            m_tree[child = data] = NullChildren; // set target (left or right ref)\n            return;\n        }\n        insert(data, child); // already in tree, go deeper\n</code></pre> <p>GitHub: 17-tree-traversal/tree-traversal-01.cpp:15:21 </p>"},{"location":"0170-tree-traversal/#preorder-traversal","title":"Preorder Traversal","text":"<p>Having the tree structure in the hand we can solve our traversal problem. We are going to use the same private-public-overload approach and we of course manage the input and output using iterators. \u201cPreorder\u201d implies that we first visit the data of the node and, and then the left descendants. Once that is over we go for the right descendants. To easily access the left and right node we use a Structured Binding construct.</p> <p>We are using a recursive approach for clarity and because C++ compilers will perform tail call optimization when compiling for speed. I.e.: a recursive call will be changed to a jump to avoid adding new frames to the stack, what could end up in a stack overflow error.</p> <p>Here is the public interface</p> <pre><code>    auto preorder(const FVisit &amp;fvisit) { preorder(fvisit, m_root); }\n</code></pre> <p>GitHub: 17-tree-traversal/tree-traversal-01.cpp:43:43 </p> <p>And the private.</p> <pre><code>    using FVisit = const std::function&lt;void(int)&gt;;\n\n    auto preorder(const FVisit &amp;fvisit, int node) {\n        if (node == NullTreeVal)\n            return; // if empty ... will do nothing\n\n        const auto &amp;[left, right] = m_tree[node]; // get children\n        fvisit(node); // preorder ... out root\n        preorder(fvisit, left); // visit left\n        preorder(fvisit, right); // visit right\n    }\n</code></pre> <p>GitHub: 17-tree-traversal/tree-traversal-01.cpp:24:34 </p>"},{"location":"0170-tree-traversal/#our-standard-performance","title":"Our \u201cStandard\u201d Performance","text":"<p>We have been so far creating solutions to the problems using the standard library as much as possible and creating the tree structure with an <code>std::unordered_map</code> has been no exception. However, we have not asked ourselves if this improves the performance and if it does not, how much are we impacting that performance. We are, of course, profiting from nice construction and syntax and avoiding memory management.</p> <p>Let us therefore measure the performance of a pointer based tree vs our implementation. We will still add a virtual root, to slight simplify our code. I.e., we add an empty root at the top and all <code>insert</code> operations, including that of the real root, take place after the top virtual root.</p> <p>The methods that can take <code>const</code> get it and that means we remove the <code>operator []</code>. This is so because in maps that operator will add a value if key being sought is not present. In contrast, the method <code>at</code> will not.</p> <p>To measure performance we will use <code>std::chrono</code> to start an <code>std::chrono::steady_clock</code> and calculate the duration. We also copy all input values to an <code>std::vector</code> to be able to repeat the test and avoid microseconds measurements.</p> <p>Hence, the most important part is how we modify <code>main</code> to get the timing of our test.</p> <pre><code>// Main\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto out = std::ostream_iterator&lt;int&gt;{std::cout, \" \"}; // out iter\n    auto oerr = std::ostream_iterator&lt;double&gt;(std::cerr, \"\\n\");\n\n    auto reps = 1;\n#ifdef REPS\n    reps = REPS;\n#endif\n    auto t = *in++;\n    auto v = std::vector&lt;int&gt;(t);\n    auto vin = v.begin();\n    std::copy_n(in, t, vin); //\n\n    auto fout = [&amp;out](const auto &amp;x){ out = x; };\n    auto fakeout = [](const auto &amp;){};\n\n    auto start = std::chrono::steady_clock::now();\n\n    solution(vin, fout, t); // to match expected output\n    while(--reps)\n        solution(vin, fakeout, t); // extra rounds output nothing\n\n    auto stop = std::chrono::steady_clock::now();\n    auto elapsed_seconds = std::chrono::\n        duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(stop - start).count();\n    oerr = elapsed_seconds;\n    return 0;\n}\n</code></pre> <p>GitHub: 17-tree-traversal/tree-traversal-02.cpp:56:86 </p> <p>This is the structure we will keep for all tests. The <code>solution</code> function is simple and just loads the values and executes the traversal.</p> <pre><code>template &lt;typename I, typename F&gt;\nauto\nsolution(I in, F fout, int size) {\n    auto tree = StdTree{};\n    while(size--)\n        tree.insert(*in++);\n\n    tree.preorder(fout);\n}\n</code></pre> <p>GitHub: 17-tree-traversal/tree-traversal-02.cpp:46:54 </p> <p>The only other thing that really changes is the initialization of the tree with the virtual root and the initialization of a reference to where the real root will be stored.</p> <pre><code>    std::unordered_map&lt;int, Children&gt; m_tree{{NullTreeVal, NullChildren}};\n    const int &amp;m_root = m_tree.at(NullTreeVal).second; // ref 2 real root\n</code></pre> <p>GitHub: 17-tree-traversal/tree-traversal-02.cpp:16:17 </p> <p>The code of our <code>02</code> solution will be trying to match the performance of this pointer based code.</p> <pre><code>class PtrTree {\n    struct Node {\n        int m_data;\n        using NodePtr = Node *;\n        NodePtr left = nullptr, right = nullptr;\n        Node(int data) : m_data{data} {};\n        auto static create(int data) { return new Node{data}; }\n        ~Node() { delete left; delete right; }\n    };\n    using NodePtr = Node::NodePtr;\n    NodePtr m_root = nullptr;\n\n    auto insert(int data, NodePtr &amp;node) {\n        if(not node) {\n            node = Node::create(data);\n            return;\n        }\n        auto &amp;left_or_right = data &lt; node-&gt;m_data ? node-&gt;left : node-&gt;right;\n        insert(data, left_or_right);\n    }\n\n    using FVisit = std::function&lt;void(int)&gt;;\n\n    auto preorder(const FVisit &amp;fvisit, const NodePtr &amp;node) const {\n        if (not node)\n            return;\n\n        fvisit(node-&gt;m_data);\n        preorder(fvisit, node-&gt;left);\n        preorder(fvisit, node-&gt;right);\n    }\npublic:\n    auto insert(int data) { insert(data, m_root); }\n    auto preorder(const FVisit &amp;fvisit) const { preorder(fvisit, m_root); }\n\n    ~PtrTree() { delete m_root; }\n};\n</code></pre> <p>GitHub: 17-tree-traversal/tree-traversal-90.cpp:8:44 </p> <p>With <code>main</code> and <code>solution</code> being as presented above.</p>"},{"location":"0170-tree-traversal/#the-performance-war","title":"The Performance War","text":"<p>Not much of a war. Just take a look at the values executed with <code>10,000</code> repetitions of filling up the tree with values and executing the traversal.</p> <p>The standard code run (for the sake of brevity, parts of the actual output are left out)</p> <pre><code>$ make 02 test05 rep10000\ng++ -std=c++17 -DREPS=10000 -o build/tree-traversal-02 tree-traversal-02.cpp\n2.89785\n</code></pre> <p>And the same execution with the pointer based tree.</p> <pre><code>$ make 90 test05 rep10000\ng++ -std=c++17 -DREPS=10000 -o build/tree-traversal-90 tree-traversal-90.cpp\n0.289652\n</code></pre> <p>This really deserves a WTF!! Pointers are <code>10x</code> faster, i.e., an order of magnitude faster. Both runs have <code>10,000</code> reps and use the input and output of test case <code>05</code>, a tree with <code>445</code> nodes.</p> <p>Now we know: even if our solution seems nice, elegant, frees us from manual memory management and offers us for sure more perks, it is slow. Luckily, our C++17 exercise does not revolve around maximum performance. We are looking to use standard features and specifically new features, those that can also help in many real life situations.</p> <p>We will actually come to that with some future versions of our tree traversal solutions.</p>"},{"location":"0170-tree-traversal/#the-optimized-performance-war","title":"The Optimized Performance War","text":"<p>The tests we executed above were compiled with no optimization. Let us see if the compiler can optimize our code by using the target <code>o2</code>, so we compile with <code>-O2</code>.</p> <pre><code>$ make 02 test05 rep10000 o2\ng++ -std=c++17 -DREPS=10000 -O2 -o build/tree-traversal-02 tree-traversal-02.cpp\n0.446231\n</code></pre> <p>Ooops! That puts the performance of our map-based tree in the ballpark of pointers.</p> <pre><code>$ make 90 test05 rep10000 o2\ng++ -std=c++17 -DREPS=10000 -O2 -o build/tree-traversal-90 tree-traversal-90.cpp\n0.0887391\n</code></pre> <p>Not anymore after we also compile the pointer-based solution with <code>-O2</code>. In any case we have reduced the performance multiplier from <code>10x</code> to <code>5x</code>.</p>"},{"location":"0170-tree-traversal/#switching-to-uniqueptr","title":"Switching to UniquePtr","text":"<p>One of our goals is to use as many of the standard, and modern, facilities that C++ offers us. Instead of manually managing the pointers with <code>new</code> and <code>delete</code>, we will let <code>std::unique_ptr&lt;T&gt;</code> take care of the management, after creating the object with <code>std::make_unique&lt;T&gt;(Args... &amp;args)</code>.</p> <p>Notice how we have an <code>auto static create(int data)</code> function in the original pointer based implementation.</p> <pre><code>        auto static create(int data) { return new Node{data}; }\n</code></pre> <p>GitHub: 17-tree-traversal/tree-traversal-90.cpp:14:14 </p> <p>That means that we only have to change who to return an <code>std::make_unique&lt;Node&gt;</code> here and where we use <code>create</code> remains unchanged. Here is the change in the implementation</p> <pre><code>        auto static create(int data) { return std::make_unique&lt;Node&gt;(data); }\n</code></pre> <p>GitHub: 17-tree-traversal/tree-traversal-91.cpp:15:15 </p> <p>As easy as that. Because we no longer have the need to manage the lifetime of the pointer held in the <code>std::unique_ptr&lt;Node&gt;</code> we can remove the destructors where <code>delete</code> is active. Here:</p> <pre><code>        ~Node() { delete left; delete right; }\n</code></pre> <p>GitHub: 17-tree-traversal/tree-traversal-90.cpp:15:15 </p> <p>And here:</p> <pre><code>    ~PtrTree() { delete m_root; }\n</code></pre> <p>GitHub: 17-tree-traversal/tree-traversal-90.cpp:43:43 </p> <p>Wherever we had a <code>Node *</code>, we know use an alias named <code>NodePtr</code> (obvious name choice) defined as:</p> <pre><code>        int m_data;\n</code></pre> <p>GitHub: 17-tree-traversal/tree-traversal-91.cpp:11:11 </p> <p>After making those changes, let us go for the performance.</p> <pre><code>$ make 91 test05 rep10000 o2\ng++ -std=c++17 -DREPS=10000 -O2 -o build/tree-traversal-90 tree-traversal-91.cpp\n0.0896148\n</code></pre> <p>That is. We have a <code>1x</code> (it's almost a perfect timing match) performance multiplier, i.e.,: we can confidently dropped raw-pointer use and work entirely with <code>std::make_unique&lt;T&gt;</code> with no fear of having an impact in the performance of the solution.</p>"},{"location":"0170-tree-traversal/#listings","title":"Listings","text":""},{"location":"0170-tree-traversal/#01-map-based-tree-implementation","title":"01 - Map-Based Tree Implementation","text":"<pre><code>#include &lt;functional&gt; // std::function\n#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iterator&gt; // std::istream/ostream_iterator\n#include &lt;unordered_map&gt; // std::unordered_map\n#include &lt;utility&gt; // std::pair\n\nclass StdTree {\n    static constexpr auto NullTreeVal = int{};\n    using Children = std::pair&lt;int, int&gt;;\n    static constexpr auto NullChildren = Children{NullTreeVal, NullTreeVal};\n\n    std::unordered_map&lt;int, Children&gt; m_tree;\n    int m_root = NullTreeVal;\n\n    auto insert(int data, int &amp;node) {\n        auto &amp;child = data &lt; node ? m_tree[node].first : m_tree[node].second;\n        if (child == NullTreeVal) { // not in tree, add with empty children\n            m_tree[child = data] = NullChildren; // set target (left or right ref)\n            return;\n        }\n        insert(data, child); // already in tree, go deeper\n    }\n\n    using FVisit = const std::function&lt;void(int)&gt;;\n\n    auto preorder(const FVisit &amp;fvisit, int node) {\n        if (node == NullTreeVal)\n            return; // if empty ... will do nothing\n\n        const auto &amp;[left, right] = m_tree[node]; // get children\n        fvisit(node); // preorder ... out root\n        preorder(fvisit, left); // visit left\n        preorder(fvisit, right); // visit right\n    }\npublic:\n    auto insert(int data) {\n        if (m_root != NullTreeVal) // root already defined?\n            return insert(data, m_root); // yes, insert\n\n        m_tree[m_root = data] = NullChildren; // set m_root with empty children\n    }\n\n    auto preorder(const FVisit &amp;fvisit) { preorder(fvisit, m_root); }\n};\n\n// Main\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto out = std::ostream_iterator&lt;int&gt;{std::cout, \" \"}; // out iter\n\n    auto tree = StdTree{};\n    for (auto t = *in++; t--;) // get number of nodes and count down\n        tree.insert(*in++); // insert nodes\n\n    tree.preorder([&amp;out](const auto &amp;x){ out = x; });\n    return 0;\n}\n</code></pre> <p>GitHub: 17-tree-traversal/tree-traversal-01.cpp </p>"},{"location":"0170-tree-traversal/#02-map-based-tree-implementation-with-timing","title":"02 - Map-Based Tree Implementation with Timing","text":"<pre><code>#include &lt;algorithm&gt; // std::copy_n\n#include &lt;chrono&gt; // std::chrono::xx\n#include &lt;functional&gt; // std::function\n#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iterator&gt; // std::istream/ostream_iterator\n#include &lt;unordered_map&gt; // std::unordered_map\n#include &lt;utility&gt; // std::pair\n#include &lt;vector&gt; // std::vector\n\nclass StdTree {\n    static constexpr auto NullTreeVal = int{};\n    using Children = std::pair&lt;int, int&gt;;\n    static constexpr auto NullChildren = Children{NullTreeVal, NullTreeVal};\n\n    // init tree with empty virtual root\n    std::unordered_map&lt;int, Children&gt; m_tree{{NullTreeVal, NullChildren}};\n    const int &amp;m_root = m_tree.at(NullTreeVal).second; // ref 2 real root\n\n    auto insert(int data, int node) {\n        auto &amp;child = data &lt; node ? m_tree[node].first : m_tree[node].second;\n        if (child == NullTreeVal) { // not in tree, add with empty children\n            m_tree[child = data] = NullChildren; // set target (left or right)\n            return;\n        }\n        insert(data, child); // already in tree, go deeper\n    }\n\n    using FVisit = std::function&lt;void(int)&gt;;\n\n    auto preorder(const FVisit &amp;fvisit, int node) const {\n        if (node == NullTreeVal)\n            return; // if empty ... will do nothing\n\n        const auto &amp;[left, right] = m_tree.at(node); // get children\n        fvisit(node); // preorder ... out root\n        preorder(fvisit, left); // visit left\n        preorder(fvisit, right); // visit right\n    }\npublic:\n    // start always with the virtual root value\n    auto insert(int data) { insert(data, NullTreeVal); }\n    // start with the reference to the real root\n    auto preorder(const FVisit &amp;fvisit) const { preorder(fvisit, m_root); }\n};\n\ntemplate &lt;typename I, typename F&gt;\nauto\nsolution(I in, F fout, int size) {\n    auto tree = StdTree{};\n    while(size--)\n        tree.insert(*in++);\n\n    tree.preorder(fout);\n}\n\n// Main\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto out = std::ostream_iterator&lt;int&gt;{std::cout, \" \"}; // out iter\n    auto oerr = std::ostream_iterator&lt;double&gt;(std::cerr, \"\\n\");\n\n    auto reps = 1;\n#ifdef REPS\n    reps = REPS;\n#endif\n    auto t = *in++;\n    auto v = std::vector&lt;int&gt;(t);\n    auto vin = v.begin();\n    std::copy_n(in, t, vin); //\n\n    auto fout = [&amp;out](const auto &amp;x){ out = x; };\n    auto fakeout = [](const auto &amp;){};\n\n    auto start = std::chrono::steady_clock::now();\n\n    solution(vin, fout, t); // to match expected output\n    while(--reps)\n        solution(vin, fakeout, t); // extra rounds output nothing\n\n    auto stop = std::chrono::steady_clock::now();\n    auto elapsed_seconds = std::chrono::\n        duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(stop - start).count();\n    oerr = elapsed_seconds;\n    return 0;\n}\n</code></pre> <p>GitHub: 17-tree-traversal/tree-traversal-02.cpp </p>"},{"location":"0170-tree-traversal/#03-pointer-based-tree-implementation","title":"03 - Pointer-Based Tree Implementation","text":"<pre><code>#include &lt;algorithm&gt; // std::copy_n\n#include &lt;chrono&gt; // std::chrono::xx\n#include &lt;functional&gt; // std::function\n#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iterator&gt; // std::istream/ostream_iterator\n#include &lt;vector&gt; // std::vector\n\nclass PtrTree {\n    struct Node {\n        int m_data;\n        using NodePtr = Node *;\n        NodePtr left = nullptr, right = nullptr;\n        Node(int data) : m_data{data} {};\n        auto static create(int data) { return new Node{data}; }\n        ~Node() { delete left; delete right; }\n    };\n    using NodePtr = Node::NodePtr;\n    NodePtr m_root = nullptr;\n\n    auto insert(int data, NodePtr &amp;node) {\n        if(not node) {\n            node = Node::create(data);\n            return;\n        }\n        auto &amp;left_or_right = data &lt; node-&gt;m_data ? node-&gt;left : node-&gt;right;\n        insert(data, left_or_right);\n    }\n\n    using FVisit = std::function&lt;void(int)&gt;;\n\n    auto preorder(const FVisit &amp;fvisit, const NodePtr &amp;node) const {\n        if (not node)\n            return;\n\n        fvisit(node-&gt;m_data);\n        preorder(fvisit, node-&gt;left);\n        preorder(fvisit, node-&gt;right);\n    }\npublic:\n    auto insert(int data) { insert(data, m_root); }\n    auto preorder(const FVisit &amp;fvisit) const { preorder(fvisit, m_root); }\n\n    ~PtrTree() { delete m_root; }\n};\n\ntemplate &lt;typename I, typename F&gt;\nauto\nsolution(I in, F fout, int size) {\n    auto tree = PtrTree{};\n    while(size--)\n        tree.insert(*in++);\n\n    tree.preorder(fout);\n}\n\n// Main\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto out = std::ostream_iterator&lt;int&gt;{std::cout, \" \"}; // out iter\n    auto oerr = std::ostream_iterator&lt;double&gt;(std::cerr, \"\\n\");\n\n    auto reps = 1;\n#ifdef REPS\n    reps = REPS;\n#endif\n    auto t = *in++;\n    auto v = std::vector&lt;int&gt;(t);\n    auto vin = v.begin();\n    std::copy_n(in, t, vin); // vin is not invalidated\n\n    auto fout = [&amp;out](auto x){ out = x; };\n    auto fakeout = [](auto){};\n\n    auto start = std::chrono::steady_clock::now();\n    solution(vin, fout, t); // to match expected output\n    while(--reps)\n        solution(vin, fakeout, t); // extra rounds for timing, no output\n    auto stop = std::chrono::steady_clock::now();\n    auto elapsed_seconds = std::chrono::\n        duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(stop - start).count();\n    oerr = elapsed_seconds;\n    return 0;\n}\n</code></pre> <p>GitHub: 17-tree-traversal/tree-traversal-90.cpp </p>"},{"location":"0170-tree-traversal/#03-uniqueptr-based-tree-implementation","title":"03 - UniquePtr-Based Tree Implementation","text":"<pre><code>#include &lt;algorithm&gt; // std::copy_n\n#include &lt;chrono&gt; // std::chrono::xx\n#include &lt;functional&gt; // std::function\n#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iterator&gt; // std::istream/ostream_iterator\n#include &lt;memory&gt; // std::unique_ptr\n#include &lt;vector&gt; // std::vector\n\nclass UniquePtrTree {\n    struct Node {\n        int m_data;\n        using NodePtr = std::unique_ptr&lt;Node&gt;;\n        NodePtr left, right;\n        Node(int data) : m_data{data} {};\n        auto static create(int data) { return std::make_unique&lt;Node&gt;(data); }\n    };\n\n    using NodePtr = Node::NodePtr;\n    NodePtr m_root;\n\n    auto insert(int data, NodePtr &amp;node) {\n        if(not node) {\n            node = Node::create(data);\n            return;\n        }\n        insert(data, data &lt; node-&gt;m_data ? node-&gt;left : node-&gt;right);\n    }\n\n    using FVisit = std::function&lt;void(int)&gt;;\n\n    auto preorder(const FVisit &amp;fvisit, const NodePtr &amp;node) const {\n        if (not node)\n            return;\n\n        fvisit(node-&gt;m_data);\n        preorder(fvisit, node-&gt;left);\n        preorder(fvisit, node-&gt;right);\n    }\npublic:\n    auto insert(int data) { insert(data, m_root); }\n    auto preorder(const FVisit &amp;fvisit) const { preorder(fvisit, m_root); }\n};\n\ntemplate &lt;typename I, typename F&gt;\nauto\nsolution(I in, F fout, int size) {\n    auto tree = UniquePtrTree{};\n    while(size--)\n        tree.insert(*in++);\n\n    tree.preorder(fout);\n}\n\n// Main\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto out = std::ostream_iterator&lt;int&gt;{std::cout, \" \"}; // out iter\n    auto oerr = std::ostream_iterator&lt;double&gt;(std::cerr, \"\\n\");\n\n    auto reps = 1;\n#ifdef REPS\n    reps = REPS;\n#endif\n    auto t = *in++;\n    auto v = std::vector&lt;int&gt;(t);\n    auto vin = v.begin();\n    std::copy_n(in, t, vin); // vin is not invalidated\n\n    auto fout = [&amp;out](auto x){ out = x; };\n    auto fakeout = [](auto){};\n\n    auto start = std::chrono::steady_clock::now();\n    solution(vin, fout, t); // to match expected output\n    while(--reps)\n        solution(vin, fakeout, t); // extra rounds for timing, no output\n    auto stop = std::chrono::steady_clock::now();\n    auto elapsed_seconds = std::chrono::\n        duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(stop - start).count();\n    oerr = elapsed_seconds;\n    return 0;\n}\n</code></pre> <p>GitHub: 17-tree-traversal/tree-traversal-91.cpp </p>"},{"location":"0180-tree-traversal-ii/","title":"Tree Traversal II","text":"<p>Title: Tree: Postorder Traversal Link: https://www.hackerrank.com/challenges/tree-postorder-traversal </p> <p>In the previous challenge we stated we would address several tree traversal methods with a single codebase. We therefore extend the latest solution to do it.</p> <p>We will also make our <code>StdTree</code> a bit more generic as it will:</p> <ul> <li> <p>Take a <code>typename T</code> instead of simply taking <code>int</code> as the type for the nodes.</p> </li> <li> <p>The visit function will also be a template parameter.</p> </li> </ul> <p>That will push us to implement SFINAE directly to check that:</p> <ul> <li> <p>The type <code>T</code> supports the operators <code>&lt;</code>, <code>==</code> and <code>!=</code>, the ones we are using for different parts of the code to chose alternative actions.</p> </li> <li> <p>The visit function type <code>F</code> can take a single <code>T</code> as a parameter.</p> </li> </ul> <p>Although we would be looking at implementing only a <code>postorder</code> traversal method, we will also add <code>inorder</code>, because we will use the pattern to improve our implementation.</p> <p>The SFINAE checks for operator support follow this pattern.</p> <pre><code>template&lt;typename, typename = void&gt;\nconstexpr bool op_lt_v = false;\n\ntemplate&lt;typename T&gt;\nconstexpr bool\nop_lt_v&lt;T, std::void_t&lt;decltype(std::declval&lt;T&gt;() &lt; std::declval&lt;T&gt;())&gt;&gt; = true;\n</code></pre> <p>GitHub: 18-tree-traversal-ii/tree-traversal-ii-01.cpp:11:16 </p> <p>The visiting function check is also no stranger, with <code>std::void_t</code> and <code>std::invoke_result</code> taking the load of the work.</p> <pre><code>template&lt;typename, typename, typename = void&gt;\nconstexpr bool f_visit = false;\n\ntemplate&lt;typename F, typename T&gt;\nconstexpr bool\nf_visit&lt;F, T, std::void_t&lt;std::invoke_result_t&lt;F, T&gt;&gt;&gt; = true;\n</code></pre> <p>GitHub: 18-tree-traversal-ii/tree-traversal-ii-01.cpp:37:42 </p> <p>All those small checks are wrapped in custom <code>enable_if_xxx</code> definitions and later applied to the corresponding functions.</p> <p>Let us concentrate on the traversal methods. First the core or <code>preorder</code></p> <pre><code>        fvisit(node); // preorder ... out root\n        preorder(fvisit, left); // visit left\n        preorder(fvisit, right); // visit right\n</code></pre> <p>GitHub: 18-tree-traversal-ii/tree-traversal-ii-01.cpp:64:66 </p> <p>And then <code>postorder</code> and <code>inorder</code>.</p> <pre><code>        postorder(fvisit, left); // visit left\n        postorder(fvisit, right); // visit right\n        fvisit(node); // postorder ... out root\n</code></pre> <p>GitHub: 18-tree-traversal-ii/tree-traversal-ii-01.cpp:74:76 </p> <pre><code>        inorder(fvisit, left); // visit left\n        fvisit(node); // inorder ... out root\n        inorder(fvisit, right); // visit right\n</code></pre> <p>GitHub: 18-tree-traversal-ii/tree-traversal-ii-01.cpp:84:86 </p> <p>And the pattern emerges:</p> <ul> <li> <p>We recurse using the same method to the left and to the right</p> </li> <li> <p>Only when the <code>fvisit(node)</code> call is executed changes</p> <ul> <li> <p><code>preorder</code>: before visiting the lower nodes</p> </li> <li> <p><code>postorder</code>: after visiting the lower nodes</p> </li> <li> <p><code>inorder</code>: after visiting the left lower nodes and before visiting the right lower ones</p> </li> </ul> </li> </ul> <p>This means that we actually only move around the position of the <code>fvisit(node)</code> call and the rest is just a node visiting thing. That is our pattern to go for more.</p>"},{"location":"0180-tree-traversal-ii/#constexpressing-the-traversals","title":"Constexpressing the Traversals","text":"<p>With the aforementioned pattern we can apply our C++17 beloved <code>if constexpr</code> to choose where to place the <code>fvisit</code> call.</p> <p>The external interfaces for the traversal methods will all rely on a single internal interface named <code>visit</code>.</p> <pre><code>    template &lt;typename F, typename = enable_if_fvisit&lt;F, T&gt;&gt;\n    auto preorder(const F &amp;fvisit) const { visit&lt;Order::Pre&gt;(fvisit, m_root); }\n    template &lt;typename F, typename = enable_if_fvisit&lt;F, T&gt;&gt;\n    auto inorder(const F &amp;fvisit) const { visit&lt;Order::In&gt;(fvisit, m_root); }\n    template &lt;typename F, typename = enable_if_fvisit&lt;F, T&gt;&gt;\n    auto postorder(const F &amp;fvisit) const { visit&lt;Order::Post&gt;(fvisit, m_root); }\n</code></pre> <p>GitHub: 18-tree-traversal-ii/tree-traversal-ii-02.cpp:85:90 </p> <p>Each public method specializes <code>visit</code> with an internal <code>enum</code> that properly defines the names <code>Pre</code>, <code>In</code> and <code>Post</code>. That specialization is the key to let <code>if constexpr</code> place the <code>fvisit(node)</code> call.</p> <pre><code>    enum class Order { Pre, Post, In };\n\n    template &lt;Order order, typename F, typename = enable_if_fvisit&lt;F, T&gt;&gt;\n    auto visit(const F &amp;fvisit, const T &amp;node) const {\n        if (node == NullTreeVal)\n            return; // if empty ... will do nothing\n\n        const auto &amp;[left, right] = m_tree.at(node); // get children\n        if constexpr (order == Order::Pre) fvisit(node); // pre -&gt; root\n        visit&lt;order&gt;(fvisit, left); // visit left\n        if constexpr (order == Order::In) fvisit(node); // inorder -&gt; root\n        visit&lt;order&gt;(fvisit, right); // visit right\n        if constexpr (order == Order::Post) fvisit(node); // post -&gt; root\n    }\n</code></pre> <p>GitHub: 18-tree-traversal-ii/tree-traversal-ii-02.cpp:58:71 </p> <p>As we know this generates as many different methods in the background as we invoke <code>visit</code> with different template parameters. But from a practical point of view we have implemented a single method capable of working as three different methods.</p>"},{"location":"0180-tree-traversal-ii/#futile-attempt-at-performance","title":"Futile Attempt At Performance","text":"<p>Now that we have proper external and internal interfaces, let us try to improve performance. It is probably going to be a futile attempt because we have a <code>10x</code> performance difference. We will, however, introduce a small change to see if something changes. Recall that Bon Jovi sang: \u201cThe more things change the more they stay the same\u201d and our performance is therefore doomed to stay the same.</p> <p>In our solution we are using <code>std::pair&lt;int, int&gt;</code> (or <code>&lt;T, T</code>&gt; in the templated version) to hold the children and have then to access <code>.first</code> and <code>.second</code> to choose the left and right children node. But because <code>std::pair</code> can handle different types, there has to be a lot of machinery to account for that. Let us therefore simplify that: we will use <code>std::array&lt;T, 2&gt;</code> to have a fixed array size assignment and no type magic.</p> <p>We introduce an enum to properly access <code>Node::Left</code> and <code>Node::Right</code>, although we only need to keep the initial reference to the real root as a child of the virtual root. This is so because we will still use Structured Bindings and the comparison <code>&lt;</code> of <code>T</code> types when inserting to choose the position.</p> <p>Here is how the <code>Children</code> now look like.</p> <pre><code>template &lt;typename T = int, typename = enable_if_T_ops&lt;T&gt;&gt;\nclass StdTree {\n    static constexpr auto NullTreeVal = T{};\n    enum Node { Left = 0, Right = 1, Total = 2 };\n    using Children = std::array&lt;T, Node::Total&gt;;\n    static constexpr auto NullChildren = Children{NullTreeVal, NullTreeVal};\n</code></pre> <p>GitHub: 18-tree-traversal-ii/tree-traversal-ii-03.cpp:48:53 </p> <p>Accessing both the <code>left</code> and <code>right</code> node at the same time does not change.</p> <pre><code>    template &lt;Order order, typename F, typename = enable_if_fvisit&lt;F, T&gt;&gt;\n    auto visit(const F &amp;fvisit, const T &amp;node) const {\n        if (node == NullTreeVal)\n            return; // if empty ... will do nothing\n\n        const auto &amp;[left, right] = m_tree.at(node); // get children\n</code></pre> <p>GitHub: 18-tree-traversal-ii/tree-traversal-ii-03.cpp:61:66 </p> <p>But we put the <code>operator []</code> of <code>std::array</code> to good use when selecting the child to insert things into (or create a new node)</p> <pre><code>    void insert(const T &amp;data, const T &amp;node) {\n        auto &amp;child = m_tree.at(node)[not (data &lt; node)];\n</code></pre> <p>GitHub: 18-tree-traversal-ii/tree-traversal-ii-03.cpp:74:75 </p> <p>Let us check if the performance has actually improved.</p> <pre><code>$ make 03 test05 rep10000 o2\ng++ -std=c++17 -DREPS=10000 -o build/tree-traversal-ii-03 tree-traversal-ii-03.cpp\n0.394339\n</code></pre> <p>Not really, i.e., no, there has been no improvement at all, when considering \u201corders or magnitude\u201d. It would really have been a miracle, had it happened. Let us think about it: an <code>std::unordered_map</code> is based on a hash table and that means that we are implementing a container, a tree, on top of another container. An <code>std::map</code> is for example implemented atop a red-black tree and that is already a good indication that implementing a tree on top of another tree (or a similar structure) is going to hurt the performance of our solution.</p> <p>But if we compare that timing with the timing of our <code>01</code> solution (still <code>std::pair</code> based) there is an average advantage of <code>20</code> milliseconds for the test with <code>10,000</code> repetitions. Not much, but it shows that <code>std::pair</code> is giving us a small leading edge.</p>"},{"location":"0180-tree-traversal-ii/#listings","title":"Listings","text":"<p>Let us list the code of the three solutions we presented above.</p>"},{"location":"0180-tree-traversal-ii/#t-template-map-based-tree-01","title":"T-Template Map-Based Tree - 01","text":"<pre><code>#include &lt;algorithm&gt; // std::copy_n\n#include &lt;chrono&gt; // std::chrono::xx\n#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iterator&gt; // std::istream/ostream_iterator\n#include &lt;unordered_map&gt; // std::unordered_map\n#include &lt;utility&gt; // std::pair\n#include &lt;vector&gt; // std::vector\n#include &lt;type_traits&gt; // std::enable_if, std::invoke_result, std::void_t\n\n// SFINAE for the Tree Type (operator support)\ntemplate&lt;typename, typename = void&gt;\nconstexpr bool op_lt_v = false;\n\ntemplate&lt;typename T&gt;\nconstexpr bool\nop_lt_v&lt;T, std::void_t&lt;decltype(std::declval&lt;T&gt;() &lt; std::declval&lt;T&gt;())&gt;&gt; = true;\n\ntemplate&lt;typename, typename = void&gt;\nconstexpr bool op_ne_v = false;\n\ntemplate&lt;typename T&gt;\nconstexpr bool\nop_ne_v&lt;T, std::void_t&lt;decltype(std::declval&lt;T&gt;() != std::declval&lt;T&gt;())&gt;&gt; = true;\n\ntemplate&lt;typename, typename = void&gt;\nconstexpr bool op_eq_v = false;\n\ntemplate&lt;typename T&gt;\nconstexpr bool\nop_eq_v&lt;T, std::void_t&lt;decltype(std::declval&lt;T&gt;() == std::declval&lt;T&gt;())&gt;&gt; = true;\n\ntemplate &lt;typename T&gt;\nusing enable_if_T_ops =\n    std::enable_if_t&lt;op_lt_v&lt;T&gt; and op_ne_v&lt;T&gt; and op_eq_v&lt;T&gt;&gt;;\n\n// SFINAE: Visiting Function\ntemplate&lt;typename, typename, typename = void&gt;\nconstexpr bool f_visit = false;\n\ntemplate&lt;typename F, typename T&gt;\nconstexpr bool\nf_visit&lt;F, T, std::void_t&lt;std::invoke_result_t&lt;F, T&gt;&gt;&gt; = true;\n\ntemplate &lt;typename F, typename T&gt;\nusing enable_if_fvisit = std::enable_if_t&lt;f_visit&lt;F, T&gt;&gt;;\n\n// Tree Class\ntemplate &lt;typename T = int, typename = enable_if_T_ops&lt;T&gt;&gt;\nclass StdTree {\n    static constexpr auto NullTreeVal = T{};\n    using Children = std::pair&lt;T, T&gt;;\n    static constexpr auto NullChildren = Children{NullTreeVal, NullTreeVal};\n\n    // init tree with empty virtual root\n    std::unordered_map&lt;T, Children&gt; m_tree{{NullTreeVal, NullChildren}};\n    const T &amp;m_root = m_tree.at(NullTreeVal).second; // ref 2 real root\n\n    template &lt;typename F, typename = enable_if_fvisit&lt;F, T&gt;&gt;\n    auto preorder(const F &amp;fvisit, const T &amp;node) const {\n        if (node == NullTreeVal)\n            return; // if empty ... will do nothing\n\n        const auto &amp;[left, right] = m_tree.at(node); // get children\n        fvisit(node); // preorder ... out root\n        preorder(fvisit, left); // visit left\n        preorder(fvisit, right); // visit right\n    }\n    template &lt;typename F, typename = enable_if_fvisit&lt;F, T&gt;&gt;\n    auto postorder(const F &amp;fvisit, const T &amp;node) const {\n        if (node == NullTreeVal)\n            return; // if empty ... will do nothing\n\n        const auto &amp;[left, right] = m_tree.at(node); // get children\n        postorder(fvisit, left); // visit left\n        postorder(fvisit, right); // visit right\n        fvisit(node); // postorder ... out root\n    }\n    template &lt;typename F, typename = enable_if_fvisit&lt;F, T&gt;&gt;\n    auto inorder(const F &amp;fvisit, const T &amp;node) const {\n        if (node == NullTreeVal)\n            return; // if empty ... will do nothing\n\n        const auto &amp;[left, right] = m_tree.at(node); // get children\n        inorder(fvisit, left); // visit left\n        fvisit(node); // inorder ... out root\n        inorder(fvisit, right); // visit right\n    }\n\n    void insert(const T &amp;data, const T &amp;node) {\n        auto &amp;child = data &lt; node ? m_tree[node].first : m_tree[node].second;\n        if (child != NullTreeVal)\n            return insert(data, child); // already in tree, go deeper\n        // not in tree, add it with default empty children\n        m_tree[child = data] = NullChildren; // set target (left or right ref)\n    }\n\npublic:\n    // start always with the virtual root value\n    auto insert(const T &amp;data) { insert(data, NullTreeVal); }\n    // start with the reference to the real root\n    template &lt;typename F, typename = enable_if_fvisit&lt;F, T&gt;&gt;\n    auto preorder(const F &amp;fvisit) const { preorder(fvisit, m_root); }\n    template &lt;typename F, typename = enable_if_fvisit&lt;F, T&gt;&gt;\n    auto postorder(const F &amp;fvisit) const { postorder(fvisit, m_root); }\n    template &lt;typename F, typename = enable_if_fvisit&lt;F, T&gt;&gt;\n    auto inorder(const F &amp;fvisit) const { inorder(fvisit, m_root); }\n};\n\n// Solution Function\ntemplate &lt;typename I, typename F&gt;\nauto\nsolution(I in, F fout, int size) {\n    auto tree = StdTree{};\n    while(size--)\n        tree.insert(*in++);\n\n    tree.postorder(fout);\n}\n\n// Main\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto out = std::ostream_iterator&lt;int&gt;{std::cout, \" \"}; // out iter\n    auto oerr = std::ostream_iterator&lt;double&gt;(std::cerr, \"\\n\");\n\n    auto reps = 1;\n#ifdef REPS\n    reps = REPS;\n#endif\n    auto t = *in++;\n    auto v = std::vector&lt;int&gt;(t);\n    auto vin = v.begin();\n    std::copy_n(in, t, vin); //\n\n    auto fout = [&amp;out](const auto &amp;x){ out = x; };\n    auto fakeout = [](const auto &amp;){};\n\n    auto start = std::chrono::steady_clock::now();\n\n    solution(vin, fout, t); // to match expected output\n    while(--reps)\n        solution(vin, fakeout, t); // extra rounds output nothing\n\n    auto stop = std::chrono::steady_clock::now();\n    auto elapsed_seconds = std::chrono::\n        duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(stop - start).count();\n    oerr = elapsed_seconds;\n    return 0;\n}\n</code></pre> <p>GitHub: 18-tree-traversal-ii/tree-traversal-ii-01.cpp </p>"},{"location":"0180-tree-traversal-ii/#constexpr-traversals-02","title":"Constexpr Traversals - 02","text":"<pre><code>#include &lt;algorithm&gt; // std::copy_n\n#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iterator&gt; // std::istream/ostream_iterator\n#include &lt;unordered_map&gt; // std::unordered_map\n#include &lt;utility&gt; // std::pair\n#include &lt;chrono&gt; // std::chrono::xx\n#include &lt;vector&gt; // std::vector\n#include &lt;type_traits&gt; // std::enable_if, std::invoke_result, std::void_t\n\n// SFINAE for the Tree Type (operator support)\ntemplate&lt;typename, typename = void&gt;\nconstexpr bool op_lt_v = false;\n\ntemplate&lt;typename T&gt;\nconstexpr bool\nop_lt_v&lt;T, std::void_t&lt;decltype(std::declval&lt;T&gt;() &lt; std::declval&lt;T&gt;())&gt;&gt; = true;\n\ntemplate&lt;typename, typename = void&gt;\nconstexpr bool op_ne_v = false;\n\ntemplate&lt;typename T&gt;\nconstexpr bool\nop_ne_v&lt;T, std::void_t&lt;decltype(std::declval&lt;T&gt;() != std::declval&lt;T&gt;())&gt;&gt; = true;\n\ntemplate&lt;typename, typename = void&gt;\nconstexpr bool op_eq_v = false;\n\ntemplate&lt;typename T&gt;\nconstexpr bool\nop_eq_v&lt;T, std::void_t&lt;decltype(std::declval&lt;T&gt;() == std::declval&lt;T&gt;())&gt;&gt; = true;\n\ntemplate &lt;typename T&gt;\nusing enable_if_T_ops =\n    std::enable_if_t&lt;op_lt_v&lt;T&gt; and op_ne_v&lt;T&gt; and op_eq_v&lt;T&gt;&gt;;\n\n// SFINAE: Visiting Function\ntemplate&lt;typename, typename, typename = void&gt;\nconstexpr bool f_visit = false;\n\ntemplate&lt;typename F, typename T&gt;\nconstexpr bool\nf_visit&lt;F, T, std::void_t&lt;std::invoke_result_t&lt;F, T&gt;&gt;&gt; = true;\n\ntemplate &lt;typename F, typename T&gt;\nusing enable_if_fvisit = std::enable_if_t&lt;f_visit&lt;F, T&gt;&gt;;\n\n// Tree Class\ntemplate &lt;typename T = int, typename = enable_if_T_ops&lt;T&gt;&gt;\nclass StdTree {\n    static constexpr auto NullTreeVal = T{};\n    using Children = std::pair&lt;T, T&gt;;\n    static constexpr auto NullChildren = Children{NullTreeVal, NullTreeVal};\n\n    // init tree with empty virtual root\n    std::unordered_map&lt;T, Children&gt; m_tree{{NullTreeVal, NullChildren}};\n    const T &amp;m_root = m_tree.at(NullTreeVal).second; // ref 2 real root\n\n    enum class Order { Pre, Post, In };\n\n    template &lt;Order order, typename F, typename = enable_if_fvisit&lt;F, T&gt;&gt;\n    auto visit(const F &amp;fvisit, const T &amp;node) const {\n        if (node == NullTreeVal)\n            return; // if empty ... will do nothing\n\n        const auto &amp;[left, right] = m_tree.at(node); // get children\n        if constexpr (order == Order::Pre) fvisit(node); // pre -&gt; root\n        visit&lt;order&gt;(fvisit, left); // visit left\n        if constexpr (order == Order::In) fvisit(node); // inorder -&gt; root\n        visit&lt;order&gt;(fvisit, right); // visit right\n        if constexpr (order == Order::Post) fvisit(node); // post -&gt; root\n    }\n\n    void insert(const T &amp;data, const T &amp;node) {\n        auto &amp;child = data &lt; node ? m_tree[node].first : m_tree[node].second;\n        if (child != NullTreeVal)\n            return insert(data, child); // already in tree, go deeper\n        // not in tree, add it with default empty children\n        m_tree[child = data] = NullChildren; // set target (left or right ref)\n    }\n\npublic:\n    // start always with the virtual root value\n    auto insert(const T &amp;data) { insert(data, NullTreeVal); }\n    // start with the reference to the real root\n    template &lt;typename F, typename = enable_if_fvisit&lt;F, T&gt;&gt;\n    auto preorder(const F &amp;fvisit) const { visit&lt;Order::Pre&gt;(fvisit, m_root); }\n    template &lt;typename F, typename = enable_if_fvisit&lt;F, T&gt;&gt;\n    auto inorder(const F &amp;fvisit) const { visit&lt;Order::In&gt;(fvisit, m_root); }\n    template &lt;typename F, typename = enable_if_fvisit&lt;F, T&gt;&gt;\n    auto postorder(const F &amp;fvisit) const { visit&lt;Order::Post&gt;(fvisit, m_root); }\n};\n\n// Solution Function\ntemplate &lt;typename I, typename F&gt;\nauto\nsolution(I in, F fout, int size) {\n    auto tree = StdTree{};\n    while(size--)\n        tree.insert(*in++);\n\n    tree.postorder(fout);\n}\n\n// Main\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto out = std::ostream_iterator&lt;int&gt;{std::cout, \" \"}; // out iter\n    auto oerr = std::ostream_iterator&lt;double&gt;(std::cerr, \"\\n\");\n\n    auto reps = 1;\n#ifdef REPS\n    reps = REPS;\n#endif\n    auto t = *in++;\n    auto v = std::vector&lt;int&gt;(t);\n    auto vin = v.begin();\n    std::copy_n(in, t, vin); //\n\n    auto fout = [&amp;out](const auto &amp;x){ out = x; };\n    auto fakeout = [](const auto &amp;){};\n\n    auto start = std::chrono::steady_clock::now();\n\n    solution(vin, fout, t); // to match expected output\n    while(--reps)\n        solution(vin, fakeout, t); // extra rounds output nothing\n\n    auto stop = std::chrono::steady_clock::now();\n    auto elapsed_seconds = std::chrono::\n        duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(stop - start).count();\n    oerr = elapsed_seconds;\n    return 0;\n}\n</code></pre> <p>GitHub: 18-tree-traversal-ii/tree-traversal-ii-02.cpp </p>"},{"location":"0180-tree-traversal-ii/#removing-stdpair-03","title":"Removing std::pair - 03","text":"<pre><code>#include &lt;algorithm&gt; // std::copy_n\n#include &lt;array&gt; // std::array\n#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iterator&gt; // std::istream/ostream_iterator\n#include &lt;unordered_map&gt; // std::unordered_map\n#include &lt;chrono&gt; // std::chrono::xx\n#include &lt;vector&gt; // std::vector\n#include &lt;type_traits&gt; // std::enable_if, std::invoke_result, std::void_t\n\n// SFINAE for the Tree Type (operator support)\ntemplate&lt;typename, typename = void&gt;\nconstexpr bool op_lt_v = false;\n\ntemplate&lt;typename T&gt;\nconstexpr bool\nop_lt_v&lt;T, std::void_t&lt;decltype(std::declval&lt;T&gt;() &lt; std::declval&lt;T&gt;())&gt;&gt; = true;\n\ntemplate&lt;typename, typename = void&gt;\nconstexpr bool op_ne_v = false;\n\ntemplate&lt;typename T&gt;\nconstexpr bool\nop_ne_v&lt;T, std::void_t&lt;decltype(std::declval&lt;T&gt;() != std::declval&lt;T&gt;())&gt;&gt; = true;\n\ntemplate&lt;typename, typename = void&gt;\nconstexpr bool op_eq_v = false;\n\ntemplate&lt;typename T&gt;\nconstexpr bool\nop_eq_v&lt;T, std::void_t&lt;decltype(std::declval&lt;T&gt;() == std::declval&lt;T&gt;())&gt;&gt; = true;\n\ntemplate &lt;typename T&gt;\nusing enable_if_T_ops =\n    std::enable_if_t&lt;op_lt_v&lt;T&gt; and op_ne_v&lt;T&gt; and op_eq_v&lt;T&gt;&gt;;\n\n// SFINAE: Visiting Function\ntemplate&lt;typename, typename, typename = void&gt;\nconstexpr bool f_visit = false;\n\ntemplate&lt;typename F, typename T&gt;\nconstexpr bool\nf_visit&lt;F, T, std::void_t&lt;std::invoke_result_t&lt;F, T&gt;&gt;&gt; = true;\n\ntemplate &lt;typename F, typename T&gt;\nusing enable_if_fvisit = std::enable_if_t&lt;f_visit&lt;F, T&gt;&gt;;\n\n// Tree Class\ntemplate &lt;typename T = int, typename = enable_if_T_ops&lt;T&gt;&gt;\nclass StdTree {\n    static constexpr auto NullTreeVal = T{};\n    enum Node { Left = 0, Right = 1, Total = 2 };\n    using Children = std::array&lt;T, Node::Total&gt;;\n    static constexpr auto NullChildren = Children{NullTreeVal, NullTreeVal};\n\n    // init tree with empty virtual root\n    std::unordered_map&lt;T, Children&gt; m_tree{{NullTreeVal, NullChildren}};\n    const T &amp;m_root = m_tree.at(NullTreeVal)[Node::Right]; // ref 2 real root\n\n    enum class Order { Pre, Post, In };\n\n    template &lt;Order order, typename F, typename = enable_if_fvisit&lt;F, T&gt;&gt;\n    auto visit(const F &amp;fvisit, const T &amp;node) const {\n        if (node == NullTreeVal)\n            return; // if empty ... will do nothing\n\n        const auto &amp;[left, right] = m_tree.at(node); // get children\n        if constexpr (order == Order::Pre) fvisit(node); // pre -&gt; root\n        visit&lt;order&gt;(fvisit, left); // visit left\n        if constexpr (order == Order::In) fvisit(node); // inorder -&gt; root\n        visit&lt;order&gt;(fvisit, right); // visit right\n        if constexpr (order == Order::Post) fvisit(node); // post -&gt; root\n    }\n\n    void insert(const T &amp;data, const T &amp;node) {\n        auto &amp;child = m_tree.at(node)[not (data &lt; node)];\n        if (child != NullTreeVal)\n            return insert(data, child); // already in tree, go deeper\n        // not in tree, add it with default empty children\n        m_tree[child = data] = NullChildren; // set target (left or right ref)\n    }\n\npublic:\n    // start always with the virtual root value\n    auto insert(const T &amp;data) { insert(data, NullTreeVal); }\n    // start with the reference to the real root\n    template &lt;typename F, typename = enable_if_fvisit&lt;F, T&gt;&gt;\n    auto preorder(const F &amp;fvisit) const { visit&lt;Order::Pre&gt;(fvisit, m_root); }\n    template &lt;typename F, typename = enable_if_fvisit&lt;F, T&gt;&gt;\n    auto inorder(const F &amp;fvisit) const { visit&lt;Order::In&gt;(fvisit, m_root); }\n    template &lt;typename F, typename = enable_if_fvisit&lt;F, T&gt;&gt;\n    auto postorder(const F &amp;fvisit) const { visit&lt;Order::Post&gt;(fvisit, m_root); }\n};\n\n// Solution Function\ntemplate &lt;typename I, typename F&gt;\nauto\nsolution(I in, F fout, int size) {\n    auto tree = StdTree{};\n    while(size--)\n        tree.insert(*in++);\n\n    tree.postorder(fout);\n}\n\n// Main\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto out = std::ostream_iterator&lt;int&gt;{std::cout, \" \"}; // out iter\n    auto oerr = std::ostream_iterator&lt;double&gt;(std::cerr, \"\\n\");\n\n    auto reps = 1;\n#ifdef REPS\n    reps = REPS;\n#endif\n    auto t = *in++;\n    auto v = std::vector&lt;int&gt;(t);\n    auto vin = v.begin();\n    std::copy_n(in, t, vin); //\n\n    auto fout = [&amp;out](const auto &amp;x){ out = x; };\n    auto fakeout = [](const auto &amp;){};\n\n    auto start = std::chrono::steady_clock::now();\n\n    solution(vin, fout, t); // to match expected output\n    while(--reps)\n        solution(vin, fakeout, t); // extra rounds output nothing\n\n    auto stop = std::chrono::steady_clock::now();\n    auto elapsed_seconds = std::chrono::\n        duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(stop - start).count();\n    oerr = elapsed_seconds;\n    return 0;\n}\n</code></pre> <p>GitHub: 18-tree-traversal-ii/tree-traversal-ii-03.cpp </p>"},{"location":"0180-tree-traversal-ii/#uniqueptr-t-templatedcontsexpress-traversals-91","title":"UniquePtr T-Templated/Contsexpress Traversals - 91","text":"<pre><code>#include &lt;algorithm&gt; // std::copy_n\n#include &lt;chrono&gt; // std::chrono::xx\n#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iterator&gt; // std::istream/ostream_iterator\n#include &lt;memory&gt; // std::unique_ptr\n#include &lt;vector&gt; // std::vector\n\ntemplate &lt;class T = int&gt;\nclass UniquePtrTree {\n    struct Node {\n        T m_data;\n        using NodePtr = std::unique_ptr&lt;Node&gt;;\n        NodePtr left, right;\n        Node(const T &amp;data) : m_data{data} {};\n        auto static create(const T &amp;d) { return std::make_unique&lt;Node&gt;(d); }\n    };\n\n    using NodePtr = typename Node::NodePtr;\n    NodePtr m_root;\n\n    auto insert(const T &amp;data, NodePtr &amp;node) {\n        if(not node) {\n            node = Node::create(data);\n            return;\n        }\n        insert(data, data &lt; node-&gt;m_data ? node-&gt;left : node-&gt;right);\n    }\n\n    enum class Order { Pre, Post, In };\n\n    template &lt;Order order, typename F&gt;\n    auto visit(const F &amp;fvisit, const NodePtr &amp;node) const {\n        if (not node)\n            return;\n\n        if constexpr (order == Order::Pre) fvisit(node-&gt;m_data); // pre\n        visit&lt;order&gt;(fvisit, node-&gt;left); // visit left\n        if constexpr (order == Order::In) fvisit(node-&gt;m_data); // inorder\n        visit&lt;order&gt;(fvisit, node-&gt;right); // visit right\n        if constexpr (order == Order::Post) fvisit(node-&gt;m_data); // post\n    }\n\npublic:\n    auto insert(const T &amp;data) { insert(data, m_root); };\n\n    template &lt;typename F&gt;\n    auto preorder(const F &amp;fvisit) const { visit&lt;Order::Pre&gt;(fvisit, m_root); }\n    template &lt;typename F&gt;\n    auto postorder(const F &amp;fvisit) const { visit&lt;Order::Post&gt;(fvisit, m_root); }\n    template &lt;typename F&gt;\n    auto inorder(const F &amp;fvisit) const { visit&lt;Order::In&gt;(fvisit, m_root); }\n};\n\ntemplate &lt;typename I, typename F&gt;\nauto\nsolution(I in, F fout, int size) {\n    auto tree = UniquePtrTree{};\n    while(size--)\n        tree.insert(*in++);\n\n    tree.postorder(fout);\n}\n\n// Main\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto out = std::ostream_iterator&lt;int&gt;{std::cout, \" \"}; // out iter\n    auto oerr = std::ostream_iterator&lt;double&gt;(std::cerr, \"\\n\");\n\n    auto reps = 1;\n#ifdef REPS\n    reps = REPS;\n#endif\n    auto t = *in++;\n    auto v = std::vector&lt;int&gt;(t);\n    auto vin = v.begin();\n    std::copy_n(in, t, vin); // vin is not invalidated\n\n    auto fout = [&amp;out](const auto &amp;x){ out = x; };\n    auto fakeout = [](const auto &amp;){};\n\n    auto start = std::chrono::steady_clock::now();\n    solution(vin, fout, t); // to match expected output\n    while(--reps)\n        solution(vin, fakeout, t); // extra rounds for timing, no output\n    auto stop = std::chrono::steady_clock::now();\n    auto elapsed_seconds = std::chrono::\n        duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(stop - start).count();\n    oerr = elapsed_seconds;\n    return 0;\n}\n</code></pre> <p>GitHub: 18-tree-traversal-ii/tree-traversal-ii-91.cpp </p>"},{"location":"0190-tree-traversal-iii/","title":"Tree Traversal III","text":"<p>Title: Tree: Inorder Traversal Link: https://www.hackerrank.com/challenges/tree-inorder-traversal </p> <p>Let us use the third of the traversal methods, inorder, to fix our design, given that we cannot really fix the performance.</p> <p>Yes, we need to fix a basic design flaw. When we first addressed the tree traversal problem we used <code>int{}</code> (i.e., <code>0</code>) to indicate that a node is a null node. This was not a problem for our solution because we know that problem values will be <code>&gt; 0</code>.</p> <p>The next design used <code>typename T</code> as the type and <code>T{}</code> as the null value. And this is simply the error repeating itself.</p> <p>Let us therefore use a feature of C++17 that we have yet not explored: <code>std::optional&lt;T&gt;</code>. It is a class that manages a value of type <code>T</code> but may actually not contain any value. And that is what will use to have a real null value: an <code>std::optional</code> that contains no value.</p> <p>That is, in fact, the value <code>std::nullopt</code> a <code>constexpr</code> value of type <code>std::nullopt_t</code>, a value that we will obtain by simply creating an empty <code>std::optional&lt;T&gt;</code>.</p> <p>This is how we now define the data structure of our tree.</p> <pre><code>template &lt;typename T = int, typename = enable_if_T_ops&lt;T&gt;&gt;\nclass StdTree {\n    using TNode = std::optional&lt;T&gt;; // out real type is now the optional&lt;T&gt;\n    static constexpr auto NullTreeVal = TNode{}; // holds std::nullopt\n\n    enum Node { Left = 0, Right = 1, Total = 2 };\n    using Children = std::array&lt;TNode, Node::Total&gt;;\n    static constexpr auto NullChildren = Children{{}}; // two std::nullopt\n\n    // init tree with virtual root with empty children\n    std::unordered_map&lt;TNode, Children&gt; m_tree{{NullTreeVal, NullChildren}};\n    const TNode &amp;m_root = m_tree.at(NullTreeVal)[Node::Right]; // real root ref\n</code></pre> <p>GitHub: 19-tree-traversal-iii/tree-traversal-iii-01.cpp:49:60 </p> <p>The tree does still take <code>T</code> as the type, but we use and store <code>TNode</code> which is defined as <code>std::optional&lt;T&gt;</code>. A simple substitution and we suddenly have a real null value, because our <code>NullTreeVal</code> is now holding a <code>constexpr</code> empty <code>std::optional&lt;T&gt;</code>, i.e. an <code>std::nullopt</code> as explained above.</p> <p>The only small drawback is that we need an extra step to get the value out of our <code>std::optional&lt;T&gt;</code> and that is: using the operator <code>*</code> as is we were dereferencing a pointer or an iterator. However, we only need that when calling the visiting function <code>fvisit</code>.</p> <p>Notice that the only change is the use of <code>*node</code> in <code>fvisit(*node)</code>.</p> <pre><code>    template &lt;Order order, typename F, typename = enable_if_fvisit&lt;F, T&gt;&gt;\n    auto visit(const F &amp;fvisit, const TNode &amp;node) const {\n        if (not node)\n            return; // if empty ... will do nothing\n\n        const auto &amp;[left, right] = m_tree.at(node); // get children\n        if constexpr (order == Order::Pre) fvisit(*node); // pre\n        visit&lt;order&gt;(fvisit, left); // visit left\n        if constexpr (order == Order::In) fvisit(*node); // inorder\n        visit&lt;order&gt;(fvisit, right); // visit right\n        if constexpr (order == Order::Post) fvisit(*node); // post\n    }\n</code></pre> <p>GitHub: 19-tree-traversal-iii/tree-traversal-iii-01.cpp:64:75 </p> <p>On the other hand, we no longer need to compare against a <code>NullTreeVal</code> as we did before, because our <code>std::optional&lt;T&gt;</code> will evaluate to <code>false</code> if no value is contained, i.e., an <code>std::nullopt</code> is contained instead of an instance of type <code>T</code>. But we still use it as a key for the virtual root.</p> <p>Given that we have added another layer of indirection, let us check the timing of this solution to see if we have gone yet another order of magnitude away from the optimal solution.</p> <p>The timing of our <code>std::optional</code> solution</p> <pre><code>$ make 01 rep10000 test05 o2\ng++ -std=c++17 -DREPS=10000 -O2 -o build/tree-traversal-iii-01 tree-traversal-iii-01.cpp\n0.497966\n</code></pre> <p>And the one of the <code>&lt;std::unique_ptr&gt;</code>-based tree</p> <pre><code>$ make 01 rep10000 test05 o2\ng++ -std=c++17 -DREPS=10000 -O2 -o build/tree-traversal-iii-01 tree-traversal-iii-01.cpp\n0.0948075\n</code></pre> <p>We are slightly above <code>5x</code>, the multiplier we had when we first measured performance against a pointer-based tree. Still in that ballpark, which means that using <code>std::optional</code> is not really a headache and has improved our code by letting us use the full spectrum of values of the type <code>T</code>. Recall that we were before blocking <code>int{}</code> or <code>T{}</code> as the values to indicate a null node, voiding the presence of those values as valid data in a node.</p>"},{"location":"0190-tree-traversal-iii/#listings","title":"Listings","text":""},{"location":"0190-tree-traversal-iii/#optional-based-map-tree-01","title":"Optional-Based Map Tree - 01","text":"<pre><code>#include &lt;algorithm&gt; // std::copy_n\n#include &lt;array&gt; // std::array\n#include &lt;chrono&gt; // std::chrono::xx\n#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iterator&gt; // std::istream/ostream_iterator\n#include &lt;optional&gt; // std::optional\n#include &lt;unordered_map&gt; // std::unordered_map\n#include &lt;vector&gt; // std::vector\n#include &lt;type_traits&gt; // std::enable_if, std::invoke_result, std::void_t\n\n// SFINAE for the Tree Type (operator support)\ntemplate&lt;typename, typename = void&gt;\nconstexpr bool op_lt_v = false;\n\ntemplate&lt;typename T&gt;\nconstexpr bool\nop_lt_v&lt;T, std::void_t&lt;decltype(std::declval&lt;T&gt;() &lt; std::declval&lt;T&gt;())&gt;&gt; = true;\n\ntemplate&lt;typename, typename = void&gt;\nconstexpr bool op_ne_v = false;\n\ntemplate&lt;typename T&gt;\nconstexpr bool\nop_ne_v&lt;T, std::void_t&lt;decltype(std::declval&lt;T&gt;() != std::declval&lt;T&gt;())&gt;&gt; = true;\n\ntemplate&lt;typename, typename = void&gt;\nconstexpr bool op_eq_v = false;\n\ntemplate&lt;typename T&gt;\nconstexpr bool\nop_eq_v&lt;T, std::void_t&lt;decltype(std::declval&lt;T&gt;() == std::declval&lt;T&gt;())&gt;&gt; = true;\n\ntemplate &lt;typename T&gt;\nusing enable_if_T_ops =\n    std::enable_if_t&lt;op_lt_v&lt;T&gt; and op_ne_v&lt;T&gt; and op_eq_v&lt;T&gt;&gt;;\n\n// SFINAE: Visiting Function\ntemplate&lt;typename, typename, typename = void&gt;\nconstexpr bool f_visit = false;\n\ntemplate&lt;typename F, typename T&gt;\nconstexpr bool\nf_visit&lt;F, T, std::void_t&lt;std::invoke_result_t&lt;F, T&gt;&gt;&gt; = true;\n\ntemplate &lt;typename F, typename T&gt;\nusing enable_if_fvisit = std::enable_if_t&lt;f_visit&lt;F, T&gt;&gt;;\n\n// Tree Class\ntemplate &lt;typename T = int, typename = enable_if_T_ops&lt;T&gt;&gt;\nclass StdTree {\n    using TNode = std::optional&lt;T&gt;; // out real type is now the optional&lt;T&gt;\n    static constexpr auto NullTreeVal = TNode{}; // holds std::nullopt\n\n    enum Node { Left = 0, Right = 1, Total = 2 };\n    using Children = std::array&lt;TNode, Node::Total&gt;;\n    static constexpr auto NullChildren = Children{{}}; // two std::nullopt\n\n    // init tree with virtual root with empty children\n    std::unordered_map&lt;TNode, Children&gt; m_tree{{NullTreeVal, NullChildren}};\n    const TNode &amp;m_root = m_tree.at(NullTreeVal)[Node::Right]; // real root ref\n\n    enum class Order { Pre, Post, In };\n\n    template &lt;Order order, typename F, typename = enable_if_fvisit&lt;F, T&gt;&gt;\n    auto visit(const F &amp;fvisit, const TNode &amp;node) const {\n        if (not node)\n            return; // if empty ... will do nothing\n\n        const auto &amp;[left, right] = m_tree.at(node); // get children\n        if constexpr (order == Order::Pre) fvisit(*node); // pre\n        visit&lt;order&gt;(fvisit, left); // visit left\n        if constexpr (order == Order::In) fvisit(*node); // inorder\n        visit&lt;order&gt;(fvisit, right); // visit right\n        if constexpr (order == Order::Post) fvisit(*node); // post\n    }\n\n    void insert(const T &amp;data, const TNode &amp;node) {\n        auto &amp;child = m_tree.at(node)[not (data &lt; node)];\n        if (child)\n            return insert(data, child); // already in tree, go deeper\n        // not in tree, add it with default empty children\n        m_tree[child = data] = NullChildren; // set target (left or right ref)\n    }\n\npublic:\n    // start always with the virtual root value\n    auto insert(const T &amp;data) { insert(data, NullTreeVal); }\n    // start with the reference to the real root\n    template &lt;typename F, typename = enable_if_fvisit&lt;F, T&gt;&gt;\n    auto preorder(const F &amp;fvisit) const { visit&lt;Order::Pre&gt;(fvisit, m_root); }\n    template &lt;typename F, typename = enable_if_fvisit&lt;F, T&gt;&gt;\n    auto inorder(const F &amp;fvisit) const { visit&lt;Order::In&gt;(fvisit, m_root); }\n    template &lt;typename F, typename = enable_if_fvisit&lt;F, T&gt;&gt;\n    auto postorder(const F &amp;fvisit) const { visit&lt;Order::Post&gt;(fvisit, m_root); }\n};\n\n// Solution Function\ntemplate &lt;typename I, typename F&gt;\nauto\nsolution(I in, F fout, int size) {\n    auto tree = StdTree{};\n    while(size--)\n        tree.insert(*in++);\n\n    tree.inorder(fout);\n}\n\n// Main\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto out = std::ostream_iterator&lt;int&gt;{std::cout, \" \"}; // out iter\n    auto oerr = std::ostream_iterator&lt;double&gt;(std::cerr, \"\\n\");\n\n    auto reps = 1;\n#ifdef REPS\n    reps = REPS;\n#endif\n    auto t = *in++;\n    auto v = std::vector&lt;int&gt;(t);\n    auto vin = v.begin();\n    std::copy_n(in, t, vin); //\n\n    auto fout = [&amp;out](const auto &amp;x){ out = x; };\n    auto fakeout = [](const auto &amp;){};\n\n    auto start = std::chrono::steady_clock::now();\n\n    solution(vin, fout, t); // to match expected output\n    while(--reps)\n        solution(vin, fakeout, t); // extra rounds output nothing\n\n    auto stop = std::chrono::steady_clock::now();\n    auto elapsed_seconds = std::chrono::\n        duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(stop - start).count();\n    oerr = elapsed_seconds;\n    return 0;\n}\n</code></pre> <p>GitHub: 19-tree-traversal-iii/tree-traversal-iii-01.cpp </p>"},{"location":"0190-tree-traversal-iii/#uniqueptr-t-templatedcontsexpress-traversals-91","title":"UniquePtr T-Templated/Contsexpress Traversals - 91","text":"<pre><code>#include &lt;algorithm&gt; // std::copy_n\n#include &lt;chrono&gt; // std::chrono::xx\n#include &lt;iostream&gt; // std::cout/cin\n#include &lt;iterator&gt; // std::istream/ostream_iterator\n#include &lt;memory&gt; // std::unique_ptr\n#include &lt;vector&gt; // std::vector\n\ntemplate &lt;class T = int&gt;\nclass UniquePtrTree {\n    struct Node {\n        T m_data;\n        using NodePtr = std::unique_ptr&lt;Node&gt;;\n        NodePtr left, right;\n        Node(const T &amp;data) : m_data{data} {};\n        auto static create(const T &amp;d) { return std::make_unique&lt;Node&gt;(d); }\n    };\n\n    using NodePtr = typename Node::NodePtr;\n    NodePtr m_root;\n\n    auto insert(const T &amp;data, NodePtr &amp;node) {\n        if(not node) {\n            node = Node::create(data);\n            return;\n        }\n        insert(data, data &lt; node-&gt;m_data ? node-&gt;left : node-&gt;right);\n    }\n\n    enum class Order { Pre, Post, In };\n\n    template &lt;Order order, typename F&gt;\n    auto visit(const F &amp;fvisit, const NodePtr &amp;node) const {\n        if (not node)\n            return;\n\n        if constexpr (order == Order::Pre) fvisit(node-&gt;m_data); // pre\n        visit&lt;order&gt;(fvisit, node-&gt;left); // visit left\n        if constexpr (order == Order::In) fvisit(node-&gt;m_data); // inorder\n        visit&lt;order&gt;(fvisit, node-&gt;right); // visit right\n        if constexpr (order == Order::Post) fvisit(node-&gt;m_data); // post\n    }\n\npublic:\n    auto insert(const T &amp;data) { insert(data, m_root); };\n\n    template &lt;typename F&gt;\n    auto preorder(const F &amp;fvisit) const { visit&lt;Order::Pre&gt;(fvisit, m_root); }\n    template &lt;typename F&gt;\n    auto postorder(const F &amp;fvisit) const { visit&lt;Order::Post&gt;(fvisit, m_root); }\n    template &lt;typename F&gt;\n    auto inorder(const F &amp;fvisit) const { visit&lt;Order::In&gt;(fvisit, m_root); }\n};\n\ntemplate &lt;typename I, typename F&gt;\nauto\nsolution(I in, F fout, int size) {\n    auto tree = UniquePtrTree{};\n    while(size--)\n        tree.insert(*in++);\n\n    tree.postorder(fout);\n}\n\n// Main\nint\nmain(int, char *[]) {\n    auto in = std::istream_iterator&lt;int&gt;{std::cin}; // input iterator\n    auto out = std::ostream_iterator&lt;int&gt;{std::cout, \" \"}; // out iter\n    auto oerr = std::ostream_iterator&lt;double&gt;(std::cerr, \"\\n\");\n\n    auto reps = 1;\n#ifdef REPS\n    reps = REPS;\n#endif\n    auto t = *in++;\n    auto v = std::vector&lt;int&gt;(t);\n    auto vin = v.begin();\n    std::copy_n(in, t, vin); // vin is not invalidated\n\n    auto fout = [&amp;out](const auto &amp;x){ out = x; };\n    auto fakeout = [](const auto &amp;){};\n\n    auto start = std::chrono::steady_clock::now();\n    solution(vin, fout, t); // to match expected output\n    while(--reps)\n        solution(vin, fakeout, t); // extra rounds for timing, no output\n    auto stop = std::chrono::steady_clock::now();\n    auto elapsed_seconds = std::chrono::\n        duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(stop - start).count();\n    oerr = elapsed_seconds;\n    return 0;\n}\n</code></pre> <p>GitHub: 18-tree-traversal-ii/tree-traversal-ii-91.cpp </p>"},{"location":"9995-colophon/","title":"Colophon","text":"<p>(C) 2025 Daniel Rodriguez</p> <pre><code>Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International\nPublic License\n\nBy exercising the Licensed Rights (defined below), You accept and agree\nto be bound by the terms and conditions of this Creative Commons\nAttribution-NonCommercial-ShareAlike 4.0 International Public License\n(\"Public License\"). To the extent this Public License may be\ninterpreted as a contract, You are granted the Licensed Rights in\nconsideration of Your acceptance of these terms and conditions, and the\nLicensor grants You such rights in consideration of benefits the\nLicensor receives from making the Licensed Material available under\nthese terms and conditions.\n\n\nSection 1 -- Definitions.\n\n  a. Adapted Material means material subject to Copyright and Similar\n     Rights that is derived from or based upon the Licensed Material\n     and in which the Licensed Material is translated, altered,\n     arranged, transformed, or otherwise modified in a manner requiring\n     permission under the Copyright and Similar Rights held by the\n     Licensor. For purposes of this Public License, where the Licensed\n     Material is a musical work, performance, or sound recording,\n     Adapted Material is always produced where the Licensed Material is\n     synched in timed relation with a moving image.\n\n  b. Adapter's License means the license You apply to Your Copyright\n     and Similar Rights in Your contributions to Adapted Material in\n     accordance with the terms and conditions of this Public License.\n\n  c. BY-NC-SA Compatible License means a license listed at\n     creativecommons.org/compatiblelicenses, approved by Creative\n     Commons as essentially the equivalent of this Public License.\n\n  d. Copyright and Similar Rights means copyright and/or similar rights\n     closely related to copyright including, without limitation,\n     performance, broadcast, sound recording, and Sui Generis Database\n     Rights, without regard to how the rights are labeled or\n     categorized. For purposes of this Public License, the rights\n     specified in Section 2(b)(1)-(2) are not Copyright and Similar\n     Rights.\n\n  e. Effective Technological Measures means those measures that, in the\n     absence of proper authority, may not be circumvented under laws\n     fulfilling obligations under Article 11 of the WIPO Copyright\n     Treaty adopted on December 20, 1996, and/or similar international\n     agreements.\n\n  f. Exceptions and Limitations means fair use, fair dealing, and/or\n     any other exception or limitation to Copyright and Similar Rights\n     that applies to Your use of the Licensed Material.\n\n  g. License Elements means the license attributes listed in the name\n     of a Creative Commons Public License. The License Elements of this\n     Public License are Attribution, NonCommercial, and ShareAlike.\n\n  h. Licensed Material means the artistic or literary work, database,\n     or other material to which the Licensor applied this Public\n     License.\n\n  i. Licensed Rights means the rights granted to You subject to the\n     terms and conditions of this Public License, which are limited to\n     all Copyright and Similar Rights that apply to Your use of the\n     Licensed Material and that the Licensor has authority to license.\n\n  j. Licensor means the individual(s) or entity(ies) granting rights\n     under this Public License.\n\n  k. NonCommercial means not primarily intended for or directed towards\n     commercial advantage or monetary compensation. For purposes of\n     this Public License, the exchange of the Licensed Material for\n     other material subject to Copyright and Similar Rights by digital\n     file-sharing or similar means is NonCommercial provided there is\n     no payment of monetary compensation in connection with the\n     exchange.\n\n  l. Share means to provide material to the public by any means or\n     process that requires permission under the Licensed Rights, such\n     as reproduction, public display, public performance, distribution,\n     dissemination, communication, or importation, and to make material\n     available to the public including in ways that members of the\n     public may access the material from a place and at a time\n     individually chosen by them.\n\n  m. Sui Generis Database Rights means rights other than copyright\n     resulting from Directive 96/9/EC of the European Parliament and of\n     the Council of 11 March 1996 on the legal protection of databases,\n     as amended and/or succeeded, as well as other essentially\n     equivalent rights anywhere in the world.\n\n  n. You means the individual or entity exercising the Licensed Rights\n     under this Public License. Your has a corresponding meaning.\n\n\nSection 2 -- Scope.\n\n  a. License grant.\n\n       1. Subject to the terms and conditions of this Public License,\n          the Licensor hereby grants You a worldwide, royalty-free,\n          non-sublicensable, non-exclusive, irrevocable license to\n          exercise the Licensed Rights in the Licensed Material to:\n\n            a. reproduce and Share the Licensed Material, in whole or\n               in part, for NonCommercial purposes only; and\n\n            b. produce, reproduce, and Share Adapted Material for\n               NonCommercial purposes only.\n\n       2. Exceptions and Limitations. For the avoidance of doubt, where\n          Exceptions and Limitations apply to Your use, this Public\n          License does not apply, and You do not need to comply with\n          its terms and conditions.\n\n       3. Term. The term of this Public License is specified in Section\n          6(a).\n\n       4. Media and formats; technical modifications allowed. The\n          Licensor authorizes You to exercise the Licensed Rights in\n          all media and formats whether now known or hereafter created,\n          and to make technical modifications necessary to do so. The\n          Licensor waives and/or agrees not to assert any right or\n          authority to forbid You from making technical modifications\n          necessary to exercise the Licensed Rights, including\n          technical modifications necessary to circumvent Effective\n          Technological Measures. For purposes of this Public License,\n          simply making modifications authorized by this Section 2(a)\n          (4) never produces Adapted Material.\n\n       5. Downstream recipients.\n\n            a. Offer from the Licensor -- Licensed Material. Every\n               recipient of the Licensed Material automatically\n               receives an offer from the Licensor to exercise the\n               Licensed Rights under the terms and conditions of this\n               Public License.\n\n            b. Additional offer from the Licensor -- Adapted Material.\n               Every recipient of Adapted Material from You\n               automatically receives an offer from the Licensor to\n               exercise the Licensed Rights in the Adapted Material\n               under the conditions of the Adapter's License You apply.\n\n            c. No downstream restrictions. You may not offer or impose\n               any additional or different terms or conditions on, or\n               apply any Effective Technological Measures to, the\n               Licensed Material if doing so restricts exercise of the\n               Licensed Rights by any recipient of the Licensed\n               Material.\n\n       6. No endorsement. Nothing in this Public License constitutes or\n          may be construed as permission to assert or imply that You\n          are, or that Your use of the Licensed Material is, connected\n          with, or sponsored, endorsed, or granted official status by,\n          the Licensor or others designated to receive attribution as\n          provided in Section 3(a)(1)(A)(i).\n\n  b. Other rights.\n\n       1. Moral rights, such as the right of integrity, are not\n          licensed under this Public License, nor are publicity,\n          privacy, and/or other similar personality rights; however, to\n          the extent possible, the Licensor waives and/or agrees not to\n          assert any such rights held by the Licensor to the limited\n          extent necessary to allow You to exercise the Licensed\n          Rights, but not otherwise.\n\n       2. Patent and trademark rights are not licensed under this\n          Public License.\n\n       3. To the extent possible, the Licensor waives any right to\n          collect royalties from You for the exercise of the Licensed\n          Rights, whether directly or through a collecting society\n          under any voluntary or waivable statutory or compulsory\n          licensing scheme. In all other cases the Licensor expressly\n          reserves any right to collect such royalties, including when\n          the Licensed Material is used other than for NonCommercial\n          purposes.\n\n\nSection 3 -- License Conditions.\n\nYour exercise of the Licensed Rights is expressly made subject to the\nfollowing conditions.\n\n  a. Attribution.\n\n       1. If You Share the Licensed Material (including in modified\n          form), You must:\n\n            a. retain the following if it is supplied by the Licensor\n               with the Licensed Material:\n\n                 i. identification of the creator(s) of the Licensed\n                    Material and any others designated to receive\n                    attribution, in any reasonable manner requested by\n                    the Licensor (including by pseudonym if\n                    designated);\n\n                ii. a copyright notice;\n\n               iii. a notice that refers to this Public License;\n\n                iv. a notice that refers to the disclaimer of\n                    warranties;\n\n                 v. a URI or hyperlink to the Licensed Material to the\n                    extent reasonably practicable;\n\n            b. indicate if You modified the Licensed Material and\n               retain an indication of any previous modifications; and\n\n            c. indicate the Licensed Material is licensed under this\n               Public License, and include the text of, or the URI or\n               hyperlink to, this Public License.\n\n       2. You may satisfy the conditions in Section 3(a)(1) in any\n          reasonable manner based on the medium, means, and context in\n          which You Share the Licensed Material. For example, it may be\n          reasonable to satisfy the conditions by providing a URI or\n          hyperlink to a resource that includes the required\n          information.\n       3. If requested by the Licensor, You must remove any of the\n          information required by Section 3(a)(1)(A) to the extent\n          reasonably practicable.\n\n  b. ShareAlike.\n\n     In addition to the conditions in Section 3(a), if You Share\n     Adapted Material You produce, the following conditions also apply.\n\n       1. The Adapter's License You apply must be a Creative Commons\n          license with the same License Elements, this version or\n          later, or a BY-NC-SA Compatible License.\n\n       2. You must include the text of, or the URI or hyperlink to, the\n          Adapter's License You apply. You may satisfy this condition\n          in any reasonable manner based on the medium, means, and\n          context in which You Share Adapted Material.\n\n       3. You may not offer or impose any additional or different terms\n          or conditions on, or apply any Effective Technological\n          Measures to, Adapted Material that restrict exercise of the\n          rights granted under the Adapter's License You apply.\n\n\nSection 4 -- Sui Generis Database Rights.\n\nWhere the Licensed Rights include Sui Generis Database Rights that\napply to Your use of the Licensed Material:\n\n  a. for the avoidance of doubt, Section 2(a)(1) grants You the right\n     to extract, reuse, reproduce, and Share all or a substantial\n     portion of the contents of the database for NonCommercial purposes\n     only;\n\n  b. if You include all or a substantial portion of the database\n     contents in a database in which You have Sui Generis Database\n     Rights, then the database in which You have Sui Generis Database\n     Rights (but not its individual contents) is Adapted Material,\n     including for purposes of Section 3(b); and\n\n  c. You must comply with the conditions in Section 3(a) if You Share\n     all or a substantial portion of the contents of the database.\n\nFor the avoidance of doubt, this Section 4 supplements and does not\nreplace Your obligations under this Public License where the Licensed\nRights include other Copyright and Similar Rights.\n\n\nSection 5 -- Disclaimer of Warranties and Limitation of Liability.\n\n  a. UNLESS OTHERWISE SEPARATELY UNDERTAKEN BY THE LICENSOR, TO THE\n     EXTENT POSSIBLE, THE LICENSOR OFFERS THE LICENSED MATERIAL AS-IS\n     AND AS-AVAILABLE, AND MAKES NO REPRESENTATIONS OR WARRANTIES OF\n     ANY KIND CONCERNING THE LICENSED MATERIAL, WHETHER EXPRESS,\n     IMPLIED, STATUTORY, OR OTHER. THIS INCLUDES, WITHOUT LIMITATION,\n     WARRANTIES OF TITLE, MERCHANTABILITY, FITNESS FOR A PARTICULAR\n     PURPOSE, NON-INFRINGEMENT, ABSENCE OF LATENT OR OTHER DEFECTS,\n     ACCURACY, OR THE PRESENCE OR ABSENCE OF ERRORS, WHETHER OR NOT\n     KNOWN OR DISCOVERABLE. WHERE DISCLAIMERS OF WARRANTIES ARE NOT\n     ALLOWED IN FULL OR IN PART, THIS DISCLAIMER MAY NOT APPLY TO YOU.\n\n  b. TO THE EXTENT POSSIBLE, IN NO EVENT WILL THE LICENSOR BE LIABLE\n     TO YOU ON ANY LEGAL THEORY (INCLUDING, WITHOUT LIMITATION,\n     NEGLIGENCE) OR OTHERWISE FOR ANY DIRECT, SPECIAL, INDIRECT,\n     INCIDENTAL, CONSEQUENTIAL, PUNITIVE, EXEMPLARY, OR OTHER LOSSES,\n     COSTS, EXPENSES, OR DAMAGES ARISING OUT OF THIS PUBLIC LICENSE OR\n     USE OF THE LICENSED MATERIAL, EVEN IF THE LICENSOR HAS BEEN\n     ADVISED OF THE POSSIBILITY OF SUCH LOSSES, COSTS, EXPENSES, OR\n     DAMAGES. WHERE A LIMITATION OF LIABILITY IS NOT ALLOWED IN FULL OR\n     IN PART, THIS LIMITATION MAY NOT APPLY TO YOU.\n\n  c. The disclaimer of warranties and limitation of liability provided\n     above shall be interpreted in a manner that, to the extent\n     possible, most closely approximates an absolute disclaimer and\n     waiver of all liability.\n\n\nSection 6 -- Term and Termination.\n\n  a. This Public License applies for the term of the Copyright and\n     Similar Rights licensed here. However, if You fail to comply with\n     this Public License, then Your rights under this Public License\n     terminate automatically.\n\n  b. Where Your right to use the Licensed Material has terminated under\n     Section 6(a), it reinstates:\n\n       1. automatically as of the date the violation is cured, provided\n          it is cured within 30 days of Your discovery of the\n          violation; or\n\n       2. upon express reinstatement by the Licensor.\n\n     For the avoidance of doubt, this Section 6(b) does not affect any\n     right the Licensor may have to seek remedies for Your violations\n     of this Public License.\n\n  c. For the avoidance of doubt, the Licensor may also offer the\n     Licensed Material under separate terms or conditions or stop\n     distributing the Licensed Material at any time; however, doing so\n     will not terminate this Public License.\n\n  d. Sections 1, 5, 6, 7, and 8 survive termination of this Public\n     License.\n\n\nSection 7 -- Other Terms and Conditions.\n\n  a. The Licensor shall not be bound by any additional or different\n     terms or conditions communicated by You unless expressly agreed.\n\n  b. Any arrangements, understandings, or agreements regarding the\n     Licensed Material not stated herein are separate from and\n     independent of the terms and conditions of this Public License.\n\n\nSection 8 -- Interpretation.\n\n  a. For the avoidance of doubt, this Public License does not, and\n     shall not be interpreted to, reduce, limit, restrict, or impose\n     conditions on any use of the Licensed Material that could lawfully\n     be made without permission under this Public License.\n\n  b. To the extent possible, if any provision of this Public License is\n     deemed unenforceable, it shall be automatically reformed to the\n     minimum extent necessary to make it enforceable. If the provision\n     cannot be reformed, it shall be severed from this Public License\n     without affecting the enforceability of the remaining terms and\n     conditions.\n\n  c. No term or condition of this Public License will be waived and no\n     failure to comply consented to unless expressly agreed to by the\n     Licensor.\n\n  d. Nothing in this Public License constitutes or may be interpreted\n     as a limitation upon, or waiver of, any privileges and immunities\n     that apply to the Licensor or You, including from the legal\n     processes of any jurisdiction or authority.\n</code></pre>"},{"location":"downloads/","title":"Downloads","text":"<p>The entire content can be downloaded in the form a PDF book.</p> <ul> <li> <p>Screen Format - c++17-iterating-problems-1.3.19-en-screen.pdf </p> <p>This is meant for PDF readers and online display. The left and right margins are the same and there are no interleaved blank pages.</p> </li> <li> <p>Prepress Format - c++17-iterating-problems-1.3.19-en-prepress.pdf </p> <p>This is intended for generating a printout. The left and right margins alternate to leave room for bookbinding and blank pages may be inserted so that chapters always start on a right-hand page.</p> </li> </ul>"}]}